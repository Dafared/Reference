## 1.深度优先搜索

搜索方向,是认准一个方向搜,直到碰壁之后再换方向
换方向是撤销原路径,改为节点链接的下一个路径,回溯的过程

```c++
// DFS 代码框架
void dfs(参数) {
    if (终止条件) {
        保存结果;
        return;
    }

    for (选择:本节点所连接的其他节点) {
        处理节点;
        dfs(图,选择的节点); // 递归
        回溯,撤销处理结果
    }
}
```

深搜三部曲:
①确认递归函数
②确认终止条件
③处理目前搜索节点出发的路径

根据题目,DFS有时应当使用visited数组作为访问过的标记,否则可能超时或栈溢出!

> DFS设置visited应该在函数开始处,if后,for前,不能在递归调用dfs()前,原因见第4题

有向图路径问题,最合适使用深搜(相比广搜更简单)

## 2.广度优先搜索

广搜的搜索方式就适合于解决两个点之间的最短路径问题
因广搜是从起点为中心一圈一圈搜索,**一旦遇到终点,记录之前走过的节点一定是一条最短路**

有些问题,不涉及具体遍历方式,只要把相邻且相同属性的节点标记上就行,广搜深搜都可以

BFS大多数使用队列

> 使用其他数据机构,如栈,数组也可以;但队列更方便
> 如用栈,就是第一圈顺时针遍历,第二圈逆时针遍历,第三圈有顺时针遍历

元素访问,加入队列时也要标记visited数组!

> **注意:标记visited是在加入队列时(①起始节点入队②BFS过程中邻居节点入队),而不是在出队列时才设置visited!**

```c++
// BFS代码框架
定义队列;
起始节点加入队列;
起始点加入队列后立刻标记为访问过的节点(visited标记);
while(!que.empty()){// 遍历
    从队列拿出元素(front()+pop());
    for(遍历该元素周围的元素){
        把没被访问过的邻居加入队列;
        只要加入队列,立刻标记visited标记,防止重复访问;
        //结点加入队列时就要标记,不能拿出时才标记(导致重复访问)
    }
}
```

## 3.岛屿数量

遍历网格所有点,每遇到未访问过的陆地方格,岛屿数量+1,并以该陆地为起点调用dfs/bfs
dfs/bfs会把与该陆地方格相连的所有陆地都标记为已访问过

**DFS:**

**注意,可以不使用visited数组,直接把访问过的标记为海洋!**
(不使用另外的空间,直接在原来所给的二维数组上进行标记!)

```c++
class Solution {
public:
    vector<vector<int>> directions{{0,1},{0,-1},{1,0},{-1,0}};
    void dfs(vector<vector<char>>& grid, vector<vector<bool>> &visited, int starti, int startj) {
        visited[starti][startj] = true;
        for (int i=0; i<4; i++) {
            int nexti = starti + directions[i][0];
            int nextj = startj + directions[i][1];
            if (nexti >= grid.size() || nexti < 0 || nextj >= grid[0].size() || nextj < 0) {
                continue;
            }
            if (visited[nexti][nextj] == true || grid[nexti][nextj] == '0') {
                continue;
            }
            dfs(grid,visited,nexti,nextj);
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));
        int count = 0;
        for (int i=0; i<grid.size(); i++) {
            for (int j=0; j<grid[0].size(); j++) {
                if (grid[i][j] == '1' && visited[i][j] == false) {
                    count++;
                    dfs(grid, visited, i, j);
                }
            }
        }
        return count;
    }
};
```

**BFS:**

```c++
class Solution {
public:
    int directions[4][2] = {0,1,0,-1,1,0,-1,0};
    void bfs(vector<vector<char>>& grid, vector<vector<bool>> &visited, int starti, int startj) {
        queue<pair<int,int>> que;
        que.push({starti,startj});
        visited[starti][startj] = true;
        while (!que.empty()) {
            pair<int,int> cur = que.front();
            que.pop();
            int nexti,nextj;
            for (int i=0; i<4; i++) {
                nexti = cur.first + directions[i][0];
                nextj = cur.second + directions[i][1];
                if (nexti >= grid.size() || nexti < 0 || nextj >= grid[0].size() || nextj < 0) {
                    continue;
                }
                if (visited[nexti][nextj] == true || grid[nexti][nextj] == '0') {
                    continue;
                }
                visited[nexti][nextj] = true;
                que.push({nexti,nextj});
            }
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));
        int count = 0;
        for (int i=0; i<grid.size(); i++) {
            for (int j=0; j<grid[0].size(); j++) {
                if (grid[i][j] == '1' && visited[i][j] == false) {
                    count++;
                    bfs(grid, visited, i, j);
                }
            }
        }
        return count;
    }
}
```

## 4.岛屿的最大面积

遍历网格所有点,每遇到没访问过的陆地方格,以该陆地为起点调用dfs/bfs
dfs/bfs会统计该陆地方格所属岛屿的大小,最后全过程中得到的取最大值

本题dfs有两种写法,注意根据dfs函数中count++位置的不同,调用前count要初始化为0还是1

> 如count++写在给下一个要访问的位置调用dfs()之前,count要初始化为1
> count++写在dfs函数开始处,遍历当前方块的周围位置的for循环之前,count初始化为0

**本题代码注意:**

> 假设count++写在dfs函数开始处,遍历当前方块的周围位置的for循环之前(count初始化=0)
>
> ```c++
> //停止递归的条件有2种,1.越界2.不是陆地或已访问过,2个条件分别如下:
> if(nextX>=grid.size()||nextX<0||nextY>=grid[0].size()||nextY<0)
> if(grid[x][y]==0||visited[x][y]==1)
>     
> //判断条件的位置也有2个1.dfs函数体开始处,不符合条件直接return
> //2.遍历当前方格周围位置过程中,调用dfs函数递归之前.不符合则continue,循环跳过   
> ```
>
> ①如果条件1和条件2一起写在位置1(函数开始处),设置visited和count++在条件判断之后
> 当1或2不满足,只有递归调用了以后进入递归函数后才能停止递归,每次递归消耗资源,导致栈溢出
>
> ②如果设置visited在单层递归的for循环中,调用dfs之前(设置下一个要被访问的陆地的visited数组=1)
> 导致每个岛屿第一个被访问到的陆地方块无法设置visited标志=1
>
> > ※:BFS可以把设置visited写在入队前,因为BFS的函数不是递归调用的,因此函数开始可以对本次BFS的起始点特殊处理,设置起始点visited=1;但由于DFS是递归调用的,无法在函数体内对本次DFS的起始点特殊设置
>
> 因此,要避免以上两种写法
> ①不要把所有判断条件都写在dfs函数体开始
> ②不要把设置下一个方块已访问(visited)写在给下一个要访问的位置调用dfs()之前,应该把设置visited写在函数体开始处,for循环之前(和count++写在一起,且设置的是当前访问方块visited);
>
> 正确写法:
> ①条件1和条件2判断全写在位置2,设置当前访问方块visited写在for循环之前的count++处
> ②条件1写在位置2,越界continue;判断条件2写在函数刚开始,不符合return,设置当前访问方块visited写在for循环之前count++处

**代码:**(直接在grid中设为海洋(0)来起到visited数组的作用)

```c++
class Solution {
public:
    int directions[4][2] = {0,1,0,-1,1,0,-1,0};
    void dfs(vector<vector<int>>& grid, int starti, int startj, int &count) {
        count++;
        grid[starti][startj] = 0;
        for (int i=0; i<4; i++) {
            int nexti = starti + directions[i][0];
            int nextj = startj + directions[i][1];
            if (nexti >= 0 && nexti < grid.size() && nextj >= 0 && nextj < grid[0].size()) {
                if (grid[nexti][nextj] == 1) {
                    dfs(grid,nexti,nextj,count);
                }
            }
        }
    }
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int maxcount = 0;
        for (int i=0; i<grid.size(); i++) {
            for (int j=0; j<grid[0].size(); j++) {
                if (grid[i][j] == 1) {
                    int count = 0;
                    dfs(grid,i,j,count);
                    maxcount = count > maxcount ? count : maxcount;
                }
            }
        }
        return maxcount;
    }
};
```

## 5.飞地数量

从4个边出发用DFS/BFS找相邻陆地,将周边靠陆地且相邻的陆地都变成海洋,然后再去重新遍历地图每个方格的时候,把仍然是陆地的方格作为出发点调用DFS/BFS,统计此时还剩下的陆地就可以了

(在搜索中,把访问过的陆地标记为海洋,起到了BFSvisited标记的作用)

## 6.被围绕的区域

给你一个 m x n 的矩阵 board ,由若干字符 'X' 和 'O' ,找到初始矩阵中所有被 'X' 围绕的区域,并将这些区域里所有的 'O' 用 'X' 填充(刚开始不被X包围,填充X以后才被包围的O不算)

被围绕的区间不会存在于边界上,换句话说,任何边界上的 'O' 都不会被填充为 'X'
因此,所有与边界上的 'O' 相连的 'O'都不会被填充成X,则本题思路和上一题类似

①从矩阵边界的'O'开始深搜/广搜,将和处于地图的边界的'O'相连的'O'全部改成'A'
②遍历地图每个方块,把剩下未被改成'A'的'O'全改'X',之前的'A'全改回'O'

## 7.两大洋水流问题

大西洋和太平洋分别定义一个visited数组
从边界开始,用bfs/dfs遍历,标记能流到大西洋/太平洋的方格
最后遍历所有方格,记录同时被标记能流入大西洋和太平洋的方格

```c++
class Solution {
public:
    int directions[4][2] = {0,1,0,-1,1,0,-1,0};
    void dfs_pacific(vector<vector<int>>& heights,int starti,int startj,vector<vector<int>> &visit) {
        visit[starti][startj] = 1;
        for (int i=0; i<4; i++) {
            int nexti = starti + directions[i][0];
            int nextj = startj + directions[i][1];
            if (nexti >= 0 && nexti < heights.size() && nextj >= 0 && nextj < heights[0].size()) {
                if (heights[nexti][nextj] >= heights[starti][startj] && visit[nexti][nextj] == 0) {
                    dfs_pacific(heights,nexti,nextj,visit);
                }
            }
        }
    }
    void dfs_atlantic(vector<vector<int>>& heights,int starti,int startj,vector<vector<int>> &visit) {
        
        if(visit[starti][startj] == 1) {
            visit[starti][startj] = 3;
        } else if (visit[starti][startj] == 0){
            visit[starti][startj] = 2;
        }

        for (int i=0; i<4; i++) {
            int nexti = starti + directions[i][0];
            int nextj = startj + directions[i][1];
            if (nexti >= 0 && nexti < heights.size() && nextj >= 0 && nextj < heights[0].size()) {
                if (heights[nexti][nextj] >= heights[starti][startj] && visit[nexti][nextj] <= 1) {
                    dfs_atlantic(heights,nexti,nextj,visit);
                }
            }
        }
    }
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        vector<vector<int>> res;
        vector<vector<int>> visit(heights.size(),vector<int>(heights[0].size(),0));
        for (int i=0; i<heights.size(); i++) {
            dfs_pacific(heights,i,0,visit);
        }
        for (int j=0; j<heights[0].size(); j++) {
            dfs_pacific(heights,0,j,visit);
        }
        for (int i=0; i<heights.size(); i++) {
            dfs_atlantic(heights,i,heights[0].size()-1,visit);
        }
        for (int j=0; j<heights[0].size(); j++) {
            dfs_atlantic(heights,heights.size()-1,j,visit);
        }
        for (int i=0; i<visit.size(); i++) {
            for (int j=0; j<visit[0].size(); j++) {
                if (visit[i][j] == 3) {
                    res.push_back({i,j});
                }
            }
        }
        return res;
    }
};
```

## 8.最大人工岛

暴力,`O(N^4)`
优化思路:暴力解法做了很多重复的工作,只需用一次深搜把每个岛屿的面积记录下来

第一步:遍历地图,得出各岛屿的面积,并做编号记录,可用map记录,key为岛屿编号,value为岛屿面积
第二步:再次遍历地图,遍历所有0的方格(因要将0变成1)并统计该1(由0变成的1)相邻各个岛屿面积,将其相邻面积相加在一起,遍历所有 0 之后,就可以选出选一个0变成1之后的最大面积

**把visited数组或地图二维数组中某个岛屿拥有的的所有陆地方格用该岛屿的数字编号标记**
(除了标记已访问外,方便每个0知道周围的陆地属于哪个岛屿)
(为了避免与原来的1混淆,编号从2开始,这样还可以顺便充当visited数组的作用)

```c++
class Solution {
public:
    int directions[4][2] = {0,1,0,-1,1,0,-1,0};
    void dfs(vector<vector<int>>& grid, int starti, int startj, int count, int &square) {
        square++;
        grid[starti][startj] = count;
        for (int i=0; i<4; i++) {
            int nexti = starti + directions[i][0];
            int nextj = startj + directions[i][1];
            if (nexti >= 0 && nexti < grid.size() && nextj >= 0 && nextj < grid[0].size()) {
                if (grid[nexti][nextj] == 1) {
                    dfs(grid,nexti,nextj,count,square);
                }
            }
        }
    }
    int largestIsland(vector<vector<int>>& grid) {
        int count = 2;
        unordered_map<int,int> areamap;
        bool is_all_one = true;
        for (int i=0; i<grid.size(); i++) {
            for (int j=0; j<grid[0].size(); j++) {
                if (grid[i][j] == 0) {
                    is_all_one = false;
                }
                if (grid[i][j] == 1) {
                    int s = 0;
                    dfs(grid,i,j,count,s);
                    areamap[count] = s;
                    count++;
                }
            }
        }
        // 特殊处理原grid全是1的情况
        if (is_all_one) {
            return (grid.size() * grid[0].size());
        }
        // 若原grid全是0,则填上一块陆地,岛屿面积至少为1,所以max初始=1
        int max = 1;
        for (int i=0; i<grid.size(); i++) {
            for (int j=0; j<grid[0].size(); j++) {
                if(grid[i][j] == 0) {
                    int island_s = 1;
                    unordered_set<int> neighbors; // 记录0周围的岛屿编号,防止相同岛屿重复相加
                    for (int k=0; k<4; k++) {
                        int nexti = i + directions[k][0];
                        int nextj = j + directions[k][1];  
                        if (nexti >= 0 && nexti < grid.size() && 
                            	nextj >= 0 && nextj < grid[0].size()) {
                            if (grid[nexti][nextj] > 1) {
                                if(neighbors.find(grid[nexti][nextj])==neighbors.end()){
                                    neighbors.insert(grid[nexti][nextj]);
                                    island_s += areamap[grid[nexti][nextj]];
                                    max = max > island_s ? max : island_s;
                                }                                                    
                            }
                        }
                    }
                }
            }
        }
        return max;
    }
};
```

## 9.单词接龙

beginWord 和 endWord 的转换序列构成一个无向图
**只需要求出这个图中起点到终点的最短路径即可,所以用BFS**
(广搜只要到达终点就一定是最短路径)

这个图中的边是否存在需要自己判断
即两个单词之间只相差一个字符,则是存在连接

另外:①本题是一个无向图,需要用visited标记位,标记着节点是否走过,否则就会死循环
(使用**一个map记录某单词是否访问过**,访问过的节点加入该map)
(同时**该map的value值还可用于记录到该单词的路径长度**)

②本题给的是数组,可转成set,在替换当前单词每个字符后查找新单词是否在字典中存在时更快一些
(当前单词每个字符位置都分别用26个字母替换一遍,每次替换后检查得到新单词是否在字典中)

```c++
int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
    unordered_set<string> dir(wordList.begin(),wordList.end());
    queue<string> que;
    unordered_map<string,int> record;
    que.push(beginWord);
    record.insert({beginWord,1});
    while (!que.empty()) {
        string cur = que.front();
        que.pop();
        if (cur == endWord) {
            return record[cur];
        }
        for (int i=0; i<cur.size(); i++) {
            for (int c='a'; c<='z'; c++) {
                string next = cur;
                next[i] = c;
                if (dir.find(next) != dir.end() &&
                    record.find(next) == record.end()) {
                    record.insert({next,record[cur]+1});
                    que.push(next);
                }
            }
        }
    }
    return 0;
}
```

## 10.钥匙和房间

有 N 个房间,开始时你位于 0 号房间, 其他房间锁着, 每个房间放若干把其他房间的钥匙
如果能进入每个房间返回 true,否则返回 false

**本题所给的是一个有向图**,有连接不代表能到达
所以**无法使用并查集**,只用DFS/BFS

**最后如果visited数组每个房间都被访问过,则返回true**

## 11.岛屿的周长

二维网格地图 grid, 1表示陆地, 0表示水域, 其中已知有一个岛屿
计算这个岛屿的周长

本题没有必要使用DFS/BFS

解法一:
遍历每一个空格,遇到岛屿,计算其上下左右的情况,遇到水域或者出界的情况,就算边

解法二:
设相邻陆地块中间的边数总计等于cover(每有一对相邻地块,总边数减2)
岛屿与水域相邻的周长=`岛屿块数量*4-cover*2`

遍历每一个方格:
①统计陆地块数量
②统计相邻陆地块对数
(每走到一个陆地块,上面/左面有陆地,cover++(不统计下面/右面是为了避免重复计算))

## 12.寻宝(最小生成树)

https://kamacoder.com/problempage.php?pid=1053

确保访问所有岛屿的同时最小化路径的总距离

最小生成树是所有节点的最小连通子图
以最小的成本(边的权值)将图中所有节点链接到一起

图中有n个节点,则可用n-1条边将所有节点连接到一起

### Prim算法

#### 只求权值

prim算法是从节点的角度, 采用贪心的策略
每次寻找距离 当前最小生成树最近的节点, 并加入到最小生成树中

1. 选距离生成树最近节点
2. 最近节点加入生成树
3. 更新非生成树节点到生成树的距离(即更新minDist数组)

使用`minDist`数组记录 每个**非生成树节点**距离最小生成树的最近距离

minDist 数组 里的数值初始化为 最大数
(本题规定最大距离为10000,所以初始化为10001)

算法过程:

> 开始算法:选距离生成树最近节点,加入生成树:
> 刚开始还没有生成树,所以直接选数组中第一个节点加入
>
> 然后更新非生成树节点到生成树的最短距离(minDist数组):
> (更新所有可**直接到达**当前生成树所属节点的生成树外节点)
>
> 之后又开始第一步,从minDist数组中选取距当前生成树距离最小的节点
> ....
>
> 直到所有节点都被加入生成树
>
> 每进行一轮(三步)就建立最小生成树的一条边
> 所以需要**循环进行n-1次**

最后`minDist`数组中不包括最开始加入的第一个节点的其余n-1个元素:
记录的就是最小生成树中n-1边分别的权值(边长)

> **注意事项**
>
> ①本题中已经说了结点编号从1开始([1,v]),所以数组大小初始化为v+1而不是v
> 遍历各个节点也从1开始到v
>
> ②最小生成树中有n个节点,n-1条边
> 本题以下代码每次大循环都把isInTree数组中一个元素设为true,即把一个节点加入最小生成树
> 但并不意味着本题需循环n次,把n个点都加入最小生成树
>
> 实际上,每次循环把一个节点加入最小生成树后:
> 会用那些与该节点直接相连的节点到该节点的距离 更新 这些节点到最小生成树的距离(minDist数组)
> 每次循环内的这些更新中, 至少有一个是最终得到的最小生成树中的一条边
> (最后最小生成树的各边存储在minDist数组中)
>
> 所以每次循环实际上是建立了最小生成树的一条边,所以循环n-1次

**代码:**

```c++
#include<iostream>
#include<vector>
using namespace std;
int main() {
    int v, e;
    int x, y, k;
    cin >> v >> e;
    // 填一个默认最大值,题目描述val最大为10000
    vector<vector<int>> grid(v + 1, vector<int>(v + 1, 10001));
    while (e--) {
        cin >> x >> y >> k;
        // 因为是双向图,所以两个方向都要填上
        grid[x][y] = k;
        grid[y][x] = k;

    }
    // 所有节点到最小生成树的最小距离
    vector<int> minDist(v + 1, 10001);

    // 用bool的数组表示这个节点是否在树里
    vector<bool> isInTree(v + 1, false);

    // 我们只需要循环n-1次,建立n-1条边,就可以把n个节点的图连在一起
    // 从第一个节点开始
    for (int i = 1; i < v; i++) {

        // 1.prim三部曲,第一步：选距离生成树最近节点
        int cur = -1; // 选中哪个节点 加入最小生成树
        for (int j = 1; j <= v; j++) { // 1 - v,顶点编号,这里下标从1开始
            //  选取最小生成树节点的条件：
            //  1.不在最小生成树里
            //  2.距离最小生成树最近的节点
            //  3.刚开始都不在最小生成树里,先默认选一个节点,再比较哪一个是最小的
            //  (cur == -1 因为条件3)
            if (!isInTree[j] && (cur == -1 || minDist[j] < minDist[cur])) {
                cur = j;
            }
        }
        
        // 2.prim三部曲,第二步：最近节点（cur）加入生成树
        isInTree[cur] = true;

        // 3.prim三部曲,第三步:更新非生成树节点到生成树的距离(更新minDist数组)
        // 只需要关心图中与cur直接相连的那些非生成树节点到cur的距离
        for (int j = 1; j <= v; j++) {
            // 更新的条件：
            // 1.节点不是生成树里的节点
            // 2.与cur相连的某节点的权值比原来记录的该节点距离最小生成树的距离更小
            if (!isInTree[j] && grid[cur][j] < minDist[j]) {
                minDist[j] = grid[cur][j];
            }
        }
    }
    // 统计结果
    int result = 0;
    // 不计第一个顶点,因为统计的是边的权值,v个节点有v-1条边
    for (int i = 2; i <= v; i++) {
        result += minDist[i];
    }
    cout << result << endl;

}
```

#### 记录最小生成树的边

记录边:记录两个节点:一维数组就可以,parent[节点编号] =  节点编号
初始化:`vector<int> parent(v + 1, -1);`

在更新minDist数组时,去更新parent数组中记录的对应边

> **为什么是`parent[j]=cur`,而不是`parent[cur]=j`:**
>
> 因为同一个cur可能会更新多个j(更新minDist数组中多个元素)
> 这些更新都需要被记录,而第二种写法对以同一个cur为一端的边会反复覆盖

代码:

```c++
for (int j = 1; j <= v; j++) {
    if (!isInTree[j] && grid[cur][j] < minDist[j]) {
        minDist[j] = grid[cur][j];
        parent[j] = cur; // 记录最小生成树的边(注意数组指向的顺序)
    }
}
```

### Kruskal算法

Prim 算法是维护节点的集合,而 Kruskal 是维护边的集合

- 边的权值排序(因为要优先选最小的边加入到生成树里)
- 遍历排序后的边(从权值小的边开始,优先选权值小的边)
  - 边首尾的两个节点都已在集合内:说明如果连上这条边图中会出现环,不加入,跳过
  - 边首尾的两个节点不是都在集合内:则加入到最小生成树,并把两个节点加入集合

判断两个节点是否都在同一个集合中:**使用并查集**

```c++
struct Edge {
    int l, r, val;
};

/* 并查集实现,省略... */

int main() {
    int v, e;
    int v1, v2, val;
    vector<Edge> edges;
    int result_val = 0;
    cin >> v >> e;
    while (e--) {
        cin >> v1 >> v2 >> val;
        edges.push_back({v1, v2, val});
    }

    // 执行Kruskal算法
    // 按边的权值对边进行从小到大排序
    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {
            return a.val < b.val;
    });

    // 并查集初始化
    init();

    // 从头开始遍历边
    for (Edge edge : edges) {
        // 并查集,搜出两个节点的祖先
        int x = find(edge.l);
        int y = find(edge.r);

        // 如果祖先不同,则不在同一个集合
        if (x != y) {
            result_val += edge.val; // 这条边可以作为生成树的边
            join(x, y); // 两个节点加入到同一个集合
        }
    }
    cout << result_val << endl;
    return 0;
}
```

### 两种算法的比较

二者关键区别在于:prim维护的是节点的集合,而 Kruskal 维护的是边的集合
如果一个图中,节点多,但边相对较少(稀疏),那么使用Kruskal 更优
同理,在稠密图中,使用Prim算法更优

- Prim 时间复杂度为 O(n^2),其中 n 为节点数量,运行效率和图中边数无关,适用稠密图
- Kruskal 时间复杂度为 O(nlogn), 其中n 为边的数量, 适用稀疏图

## 13.最爱的城市(最短路)

https://kamacoder.com/problempage.php?pid=1024

### Dijkstra算法

计算从v0到其他点距离,初始化集合`S={v0}`,所有结点的集合为V
cost数组表示图中各节点到出发点v0的距离
(其中cost数组中,初始与v0直接相连的结点的值为其到v0的直接距离,其他结点为+∞)

①选择属于集合V-S的结点中在dist数组中值最小的那个结点,加入S
②更新cost数组各结点,看其途径这个新加入S的结点到达v0的距离是否比以前更近
③更新path数组(存放结点的直接前驱)

`if (!st[i]) dist[i] = min(dist[i], dist[t] + g[t][i]);`
(st数组表示当前是否已加入集合S)

代码:(一次会输入多组测试数据)

1.使用邻接矩阵存储:

```c++
#include <iostream>
#include <vector>

int main() {
    int n,m;
    const int MAX = 21;
    while (std::cin>>n>>m) {
        int a,b,val;
        int src,dst;
        
        std::vector<bool> used(n+1, false);
        std::vector<int> cost(n+1,MAX);
        std::vector<std::vector<int>> grid(n+1,std::vector<int>(n+1,MAX));
        
        while (m--) {
            std::cin>>a>>b>>val;
            grid[a][b] = val;
            grid[b][a] = val;
        }
        
        std::cin>>src>>dst;
        used[src] = true;
        cost[src] = 0;
        for (int i=1; i<=n; i++) {
            if (grid[src][i] != MAX) {
                cost[i] = grid[src][i];
            }
        }
        
        for (int i=1; i<n; i++) {
            int minindex = -1;
            int minvalue = MAX;
            for (int j=1; j<=n; j++) {
                if (!used[j] && cost[j] < minvalue) {
                    minvalue = cost[j];
                    minindex = j;
                }
            }
            if (minindex == -1) {
                break;
            }
            
            used[minindex] = true;
            
            for (int j=1; j<=n; j++) {
                if (cost[minindex] + grid[minindex][j] < cost[j]) {
                    cost[j] = cost[minindex] + grid[minindex][j];
                }
            }
        }  
        
        int res = cost[dst];
        if (res != MAX) {
            std::cout<<res<<std::endl;
        } else {
            std::cout<<"No path"<<std::endl;
        } 
    }
    
    return 0;
}
```

2.使用哈希表+优先队列(堆优化)

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
#include <queue>

int main() {
    int n,m;
    const int MAX = 21;
    while (std::cin>>n>>m) {
        int a,b,val;
        int src,dst;
        
        std::vector<bool> used(n+1, false);
        std::vector<int> cost(n+1,MAX);
        std::unordered_map<int, std::vector<std::pair<int, int>>> grid;
        
        while (m--) {
            std::cin>>a>>b>>val;
            grid[a].push_back({b,val});
            grid[b].push_back({a,val});
        }
        
        std::cin>>src>>dst;
        cost[src] = 0;
        std::priority_queue<std::pair<int,int>,std::vector<std::pair<int,int>>,
        	std::greater<std::pair<int,int>>> heap;
        heap.push({0,src});
        
        // grid中存储<a,<b,cost>>
		// heap中存储<cost,b>
        
        while (!heap.empty()) {
            auto min_edge = heap.top();
            heap.pop();
            
            if (used[min_edge.second] || min_edge.first > cost[min_edge.second]) {
                continue;
            }
            
            used[min_edge.second] = true;
            
            for (auto new_edge : grid[min_edge.second]) {
                if (cost[min_edge.second] + new_edge.second < cost[new_edge.first]) {
                    cost[new_edge.first] = cost[min_edge.second] + new_edge.second;
                    heap.push({cost[new_edge.first],new_edge.first});
                }
            }
            
        }        
        
        int res = cost[dst];
        if (res != MAX) {
            std::cout<<res<<std::endl;
        } else {
            std::cout<<"No path"<<std::endl;
        } 
    }
    
    return 0;
}
```

