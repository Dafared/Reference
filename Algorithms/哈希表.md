当我们遇到了要快速判断一个元素是否出现集合里的时候,就要考虑哈希法
(牺牲了空间换时间)

> 1.字母异位词: 哈希表存储单词中各个字母出现的次数
>
> 2.赎金信:哈希表存储各个字母出现次数
>
> > C数组设定默认值 int count[26] = { 0 };
>
> 3.按字母异位词分组:判断是否存在:使用哈希表
> 但分别存储并遍历每个字母判断是否是异位词太慢
>
> 为了通过哈希表中快速得知是否已存在某个字母异位词:
>
> - 构造一个用作比较的string key(格式为字母+次数)
> - 或利用字母异位词排序后相同的特点
>   排序后存入哈希表/用作key查询哈希表
>
> 4.找到所有字母异位词:
> 字母异位词的长度都相同,所以可以使用固定长度的**滑动窗口**
> 窗口滑动过程中维护:
> 1.记录当前窗口内每个字母和目标单词数量差的哈希表
> 2.当前窗口内每个字母和目标单词中该字母数量不相等的字母个数
> 当2的变量==0时即找到一个字母异位词
>
> 5.两个数组的交集: unordered_set存储数组中出现过的数字(不需要计数)
>
> 6.两个数组的交集Ⅱ:
> 1.哈希表(map)存储其中一个数组各个数字以及其出现的次数
> 之后遍历另一个哈希表,每遇到一个数字,就在哈希表中查找
> 如果存在,且哈希表中计数>0,就往交集中写入一次,并将哈希表中计数值-1
> 如第一个数组中数量更少,计数值会减为0,之后遇到了也不再记录
> 如第二个数组中数量更少,因只有在遍历第二个数组时遇到了才检查哈希表,所以也能符合题意
>
> 7.快乐数:根据题意对快乐数反复求和过程中,和会重复出现
> 所以用一个unordered_set存储出现过的和
>
> 8.两数之和:哈希表存储第一个数组的数字和下标
> 之后遍历第二个数组
>
> 9.三数之和:第一个数遍历,后两个数双指针
> 后两个数双指针一个left一个right,如果三数和`>0`,`right--`;和`<`0,`left++`
> 直到三数和`=0`时记录结果,之后left++,right--
> 第一个数遍历时可剪枝:如果第一个数>0,则后面都不用看了,continue
> 去重:避免选出重复的三元组,因为去重所以需要先排序
> 第一个数:`if(i>0 && nums[i-1] == nums[i]) continue;`
> 第二三个数:当找到三数和=0时:
> `while(left < right && nums[left] == nums[left+1]) left++;`
> `while(left < right && nums[right] == nums[right-1]) right--;`
>
> 10.四数之和:类似于三数之和,前两个数遍历,后两个数双指针
> 前两个数要剪枝
> 去重方法类似与上一题
>
> 11.四数相加Ⅱ:因为是四个独立数组,4元组内数字顺序有影响,不用去重
> 所以使用哈希表,
> 先遍历前两个数组,用哈希表(unordered_map)统计所有的两数之和及出现的次数
> 之后遍历后两个数组,假设遍历到后两个数组的两个元素分别是i,j
> 若哈希表中有元素0-i-j,最终答案count+=哈希表中0-i-j出现的次数
>
> 12.最长连续序列
> 哈希表unordered_set存所有数
> 之后遍历所有数,如果它的前一个不在哈希表中,则它可能是一个连续序列的起点
> 从它开始统计长度并记录
> 最后统计最长的连续序列长度
>
> 13.和为k的子数组
> 因为有负数,所以不能滑动窗口
> 只统计数量,所以用前缀和＋哈希表
> 用哈希表存储当前位置之前某个前缀和出现的次数
>
> 14.字符串中首个唯一字符
> 哈希表(数组)长度26,初始化为-2
> 遍历字符串,字符第一次出现改为下标,第二次出现改为-1
> 之后再遍历一遍字符串,找第一个能在哈希表中对应值>=0的字符
>
> 15.最小覆盖子串
> 找字符串s中能覆盖t的最小子串
> 滑动窗口+左右指针
> 一个哈希表记录目标字符串t中每个字符的数量和窗口中该字符数量的差值
> 另外用一个变量记录窗口中满足数量要求的字符种数
> 在窗口扩大和缩小时维护这两个数据结构
> 如果满足覆盖要求则从左边尝试缩小窗口
>
> 16.同构字符串
> 用2个map存储2个方向(s->t,t->s)的映射关系

## 1.判断字母异位词

**因为字母数量有限,且连续分布,所以可以使用数组代替哈希表**

定义一个大小为26的数组,起到哈希表的作用

先遍历s,记录s中个字母出现的次数,存储在数组对应位置
然后遍历t,对每个遇到的字母,将数组中**对应位置记录的次数-1**
最后,如果这个长为26的数组中存在不为0的元素,则不字母异位词

**用一个表示一个数组和另一个数组各字母数量差的数组即可,方便维护**

### 赎金信

字母,用数组做哈希表

### 按字母异位词分组

自己写:用int数组记录字母出现次数,新单词也用int数组统计字母出现次数
之后把新单词的字母次数数组与过去记录的所有数组进行逐一比较,确定新单词
可以AC,但是太慢

解决方法:

**1.仍用字母计数的方法,但用字符串记录字母计数并作为哈希表的键,因而可快速确定是否属于异位词**
定义一个map,key为计数字符串

定义字符串格式:
**字母字符+计数数字**

```c++
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    std::map<string,vector<string>> count_hash;
    vector<vector<string>> ans;
    for (string s : strs) {
        int count[26]{0};
        for (char c : s) {
            count[c - 'a'] += 1;
        }
        string key;
        for (int i=0; i<26; i++) {
            key += (char)('a' + i);
            key += count[i];
        }
        if (count_hash.find(key) == count_hash.end()) {
            count_hash[key] = vector<string>{s};
        } else {
            count_hash[key].push_back(s);
        }
    }
    for (auto it = count_hash.begin(); it != count_hash.end(); it++) {
        ans.push_back(it->second);
    }
    return ans;
}
```

**2.将字符串排序后作为哈希表(map)的key**

字母异位词的特点:**排序后相同**

```c++
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    std::map<string,vector<string>> sort_hash;
    vector<vector<string>> ans;
    for (string s : strs) {
        string key = s;
        sort(key.begin(),key.end());
        sort_hash[key].push_back(s);
    }
    for (auto it = sort_hash.begin(); it != sort_hash.end(); it++) {
        ans.push_back(it->second);
    }
    return ans;
}
```

### 找到所有的字母异位词

(题目中”所有是字母异位词的子串“指连续的子串)

**数组计数+滑动窗口**

异位词**长度一定是相同的**
**使用一个长度等于给定字符串的滑动窗口,避免O(N^2)暴力搜索**

另外,对于滑动窗口中的数组,不需要每次都统计各个字母的出现次数
**只需要在窗口滑动过程中维护一个表示窗口内数组和目标数组各字母数量差的数组即可**
**并引入变量`equal_num`记录当前窗口与字符串p中数量不同的字母的个数,并在滑动窗口的过程中维护它**
是否是字母异位词只要看它是否为0,不用每次都遍历一遍计数的数组

```c++
vector<int> findAnagrams(string s, string p) {
    vector<int> result;
    int p_size = p.size();
    int equal_num = 0;
    unordered_set<char> p_set(p.begin(),p.end());
    int char_num = p_set.size();
    unordered_map<char,int> count;
    for (char c : p) {
        count[c]++;
    }
    for (int i=0; i<p_size; i++) {
        if (p_set.find(s[i])!=p_set.end()) {
            count[s[i]]--;
            if (count[s[i]] == 0) {
                equal_num++;
            }
        }
    }
    if (equal_num == char_num) {
        result.push_back(0);
    }
    for(int i=p_size; i<s.size(); i++) {
        if (p_set.find(s[i])!=p_set.end()) {
            count[s[i]]--;
            if (count[s[i]] == 0) {
                equal_num++;
            }
        }
        if (p_set.find(s[i-p_size])!=p_set.end()) {
            count[s[i-p_size]]++;
            if (count[s[i-p_size]] == 1) {
                equal_num--;
            }
        }

        if (equal_num == char_num) {
            result.push_back(i-p_size+1);
        }
    }
    return result;
}
```

## 2.两个数组的交集

**如果哈希值比较少,特别分散,跨度大,使用数组就造成空间的极大浪费**

输出结果中的每个元素一定是唯一的(要去重),可以不考虑输出结果的顺序
使用unordered_set记录和储存结果(最后再转为vector)

### 两个数组的交集Ⅱ

要求输出的交集中每个结果出现的次数要等于其在2个数组中出现次数的较小者

**法一:哈希表**

自己写:用一个map记录存第一个数组各数字出现次数
用另外一个map记录交集的数字和其在两个数组中分别出现的次数
最后把第二个map中每个数字输出,输出次数取记录的两个次数中较小者

**但具体实现不好,运行较慢:**

```c++
vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
    std::unordered_map<int,int> map1;
    std::unordered_map<int,vector<int>> map2;
    vector<int> res;
    for (int n : nums1) {
        map1[n] += 1;
    }
    for (int n : nums2) {
        if (map1.find(n) != map1.end()) {
            if (map2.find(n) == map2.end()) {
                map2[n] = vector<int>{map1[n],0};
            }
            map2[n][1] += 1;
        }
    }
    for(auto it = map2.begin(); it != map2.end(); it++) {
        int c = min(it->second[0],it->second[1]);
        while (c--) {
            res.push_back(it->first);
        }
    }
    return res;
}
```

**改进代码:**
①为了提高效率,先遍历长度较短的数组,然后遍历较长的数组得到交集
②不需要先定义两个哈希表,最后再遍历第二个哈希表得到答案
只需要定义一个哈希表记录第一个遍历的数组中各数字的出现次数
遍历第二个数组过程中,根据第一个哈希表记录的次数和第二个数组中出现次数可直接得知较小的次数
遍历第二个数组的同时,如果发现哈希表中存在该字母在第一个数组中出现的记录:
每遇到一次就往结果数组中记录一次该字母,**同时将第一次记录的次数减一**

> 若哈希表中记录的个数减为0,则说明第一个数组中该字母的数量更少;
> 若哈希表中记录的个数未被减为0,且第二个数组中没有更多还未被遍历的该字母:
> 则说明第二个数组中该字母的数量更少;
>
> 无论是上面的哪一种情况:
> 之后都不会有"遍历第二个数组中又遇到该字母且该字母在哈希表中有第一个数组的记录"的情况
> 从而,往结果数组中记录该字母的次数总为两个数组中出现次数较少者

因此可在第二次遍历时直接产生要输出的结果,无需最后再遍历一遍哈希表以产生结果

```c++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() <= nums2.size()) {
            return getIntersect(nums1, nums2);
        }
        return getIntersect(nums2, nums1);
    }
    vector<int> getIntersect(vector<int>& nums1, vector<int>& nums2) {
        vector<int> res;
        unordered_map<int,int> hash_map;
        for (int i : nums1) {
            hash_map[i]++;
        }
        for (int i : nums2) {
            if(hash_map.find(i) != hash_map.end()) {
                if (hash_map[i] > 0) {
                    res.push_back(i);
                }
                hash_map[i]--;
            }
        }
        return res;
    }
};
```

**方法二:排序+双指针**

**先对两个数组进行排序**,然后使用两个指针同时从头遍历两个数组

若遇到两个指针所指位置的数字不相等,**将所指位置的数字较小的指针向前移动一位**
若有一个指针已经移动到数组末尾,则得到交集

```c++
vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
    sort(nums1.begin(), nums1.end());
    sort(nums2.begin(), nums2.end());
    vector<int> res;
    for (int i=0, j=0; i < nums1.size() && j < nums2.size();) {
        if (nums1[i]==nums2[j]) {
            res.push_back(nums1[i]);
            i++;
            j++;
        } else {
            if (nums1[i] < nums2[j]) {
                i++;
            } else {
                j++;
            }
        }
    }
    return res;
}
```

## 3.快乐数

> 「快乐数」定义为: 对于一个正整数,每一次将该数替换为它每个位置上的数字的平方和,然后重复这个过程直到这个数变为 1,也可能是 无限循环 但始终变不到 1,如果 可以变为 1,那么这个数就是快乐数

题目中说了会无限循环,那么也就是说求和的过程中,**sum会重复出现**
判断和是否在之前出现过:哈希表**unordered_set**

```c++
bool isHappy(int n) {
    unordered_set<int> sum_set;
    while (sum_set.find(n) == sum_set.end() && n != 1) {
        sum_set.insert(n);
        int sum = 0;
        while(n>0) {
            int tmp = n % 10;
            n = n/10;
            sum += tmp * tmp; 
        }
        n = sum;
    }
    if (n == 1) {
        return true;
    } else {
        return false;
    }
}
```

## 4.两数之和

数组中是否存在2个数,和为指定值,返回所有这样的元组的索引下标

当我们需要查询一个元素是否出现过,或者一个元素是否在集合里的时候,就要第一时间想到哈希法
因为本题不仅需要知道是否存在过,还需要知道其下标,所以使用map
遍历过程中查找map即可

```c++
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> map;
    vector<int> res;
    for (int i=0; i<nums.size(); i++) {
        if (map.find(target-nums[i]) != map.end()) {
            res.push_back(map[target-nums[i]]);
            res.push_back(i);
            break;
        }
        map[nums[i]] = i;
    }
    return res;
}
```

## 5.三数之和

数组中是否存在3个数,和为0,返回所有这样的三元组

**本题不适合使用哈希法,时间复杂度N^2,且去重不方便**

### 双指针法

因为要求返回的不是索引下标,而是数值,所以可以使用双指针法

另外注意:本题要求对结果进行去重,即,每种组合只能出现一次
去重时应注意对于一个组合中有重复数字时的处理,防止漏掉情况
因已排序,所以组合有重复数字只有三种情况:①a a b ② a b b ③a a a (0 0 0)

**1.对原数组进行从小到大排序**
(此方法别忘了先排序!去重往往涉及到需要先排序)

2.使用for循环,用变量`i`从左到右遍历整个数组,`i`所在位置的数字作为三元组的第一个数字
(因为数组已经提前排过序,所以三元组第一个数字总是最小的一个)

**此处可以进行一次剪枝,提高效率**
若最小的nums[i]>0,则后面都不存在三数和=0的情况,直接返回现有结果

**此处涉及到对三元组对第一个数字的去重,**有两种方式:
①`if(nums[i] == nums[i+1]) continue;`
②`if(i > 0 && nums[i] == nums[i-1]) continue;`

> 为什么要对第一个数字去重:
> 不考虑前两个数字相同的情况:若三元组第一个数字和之前的三元组重复,因要求三个数相加等于给定值,后面选出的两个数字的和也要与之前重复的三元组相同,因此后面两个数的组合也会与之前重复,导致整个三元组和之前的三元组重复

但必须**考虑前两个数字相同的情况**:(a a b 和 a a a)
因为这是第一个数字,后面两个数字都会在其之后产生,这两种情况的第二个数字就在第一个数字后面
若使用第一种去重方法,看到下一个和当前第一个数字重复就跳过当前第一个数字,则会漏掉这两种情况
所以使用第二种方法,看到前面一个和自己相同时,才跳过

3.设置left=i+1,right在数组最右边,之后开始根据当前三数和寻找left和right的位置(**循环条件left<right**)
当`nums[i]+nums[left]+nums[right]>0`时,和太大,right--
当`nums[i]+nums[left]+nums[right]<0`时,和太小,left++

4.当发现`nums[i]+nums[left]+nums[right]==0`时,找到了一种符合条件的三元组,记录该结果
**之后又涉及到对三元组第二和第三个数字的去重**

> 为什么要有后两个数字的去重:
> 此时前面第一个数字已经固定,在第一个数字后面寻找相加等于0-nums[i]的nums[left]和nums[right]时,可能出现重复的相加等于0-nums[i]的nums[left]和nums[right]组合,如果不去重而全部加以记录,会导致记录重复的三元组
>
> 另外,由于后面两个数字相加的和已固定,对于一个等于0-nums[i]的nums[left]和nums[right]组合来说,只要nums[left]和nums[right]二者其中一个存在多个,就都可以和另一个相加等于0-nums[i],产生重复的组合
> 所以去重时,对于等于0-nums[i]的nums[left]和nums[right]组合,只要发现数组中有重复的多个nums[left]或nums[right],除第一次遇到外其余重复的都需要跳过

对后面两个数字的去重:(在记录到一个满足条件的三元组后进行,防止之后记录与这次重复的组合)
(**去重不能放在记录三元组之前**,防止出现为了去重移动指针后left>=right,导致漏掉情况(如0,0,0))

```cpp
while (right > left && nums[right] == nums[right - 1]) right--;
while (right > left && nums[left] == nums[left + 1]) left++;
```

**5.对于相加等于0的情况,记录结果和去重(如有)结束后,还要移动left++,right--**
(※上一步的移动这是为了去重,相加等于0的情况还没有移动left和right指针,别忘了!)

**本题使用双指针法,把暴力解法的O(N^3)降为O(N^2)**

```c++
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> res;
    sort(nums.begin(),nums.end());
    for (int i=0; i<nums.size(); i++) {
        if (nums[i] > 0) {
            return res;
        }
        if (i > 0 && nums[i-1] == nums[i]) {
            continue;
        }
        int left = i+1;
        int right = nums.size()-1;
        while (right > left) {
            if (nums[i]+nums[left]+nums[right] > 0) {
                right--;
            }
            else if (nums[i]+nums[left]+nums[right] < 0) {
                left++;
            } else {
                res.push_back({nums[i],nums[left],nums[right]});
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                right--;
                left++;
            }       
        }
    }
    return res;
}
```

## 6.四数之和

数组中是否存在4个数,和为指定值,返回所有这样的元组

类似于上题,使用双指针法
**本题使用双指针法,把暴力解法的O(N^4)降为O(N^3)**
(**降一个数量级**,即双指针可以把寻找最后两个数的O(N^2)变为O(N))

**先排序**,然后使用嵌套的两个for循环遍历前两个数字的组合(前两个数字都需要注意去重)
再使用和上一题同理的双指针法寻找满足条件的后两个数字

当确定第一个数字时,可进行剪枝,看能不能提前结束:
`if (nums[k] > target && nums[k] >= 0)`
(nums[k]只有>target且大于等于0,才能确定后面再不可能找到符合条件的组合了)
(不同于上题,target未知,不能仅靠nums[k]>target确定,因为nums[k]和target可能都是负数)

当确定第二个数字时,也可进行剪枝:
`if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0)`

```c++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    sort(nums.begin(),nums.end());
    vector<vector<int>> res;
    for (int i = 0; i<nums.size(); i++) {
        if (nums[i] > 0 && nums[i] > target) {
            // 剪枝
            break;
        }
        if (i > 0 && nums[i-1] == nums[i]) {
            continue;
        }
        for (int j = i + 1; j<nums.size(); j++) {
            if (nums[i] + nums[j] > 0 && nums[i] + nums[j] > target) {
                // 剪枝
                break;
            }
            if (j > i+1 && nums[j-1] == nums[j]) {
                // 注意是>i+1,不是>i
                continue;
            }
            int left = j+1;
            int right = nums.size()-1;
            while (left < right) {
                if (nums[i] + nums[j] + nums[left] + nums[right] > target) {
                    right--;
                } else if (nums[i] + nums[j] + nums[left] + nums[right] < target) {
                    left++;
                } else {
                    res.push_back({nums[i],nums[j],nums[left],nums[right]});
                    while (left < right && nums[right-1] == nums[right]) {
                        right--;
                    }
                    while (left < right && nums[left+1] == nums[left]) {
                        left++;
                    }
                    right--;
                    left++;
                }
            }
        }
    }
    return res;
}
```

## 7.四数相加II

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) , 使得 A[i] + B[j] + C[k] + D[l] = 0

不同于三数之和和四数之和,因为去重麻烦,不用哈希表法而使用双指针法
本题为**4个独立的数组**,每个各出一个数字,即4元组内数字顺序有影响,**不需要考虑去重**(**排列数**)
不同于上题在同一数组中选时要考虑因重复数字导致的去重问题(组合数)

所以本题使用哈希法,注意本题只需返回组合的个数,**只统计个数即可**
本题解题步骤:

1. 首先定义 一个unordered_map,key放a和b两数之和,value 放a和b两数之和出现的次数
2. 遍历大A和大B数组,统计两个数组元素之和,和出现的次数,放到map中
3. 定义int变量count,用来统计 a+b+c+d = 0 出现的次数
4. 在遍历大C和大D数组,找到如果 0-(c+d) 在map中出现过的话,就用count把map中key对应的value也就是出现次数统计出来
5. 最后返回统计值 count 就可以了

```c++
int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
    unordered_map<int,int> sum1;
    int count = 0;
    for (int n1 : nums1) {
        for (int n2 : nums2) {
            sum1[n1+n2]++;
        }
    }
    for (int n3: nums3) {
        for (int n4: nums4) {
            if (sum1.find(0-(n3+n4))!=sum1.end()) {
                count+=sum1[0-(n3+n4)];
            }
        }
    }
    return count;
}
```

## 8.最长连续序列

给定一个未排序的整数数组 `nums` 
找出数字连续的最长序列**(不要求序列元素在原数组中连续和按顺序)**的长度

要求O(n)
注意看清题,不是最长递增子序列!不用连续!

哈希表

1.将数组所有数字加入哈希表
2.遍历数组,对遇到的每一个数字nums[i],检查nums[i-1]是否在哈希表中
如果不在,则这个nums[i]可能为若干连续数字的开始
从nums[i]开始,依次检查nums[i]+1,nums[i]+2....是否在哈希表中

```c++
int longestConsecutive(vector<int>& nums) {
    unordered_set<int> num_set(nums.begin(),nums.end());
    int res = 1;
    if (num_set.empty()) {
        return 0;
    }
    for (int i=0; i<nums.size(); i++) {
        if (num_set.find(nums[i]-1)==num_set.end()) {
            int len = 1;
            int tmp = nums[i];
            while (num_set.find(tmp+1) != num_set.end()) {
                len++;
                tmp++;
            }
            res = max(res, len);
        }
    }
    return res;
}
```

## 9.和为K的子数组

错误思路:滑动窗口
因为数组中可能有负数!(即窗口内和>k时,不一定需要缩小窗口左边)

正确思路:前缀和+哈希表

因为题目只要求和为k子数组出现的次数,不用求出具体有哪些子数组
所以可以用哈希表存储某个前缀和在之前出现过的次数
**可以从左到右一边更新哈希表,一边计算答案**

(检查"k-当前前缀和"在哈希表中是否出现过)

```c++
int subarraySum(vector<int>& nums, int k) {
    unordered_map<int,int> prefix_count;
    prefix_count[0] = 1;
    int result = 0;
    int prefix_sum = 0;
    for (int i=0; i<nums.size(); i++) {
        prefix_sum += nums[i];
        // 注意下面这两句的顺序不能反!
        result += prefix_count[prefix_sum-k];
        prefix_count[prefix_sum]++;
    }
    return result;
}
```

## 10.字符串中首个唯一字符

第一次出现,哈希表中该字母的位置改为下标

后面再出现,该字母的位置改为-1

后面遍历原字符串,寻找第一个在哈希表中对应值>=0的字母

```c++
int firstUniqChar(string s) {
    vector<int> count(26,-2);
    int res = -1;
    for (int i=0; i<s.size(); i++) {
        if (count[s[i]-'a'] == -2) {
            count[s[i]-'a'] = i;
        } else {
            count[s[i]-'a'] = -1;
        }

    }
    for (int i=0; i<s.size(); i++) {
        if(count[s[i]-'a']>=0) return count[s[i]-'a'];
    }
    return -1;
}
```

## 11.最小覆盖子串(滑动窗口)

**方法一**

给你一个字符串 s ,一个字符串 t,返回 s 中涵盖 t 所有字符的最小子串
如果 s 中不存在涵盖 t 所有字符的子串,则返回空字符串 ""

定义两个哈希表,存放t中元素的出现次数信息和滑动窗口中元素的出现次数信息

judge函数只用于for循环窗口结束位置右移,窗口扩大时判断

当窗口缩小时:
①窗口缩小时被移出窗口的最左边字符不是t中字符:
移除该字符不影响窗口内字符串符合条件,无需判断,直接让left++即可
②窗口缩小时被移出窗口的最左边字符是t中字符:
只需检查两个哈希表中该字符的数量即可,无需用judge检查所有字

**方法二(更简洁)**

- 使用滑动窗口+双指针寻找最小覆盖字串
- 用一个`unordered_map<char,int>` 记录窗口中和目标字符串各字符的数量差
  以及一个变量`match_num`表示"在窗口内已经有足够数量的字符"的个数
- 右指针右移扩大窗口
  在遇到目标字符串中字符进入窗口时将map中该字符的数量差值减1
  如果减为0表示窗口中该字符的数量够了,match_num++
  在恰好凑齐所有不同字符(match_num == t_map.size()`)时进入收缩阶段
- 收缩阶段让左指针右移
  如果是目标字符串中字符离开窗口,将map中该字符的数量差值加1
  如果加1后=1,则表示窗口中这个字符的数量从足够变为不足,match_num--
  如果仍然满足`(match_num == t_map.size()`,则继续从左边缩小窗口
  否则停止收缩阶段,继续右移右指针扩大窗口
- 为了防止内存消耗过大,在寻找过程中只记录左右边界
  在最后返回结果时再用substr提取需要的最小覆盖子串

```c++
string minWindow(string s, string t) {
    unordered_map<char, int> t_map;
    for (char c : t) {
        t_map[c]++;
    }
    int match_num = 0;
    int left = 0;
    int result_left=0, result_right=INT_MAX;
    bool find = false;
    for (int right = 0; right < s.size(); right++) {
        if (t_map.find(s[right]) != t_map.end()) {
            t_map[s[right]]--;
            if (t_map[s[right]] == 0) {
                match_num++;
            }
            while (match_num == t_map.size() && left <= right) {
                find = true;
                if (right - left < result_right - result_left) {
                    result_left = left;
                    result_right = right;
                }
                if (t_map.find(s[left]) != t_map.end()) {
                    t_map[s[left]]++;
                    if (t_map[s[left]] == 1) {
                        match_num--;
                    }
                }
                left++;
            }
        }
    }
    if (!find) return "";
    return s.substr(result_left,result_right-result_left+1);
}
```

## 12.同构字符串

给定两个字符串 `s` 和 `t` 判断它们是否是同构的

如果 `s` 中的字符可以按某种映射关系替换得到 `t` 那么这两个字符串是同构的

题目要求一对一映射,同时不改变字符的顺序,可以映射到本身
不同字符不能映射到同一个字符上,相同字符只能映射到同一个字符上

用2个map存储2个方向(s->t,t->s)的映射关系

```c++
bool isIsomorphic(string s, string t) {
    unordered_map<char,char> s2t;
    unordered_map<char,char> t2s;
    int n = s.size();
    for (int i = 0; i<s.size(); i++) {
        if(s2t.find(s[i]) == s2t.end() && t2s.find(t[i]) == t2s.end()) {
            s2t[s[i]] = t[i];
            t2s[t[i]] = s[i];
        } else if (s2t.find(s[i]) != s2t.end() && t2s.find(t[i]) != t2s.end()){
            if (s2t[s[i]] != t[i] || t2s[t[i]] != s[i]) {
                return false;
            }
        } else {
            return false;
        }
    }
    return true;
}
```

