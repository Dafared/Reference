[TOC]

### 前缀和与字符串哈希

字符串哈希:快速O(1)比较两个字符串

#### 01个数相同最长子数组

(leetcode 525)

**前缀和+哈希表**

计算前缀和的作用:便于快速计算子数组的元素和
若前缀和数组为prefix,则下标从j+1到k的子数组的元素和为prefix[k]-prefix[j]

可以将0视为-1,则-1和1个数相同的子数组就是元素和=0的子数组
即对于下标从j+1到k的子数组满足prefix[k]-prefix[j]=0,即prefix[k]=prefix[i]

实际上得到元素和=0的不需要prefix数组,只需要一个哈希表
因求的是最长长度,哈希表中存储某个前缀和**第一次出现的下标**
若之后发现该前缀和之前出现过,则当前的下标和第一次出现的下标之间的子数组和为0

```c++
int findMaxLength(vector<int>& nums) {
    vector<long long> pre_sum(nums.size()+1, 0);
    unordered_map<long long, int> m;
    int max_len = 0;
    m[0] = 0;
    for (int i = 1; i <= nums.size(); i++) {
        if (nums[i - 1] == 1) {
            pre_sum[i] = pre_sum[i - 1] + 1;
        } else {
            pre_sum[i] = pre_sum[i - 1] - 1;
        }
        if (m.find(pre_sum[i]) != m.end()) {
            max_len = max(max_len, i - m[pre_sum[i]]);
        }
        if (m.find(pre_sum[i]) == m.end()) {
            m[pre_sum[i]] = i;
        }
    }
    return max_len;
}
```

#### 重复的长度为10的DNA序列

**滑动窗口+哈希表**

从左到右使用滑动窗口得到每个长度为10的子串
用哈希表记录每个以子串的出现次数

每次检查以 s[i] 为结尾的子串, 需要构造出新的且长度为 10 的字符串
令 C=10, 复杂度为 `O(n *  C)`

**字符串哈希**

字符串哈希:快速检查两个子串是否相同

字符串哈希计算公式为:
`hash[i] = hash[i-1] *Base + idx(s[i]);`
(类似十进制的表示,14,一开始是 0,然后 0 * 10 + 1 = 1,接着 1*10 + 4 = 14)

使用`P[i]`数组表示`Base^i`,即底的i次方

计算子串s[i,...,j]的哈希值:**使用前缀和思想**
`h[j]-h[i-1]*p[j-i+1]`

推导过程:
<img src="C:\Users\20200\Desktop\找工\算法\images\26.JPG" alt="26" style="zoom:80%;" />

使用该方法的**时间复杂度为(O(n))**
①计算h数组和p数组的时间复杂度为O(n)
②计算子串的哈希值时,可以使用前缀和思想,在O(1)时间内得到哈希值

另外,如果希望做到O(n)
最后用作计数的哈希表map不能用string作为key,只能使用int

①计算哈希数组h和次方数组p
②遍历数组,计算每个长度为10的子串的哈希值
③检查子串哈希值是否存在过,如存在过且本次是出现的第二次,则将对应区间子串加入答案
然后把map中的计数++

```c++
#define BASE 131
vector<string> findRepeatedDnaSequences(string s) {
    unordered_map<uint64_t,int> count_map;
    vector<string> res;
    vector<uint64_t> h(s.size()+1,0);
    vector<uint64_t> p(s.size()+1,0);
    p[0] = 1;
    for (int i=0; i<s.size(); i++) {
        p[i+1] = p[i] * BASE;
        h[i+1] = h[i] * BASE + s[i];
    }
    for (int i=10; i<=s.size(); i++) {
        uint64_t hash = h[i] - h[i-10] * p[10];
        if (count_map.find(hash) != count_map.end()) {
            if (count_map[hash] == 1) {
                res.push_back(s.substr(i-10,10));
            }
        }
        count_map[hash] ++;
    }
    return res;
}
```

#### 最长重复子串

(leetcode 1044)

**字符串哈希+二分查找最大长度**

p通常默认设为1313131/131

①计算哈希数组h和次方数组p

②编写check函数,检查某个长度 len 作为最大长度, 是否存在合法方案
(寻找是否有长度为len的符合要求的重复子串)

③使用二分查找,寻找可能的最大长度

```c++
#define BASE 131
class Solution {
public:
    string check(vector<uint64_t> &p, vector<uint64_t> &h, int len, string &s) {
        unordered_set<uint64_t> count_set;
        for (int i=len; i<=s.size(); i++) {
            uint64_t hash = h[i] - h[i-len] * p[len];
            if (count_set.find(hash) != count_set.end()) {
                return s.substr(i-len,len);
            }
            count_set.insert(hash);
        }
        return "";
    }
    string longestDupSubstring(string s) {
        vector<uint64_t> p(s.size()+1,0);
        vector<uint64_t> h(s.size()+1,0);
        p[0] = 1;
        for (int i=1; i<=s.size(); i++) {
            p[i] = p[i-1] * BASE;
            h[i] = h[i-1] * BASE + s[i-1];
        }
        int right = s.size();
        int left = 0;
        string res_str = "";
        while (left <= right) {
            int mid = (left+right) >> 1;
            string tmp = check(p,h,mid,s);
            res_str = res_str.size() < tmp.size() ? tmp : res_str;
            if (!tmp.empty()) {
                left = mid+1;
            } else {
                right = mid-1;
            }
        }
        return res_str;
    }
};
```

### 双指针

#### 盛最多水的容器

双指针法

左指针指向数组第一个,右指针指向最右边

当右指针所在的高度小于左指针位置,右指针左移
左指针小,则左指针右移

在此过程中记录最大的水量=min(左,右)*左右之间的距离

#### 颜色分类(按红白蓝顺序排列)

给定一个包含红色,白色和蓝色,共 n 个元素的数组 nums 
原地对它们进行排序,使得相同颜色的元素相邻,并按照红色,白色,蓝色顺序排列

我们使用整数 0,1,2 分别表示红色,白色和蓝色

```c++
class Solution {
public:
    // 单指针
    // 第一趟遍历,从开始到末尾,把红色全放在最前面
    // 第二趟,从红色之后到数组结束,把白色放在第二段数组的前面
    void sortColors_1(vector<int>& nums) {
        int n = nums.size();
        int cur = 0;
        for (int i=0; i<n; i++) {
            if (nums[i] == 0) {
                swap(nums[i],nums[cur]);
                cur++;
            }
        }
        for (int i=cur; i<n; i++) {
            if (nums[i] == 1) {
                swap(nums[i],nums[cur]);
                cur++;
            }
        }
    }
    // 双指针(0+1),cur0和cur1分表代表0和1的开始,都从0开始递增
    // 如果交换cur0和nums[i]时,cur0<cur1,则原cur0处元素一定是1
    // 需要继续交换新nums[i]和现有的cur1
    // cur1也++的原因:1.发生了上面的交换,cur1自然要++;
    // 2.没有发生上面的交换,即cur1==cur0,cur0++了,cur1也要跟着加
    void sortColors_2(vector<int>& nums) {
        int n = nums.size();
        int cur0 = 0;
        int cur1 = 0;
        for (int i=0; i<n; i++) {
            if (nums[i] == 1) {
                swap(nums[i],nums[cur1]);
                cur1++;
            } else if (nums[i] == 0) {
                swap(nums[i],nums[cur0]);
                if (cur0 < cur1) {
                    swap(nums[i],nums[cur1]);
                }
                cur0++;
                cur1++;
            }
        }
    }
    // 双指针(0+2)
    // 对于cur2处原来的元素,可能是2,也可能是0,因为i<=cur2,所以cur2处元素没有检查过
    // 交换到nums[i]后,对于2,需要左移cur2指针,继续交换;对于0,需要和cur0指针交换
    // 如果不继续判断,则i就会+1了
    // 对于cur1,因为cur1一定<=i,所以原cur1处元素一定已经被下标i经过,即已经检查过了
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        int cur0 = 0;
        int cur2 = n-1;
        int i = 0;
        for (int i=0; i<=cur2; i++) {        
            while (i <= cur2 && nums[i] == 2) {
                swap(nums[i],nums[cur2]);
                cur2--;
            }
            if (nums[i] == 0) {
                swap(nums[i],nums[cur0]);
                cur0++;
            }
        }
    }
};
```

### 哈希表

#### 最长连续序列

给定一个未排序的整数数组 `nums` 
找出数字连续的最长序列(不要求序列元素在原数组中连续)的长度

要求O(n)
注意看清题,不是最长递增子序列!

哈希表

1.将数组所有数字加入哈希表
2.遍历数组,对遇到的每一个数字nums[i],检查nums[i-1]是否在哈希表中
如果不在,则这个nums[i]可能为若干连续数字的开始
从nums[i]开始,依次检查nums[i]+1,nums[i]+2....是否在哈希表中

```c++
int longestConsecutive(vector<int>& nums) {
    int res = 1;
    unordered_set<int> dict(nums.begin(),nums.end());
    if (nums.empty()) {
        return 0;
    }
    for (int n : nums) {
        if (dict.count(n-1)==0) {
            int len = 1;
            int tmp = n+1;
            while(dict.count(tmp++)!=0) {
                len++;   
            }
            res = max(res,len);
        }
    }
    return res;
}
```

#### 和为K的子数组

错误思路:滑动窗口
因为数组中可能有负数!(即窗口内和>k时,不一定需要缩小窗口左边)

正确思路:前缀和+哈希表

因为题目只要求和为k子数组出现的次数,不用求出具体有哪些子数组
所以可以用哈希表存储某个前缀和在之前出现过的次数
**可以从左到右一边更新哈希表,一边计算答案**

(检查"k-当前前缀和"在哈希表中是否出现过)

#### 字符串中第一个唯一字符

第一次出现,哈希表中该字母的位置改为下标

后面再出现,该字母的位置改为-1

后面遍历原字符串,寻找第一个在哈希表中对应值>=0的字母

```c++
int firstUniqChar(string s) {
    vector<int> count(26,-2);
    int res = -1;
    for (int i=0; i<s.size(); i++) {
        if (count[s[i]-'a'] == -2) {
            count[s[i]-'a'] = i;
        } else {
            count[s[i]-'a'] = -1;
        }

    }
    for (int i=0; i<s.size(); i++) {
        if(count[s[i]-'a']>=0) return count[s[i]-'a'];
    }
    return -1;
}
```

### 滑动窗口

#### 最小覆盖子串

定义两个哈希表,存放t中元素的出现次数信息和滑动窗口中元素的出现次数信息

judge函数只用于for循环窗口结束位置右移,窗口扩大时判断

当窗口缩小时:
①窗口缩小时被移出窗口的最左边字符不是t中字符:
移除该字符不影响窗口内字符串符合条件,无需判断,直接让left++即可
②窗口缩小时被移出窗口的最左边字符是t中字符:
只需检查两个哈希表中该字符的数量即可,无需用judge检查所有字符

### 二分查找

#### 寻找重复数

给定一个包含 `n + 1` 个整数的数组 `nums` ,其数字都在 `[1, n]` 范围内
假设 nums 只有 一个重复的整数 ,返回 这个重复的数

不允许修改数组且只用常量级的O(1)额外空间

```c++
// 用乘上-1标记为重复（因为已知数字>0且<nums.size())
int findDuplicate_1(vector<int>& nums) {
    for (int i=0; i<nums.size(); i++) {
        int n = abs(nums[i]);
        if (nums[n] > 0) {
            nums[n] *= -1;
        } else {
            nums[n] *= -1;
            return n;
        }
    }
    return 0;
}

// 二分查找,答案二分
// 已知共n+1个数字,有2个重复数字,剩下n-1个互不重复,(可能的)最大数字是n,最小是1
// 设cnt[n]表示数组中小于等于数字n的元素个数,重复的数字是target
// 则对于<target的数字n,cnt[n]小于等于n
// 对于大于等于target的数字,cnt[n]>n
// 符合使用二分的条件,对于当前数字mid,求cnt[mid],判断和mid的关系
// 时间复杂度O(nlogn)
int findDuplicate(vector<int>& nums) {
    int left = 1;
    int right = nums.size();
    int res = -1;
    while (left <= right) {
        int mid = (left + right) >> 1;
        int cnt = 0;
        for (int i=0; i<nums.size(); i++) {
            if (nums[i] <= mid) {
                cnt++;
            }
        }
        if (cnt <= mid) {
            left = mid + 1;
        } else {
            right = mid - 1;
            res = mid;
        }
    }
    return res;
}
```

#### 搜索旋转排序数组

二分查找

把有序数组的前面一部分旋转到了后面
因此,如果将数组从中间进行二分,**左右两边一定会有一部分是有序的**

二分查找过程:如果`target==nums[mid]`,找到
否则判断mid两边的区间中哪一边是有序的
①如果`[left,mid-1]`有序:
若target大小满足在`[nums[left],nums[mid-1]]`区间中
(必须在这个区间内,不能只判断<nums[mid],还要>=nums[left],下面同理)
则将搜索范围缩小至`[left,mid-1]`,否则在`[mid+1,right]`中查找
②如果`[mid+1,right]`有序:
若target在`[nums[mid+1],nums[right]]`区间中
则将搜索范围缩小至`[mid+1,right]`,否则在`[left,mid-1]`中查找

```c++
int search(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size()-1;
    while (left <= right) {
        int mid = (left + right) >> 1;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}
```

#### 寻找旋转排序数组中的最小值

必须设计一个时间复杂度为 O(log n) 的算法解决此问题

把有序数组的前面一部分旋转到了后面
对于数组中最右一个元素x:
在旋转后数组中最小值右侧的元素,一定严格小于x
在旋转后数组中最小值左侧的元素,一定严格大于x
所以以x为比较基准

二分时比较mid和最后一个元素:

①nums[mid] < nums[nums.size()-1]:
mid的位置在最小值右侧,忽略mid的右半部分

①nums[mid] > nums[nums.size()-1]:
mid的位置在最小值左侧,忽略mid的左半部分

最后二分查找结束,找到最小值为nums[low]

```c++
int findMin(vector<int>& nums) {
    int left = 0;
    int right = nums.size()-1;
    while (left <= right) {
        int mid = (right + left) >> 1;
        // 注意nums[mid]==nums[nums.size()-1]时要right=mid-1
        // 不能left=mid+1,否则会越界
        if (nums[mid] > nums[nums.size()-1]) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return nums[left];
}
```

#### 两个正序数组的中位数

暴力方法:合并两个数组,然后寻找中位数

改进:

**1.同时遍历两个有序数组**
用两个指针分别指向两个数组当前遍历到的位置
哪个指向的数字小,哪个往后移

设两个有序数组长度和为n,若n为奇数,中位数在n/2(0开始)
n为偶数,中位数为第n/2-1和n/2的平均值

```c++
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int len1 = nums1.size();
    int len2 = nums2.size();
    int cur1 = 0;
    int cur2 = 0;
    int count = -1;
    int n1,n2;
    while (cur1 < len1 && cur2 < len2 && count < (len1+len2)/2) {
        if (nums1[cur1] < nums2[cur2]) {
            cur1++;
            count++;
            if (count == (len1+len2)/2-1) {
                n1 = nums1[cur1-1];
            }
            if (count == (len1+len2)/2) {
                n2 = nums1[cur1-1];
            }
        } else{
            cur2++;
            count++;
            if (count == (len1+len2)/2-1) {
                n1 = nums2[cur2-1];
            }
            if (count == (len1+len2)/2) {
                n2 = nums2[cur2-1];
            }
        }
    }
    while (cur1 < len1 && count < (len1+len2)/2) {
        cur1++;
        count++;
        if (count == (len1+len2)/2-1) {
            n1 = nums1[cur1-1];
        }
        if (count == (len1+len2)/2) {
            n2 = nums1[cur1-1];
        }
    }
    while (cur2 < len2 && count < (len1+len2)/2) {
        cur2++;
        count++;
        if (count == (len1+len2)/2-1) {
            n1 = nums2[cur2-1];
        }
        if (count == (len1+len2)/2) {
            n2 = nums2[cur2-1];
        }
    }
    if ((len1+len2)%2 == 0) {
        return (n1+n2)/2.0;
    } else {
        return n2;
    }
}
```

**2.二分查找**

如果 `array1[mid1] < array2[mid2]`,中位数一定在 `array1[mid1:]` 和 `array2[:mid2]` 中。

如果 `array1[mid1] > array2[mid2]`,那么中位数一定在 `array1[:mid1]` 和 `array2[mid2:]` 中

```c++
#include <iostream>
#include <vector>
using namespace std;

int findKthElement(const vector<int>& array1, 
                   const vector<int>& array2, 
                   int start1, int start2, int k) {
    if (start1 >= array1.size()) return array2[start2 + k - 1];
    // array1已经取完,直接返回array2中的第k小
    if (start2 >= array2.size()) return array1[start1 + k - 1];
    // array2已经取完,直接返回array1中的第k小
    
    if (k == 1) return min(array1[start1], array2[start2]);
    // 找第1小,直接取两数组头部较小值

    // 取两个数组的第k/2个元素（注意越界情况）
    int mid1 = start1 + k / 2 - 1 < array1.size() ? 
        array1[start1 + k / 2 - 1] : INT_MAX;
    int mid2 = start2 + k / 2 - 1 < array2.size() ? 
        array2[start2 + k / 2 - 1] : INT_MAX;

    if (mid1 < mid2) {
        // array1的前k/2个元素不可能是第k小的,排除这些元素
        return findKthElement(array1, array2, start1 + k / 2, start2, k - k / 2);
    } else {
        // array2的前k/2个元素不可能是第k小的,排除这些元素
        return findKthElement(array1, array2, start1, start2 + k / 2, k - k / 2);
    }
}

double findMedianSortedArrays(const vector<int>& array1, 
                              const vector<int>& array2) {
    int N = array1.size();
    // 数组为空的情况
    if (N == 0) return 0;
    int totalLen = 2 * N;

    if (totalLen % 2 == 1) {
        // 如果总长度为奇数,找到第totalLen/2 + 1小的元素
        return findKthElement(array1, array2, 0, 0, totalLen / 2 + 1);
    } else {
        // 如果总长度为偶数,找到第totalLen/2和第totalLen/2 + 1小的元素,返回平均值
        return (findKthElement(array1, array2, 0, 0, totalLen / 2)
                + findKthElement(array1, array2, 0, 0, totalLen / 2 + 1)) 
            	/ 2.0;
    }
}
```

#### 搜索二维矩阵

1.抽象BST(右上角为根节点)

2.两次二分查找

先二分查找所在行,再二分查找所在列

3.一次二分,把二维地址转为一维地址

#### 有序数组中找元素的第一个和最后一个

1.二分查找分别找左边界和右边界

找左边界:nums[mid] >= target, right--
nums[mid] < target, left++

找右边界:nums[mid] > target, right--
nums[mid] <= target, left++

2.先找到任意一个target,再往两边找

### 栈,队列,堆

#### 滑动窗口最大值

单调队列
为了方便处理,给数组头和尾各加一个0

#### 字符串解码

```c++
// 辅助栈法,构建一个辅助栈
/*
1.当c为数字,将数字字符转变为数字
2.当c为字母,在str_res尾部添加c
3.当c为[,将当前数字和str_res入栈(当前重复若干次的字串之前的字符串入栈)
入栈后str_res和数字重新置空
4.当c为],出栈得到数字和str_before
让res = str_before + 数字*res
str_before为该[]之前已经得到的字符串
*/
string decodeString(string s) {
    stack<pair<int,string>> st;
    string str_res;
    int cur_num = 0;
    for (char c : s) {
        if (c == '[') {
            st.push({cur_num,str_res});
            str_res = "";
            cur_num = 0;
        } else if (c == ']') {
            auto tmp = st.top();
            st.pop();
            string str_before = tmp.second;
            int num = tmp.first;
            while (num--) {
                str_before = str_before + str_res;
            }
            str_res = str_before;
        } else if ('0' <= c && c <= '9') {
            cur_num = cur_num*10 + c-'0';
        } else {
            str_res = str_res + c;
        }
    }
    return str_res;
}
```

#### 柱状图中最大的矩形

使用递减的单调栈

遇到大于等于栈顶的入栈
遇到小于栈顶的,出栈,计算矩形面积

当前遍历到的数组下标:`i`
矩形高:栈顶对应的柱子高
矩形宽:栈顶出栈以后,`i-st.top()-1`

> **注意:计算矩形宽不能在栈顶出栈前计算`w=i-st.top()`**
> 因为当前栈顶和栈顶下一个中间可能已经发生过若干次出栈
> 即当前栈顶和栈顶下一个中间可能不连续!

```c++
int largestRectangleArea(vector<int>& heights) {
    stack<int> st;
    heights.push_back(0);
    heights.insert(heights.begin(),0);
    int max_s = 0;
    st.push(0);
    for (int i=1; i<heights.size(); i++) {
        while (heights[i] < heights[st.top()]) {
            int mid = st.top();
            st.pop();
            int w = i - st.top() - 1;
            int h = heights[mid];
            max_s = max(max_s, h*w);
        }
        st.push(i);
    }
    return max_s;
}
```

#### 前 K 个高频元素

1.使用大小为k的小顶堆

①先用哈希表统计数字中各元素的出现次数
②遍历各元素的出现次数,如发现大于堆顶,则替换当前小顶堆顶,维护堆的性质
③最后堆中剩下的k个元素就是前k个高频

①使用优先队列

```c++
class Solution {
public:
    static bool cmp(const pair<int,int> &l, const pair<int,int> &r) {
        return l.second > r.second;
    }
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> count;
        for (int n : nums) {
            count[n]++;
        }
        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(&cmp)> que(cmp);
        for (auto p : count) {
            que.push({p.first,p.second});
            if (que.size() > k) {
                que.pop();
            }
        }

        vector<int> res;
        while (!que.empty()) {
            res.push_back(que.top().first);
            que.pop();
        }
        return res;
    }
};
```

②使用自定义堆

```c++
class Solution {
public:
    void heapify(vector<pair<int,int>>& nums, int heap_size, int i) {
        int smallest = i;
        int lson = 2*i + 1;
        int rson = 2*i + 2;
        if (lson < heap_size && nums[lson].second < nums[smallest].second) {
            smallest = lson;
        }
        if (rson < heap_size && nums[rson].second < nums[smallest].second) {
            smallest = rson;
        }
        if (smallest != i) {
            swap(nums[smallest],nums[i]);
            heapify(nums,heap_size,smallest);
        }
    }
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> count;
        vector<pair<int,int>> heap;
        for (int n : nums) {
            count[n]++;
        }
        for (auto p : count) {
            if (heap.size() < k) {
                heap.push_back(p);
                if (heap.size() == k) { // 建堆
                    for (int i=k/2-1; i>=0; i--) {
                        heapify(heap,k,i);
                    }
                }
            } else {
                if (heap[0].second < p.second) {
                    heap[0] = p;
                    heapify(heap,k,0);
                }
            }
        }

        vector<int> res;
        for (auto p : heap) {
            res.push_back(p.first);
        }
        return res;
    }
};
```

2.使用桶排序

①先用哈希表统计数字中各元素的出现次数
②遍历各元素的出现次数,按出现次数存入数组的对应项
③从后开始遍历数组,读取k个有效值

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> count;
        vector<list<int>> buckets(nums.size()+1);
        for (int n : nums) {
            count[n]++;
        }
        for (auto p : count) {
            buckets[p.second].push_back(p.first);
        }

        vector<int> res;
        int n = k;
        for (auto it = buckets.rbegin(); it != buckets.rend(); it++) {
            if (n == 0) {
                break;
            }
            if(!it->empty()) {
                for (int num : *it) {
                    res.push_back(num);
                    n--;
                }
            }
        }
        return res;
    }
};
```

#### 数组中的第K个最大元素

1.使用快排思想

如果某次哨兵划分后,基准数的索引正好是N−k,则意味着它就是第k大的数字

使用三路递归
若下标N−k在大于基准的部分,递归划分右半部分
若下标N−k在小于基准的部分,递归划分左半部分
若下标N-k在等于基准的部分,则找到第k大的元素,返回当前基准数字

```c++
class Solution {
public:
    int findres(vector<int>& nums, int left, int right, int k) {
        srand(time(0));
        int pivot_index = rand() % (right - left + 1) + left;
        swap(nums[left],nums[pivot_index]);
        int less = left;
        int more = right+1;
        int i = left+1;
        while (i<more) {
            if (nums[i] < nums[left]) {
                less++;
                swap(nums[less],nums[i]);
                i++;
            } else if (nums[i] > nums[left]) {
                more--;
                swap(nums[more],nums[i]);
            } else {
                i++;
            }
        }
        swap(nums[left],nums[less]);
        /*
        [left,less-1] 小于基准
        [less,more-1] 等于基准
        [more,right] 大于基准
        */
        if (nums.size() -k < less) {
            return findres(nums,left,less-1,k);
        } else if (nums.size() -k >= more) {
            return findres(nums,more,right,k);
        } else {
            return nums[less];
        }
    }
    int findKthLargest(vector<int>& nums, int k) {
        return findres(nums,0,nums.size()-1,k);
    }
};
```

2.大顶堆

用数组所有元素建堆
然后删除堆顶k-1次(把数组末尾的元素换到数组第一项,堆大小-1)
之后堆顶元素为第k个最大元素

3.小顶堆

建立大小为k的小顶堆
遍历元素,当大于堆顶时则替换小顶堆堆顶
最后小顶堆堆顶为第k个最大元素

#### 数据流的中位数

1.维护2个优先队列(堆)

①q1,一个大顶堆,存储小于等于中位数的数
②q2,一个小顶堆,存储大于中位数的数

当加入的数字num<=第一个优先队列最大者(大顶堆堆顶)
加入第一个优先队列,否则加入第二个队列
(第一次加到第一个优先队列中)

当`q2.size() > q1.size()`,需要把第一个队列最大值移入第二个队列
当`q2.size() < q1.size() - 1`,需要把第二个队列中最小数移入第一个队列

若为奇数,即第一个队列元素更多,则中位数为第一个优先队列队头(堆顶)
否则为偶数,则中位数为两个堆堆顶的平均值

```c++
class MedianFinder {
    priority_queue<int,vector<int>,less<int>> maxheap;
    priority_queue<int,vector<int>,greater<int>> minheap;
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if (maxheap.empty() || num <= maxheap.top()) {
            maxheap.push(num);
            if (minheap.size() < maxheap.size() - 1) {
                minheap.push(maxheap.top());
                maxheap.pop();
            }
        } else {
            minheap.push(num);
            if (maxheap.size() < minheap.size()) {
                maxheap.push(minheap.top());
                minheap.pop();
            }
        }
    }
    
    double findMedian() {
        if (maxheap.size() > minheap.size()) {
            return maxheap.top();
        } else {
            return( maxheap.top() + minheap.top())/2.0;
        }
    }
};
```

2.有序集合(multiset)+双指针

当为偶数元素,left和right分别指向两个中位数
当为奇数元素,left和right指向同一个唯一中位数

```c++
class MedianFinder {
    multiset nums;
    multiset::iterator left, right;
    
public:
    MedianFinder() : left(nums.end()), right(nums.end()) {}
    
    void addNum(int num) {
        nums.insert(num);
        int n = nums.size();
        if (n == 1) {
            left = right = nums.begin();
        } else if (n & 1) { //此时nums大小为奇数个,需要更新left,right使之指向唯一的中位数
            if (num >= *left && num < *right) {
                left++;
                right--;
            } else if (num >= *right) {
                left++;
            } else {
                right--;
            }
        } else { //此时nums大小为偶数个,需要更新left,right使之指向两个分别的中位数
            if (num < *left) {
                left--;
            } else {
                right++;
            }
        }
    }

    double findMedian() {
        return (*left + *right) / 2.0;
    }
};
```

#### 会议室II(已知各会议开始结束时间,求最小房间数)

```c++
// 1.优先队列
// 最小堆,按结束时间排序
// 先按开始时间对所有会议排序,把第一个会议放进优先队列
// 对之后的其他会议,检查优先队列队头即可,比较当前遍历到会议的start和队头会议的end
// 之后把新的安排加入堆中即可
// (注意用lambda定义优先队列的方法,以及小顶堆的定义方法)
int minMeetingRooms_1(vector<vector<int>>& intervals) {
    sort(intervals.begin(),intervals.end());
    auto cmp = [](const vector<int> &l, const vector<int> &r){
        return l[1]>r[1];
    };
    priority_queue<vector<int>,vector<vector<int>>,decltype(cmp)> que(cmp);
    int cur_meeting = 1;
    int num_rooms = 1;
    que.push(intervals[0]);
    while (cur_meeting < intervals.size()) {
        if (que.top()[1] <= intervals[cur_meeting][0]) {
            que.pop();
            num_rooms--;
        }
        que.push(intervals[cur_meeting]);    
        cur_meeting++;
        num_rooms++;
    }
    return num_rooms;
}

// 2.按照会议的开始和结束时间排序
// 开始指针遍历按开始时间排序的会议,结束指针同理
// 当前结束指针指向会议结束时间<=当前开始指针指向会议开始时间:
// 表示此时一个会议确实已结束,结束指针后移,开始指针后移
// 反之,则使用的房间数+1,开始指针后移
int minMeetingRooms(vector<vector<int>>& intervals) {
    sort(intervals.begin(),intervals.end());
    vector<vector<int>> sorted_end = intervals;
    sort(sorted_end.begin(),sorted_end.end(),[](
        const vector<int> &l, const vector<int> &r){
            return l[1] < r[1];
        });
    int cur_start = 1;
    int cur_end = 0;
    int num_room = 1;
    while (cur_start < intervals.size()) {
        if (intervals[cur_start][0] >= sorted_end[cur_end][1]) {
            cur_end++;
            cur_start++;
        } else {
            num_room++;
            cur_start++;
        }
    }
    return num_room;
}
```

### 二叉树

#### 二叉树节点展开为链表

展开后的单链表应该同样使用 TreeNode 
其中 right 子指针指向链表中下一个结点,而左子指针始终为 null 

1. 将左子树插入到右子树的地方
2. 将原来的右子树接到左子树的最右边节点
3. 考虑新的右子树的根节点,一直重复上边的过程,直到新的右子树为 null

```java
public void flatten(TreeNode root) {
    while (root != null) { 
        //左子树为 null，直接考虑下一个节点
        if (root.left == null) {
            root = root.right;
        } else {
            // 找左子树最右边的节点
            TreeNode pre = root.left;
            while (pre.right != null) {
                pre = pre.right;
            } 
            //将原来的右子树接到左子树的最右边节点
            pre.right = root.right;
            // 将左子树插入到右子树的地方
            root.right = root.left;
            root.left = null;
            // 考虑下一个节点
            root = root.right;
        }
    }
}
```

#### 二叉树路径总和为指定值的路径数目

需要从根节点开始,也不需要在叶子节点结束,但是路径方向必须是向下的

**暴力方法O(n^2)**

```c++
int rootSum(TreeNode* root, int targetSum) {
    if (!root) {
        return 0;
    }

    int ret = 0;
    if (root->val == targetSum) {
        ret++;
    } 

    ret += rootSum(root->left, targetSum - root->val);
    ret += rootSum(root->right, targetSum - root->val);
    return ret;
}

int pathSum(TreeNode* root, int targetSum) {
    if (!root) {
        return 0;
    }

    int ret = rootSum(root, targetSum);
    ret += pathSum(root->left, targetSum);
    ret += pathSum(root->right, targetSum);
    return ret;
}
```

**前缀和O(N)**

我们定义节点的前缀和为由根结点到当前结点的路径上所有节点的和
利用先序遍历二叉树,记录下根节点 root 到当前节点 p 的路径上除当前节点以外所有节点的前缀和
在得到的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和curr减去targetSum

遍历过程中使用一个哈希表保存前缀和和其数量

```c++
class Solution {
public:
    unordered_map<long long, int> prefix;

    int dfs(TreeNode *root, long long curr, int targetSum) {
        if (!root) {
            return 0;
        }

        int ret = 0;
        curr += root->val;
        if (prefix.count(curr - targetSum)) {
            ret = prefix[curr - targetSum];
        }

        prefix[curr]++;
        ret += dfs(root->left, curr, targetSum);
        ret += dfs(root->right, curr, targetSum);
        prefix[curr]--;

        return ret;
    }

    int pathSum(TreeNode* root, int targetSum) {
        prefix[0] = 1;
        return dfs(root, 0, targetSum);
    }
};
```

### DP

#### 乘积最大的子数组

```c++
// DP,但如果只用一个DP数组从左到右处理,结果是错误的
// 因为对于该问题来说,当前位置的最优解未必是由前一个位置的最优解转移得到的
// 因为可能前面的若干个数乘积是负数,和后面一个负数又变正了,反而更大
// 所以不能只用DP记录前面一段数字中的最大乘积
// 需要再加一个DP数组记录最小乘积(负数)
int maxProduct(vector<int>& nums) {
    vector<long long> dp_max(nums.size()+1,1);
    vector<long long> dp_min(nums.size()+1,1);
    long long res = INT_MIN;
    for (int i=1; i<=nums.size(); i++) {
        long long n = nums[i-1];
        dp_max[i] = max(max(n*dp_max[i-1],n*dp_min[i-1]),n);
        dp_min[i] = min(min(n*dp_max[i-1],n*dp_min[i-1]),n);
        res = max(res, dp_max[i]);
    }
    return res;
}
```

#### 比特位1个数计数

```c++
// 动态规划
/*
对于奇数,它的1的个数是前一个数字1的个数+1
对于偶数,它的1的个数和其二分之一的1的个数相同
*/
vector<int> countBits(int n) {
    vector<int> dp(n+1,0);
    for (int i=1; i<=n; i++) {
        if (i%2==0) {
            dp[i] = dp[i/2];
        } else {
            dp[i] = dp[i-1] + 1;
        }
    }
    return dp;
}
```

#### 正则表达式匹配

```c++
// 动态规划
// 让s各字符和p各字符比较,比较过程中的状态用二维dp数组表示
// dp[i][j]表示s[0,i-1]和p[0,j-1]两个区间比较的结果
/*
确定dp[i][j]:
(1)p[j-1]=='*'
dp[i][j] = dp[i][j-2] || 
(dp[i-1][j] && s[i-1]==p[j-2]) || 
(dp[i-1][j] && p[j-2] == '.');
即三种情况:1.出现0次;2.p中'*'前面的字符出现大于等于1次;3.p中'*'前面的是'.'
(2)p[j-1]!='*"
dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');

dp数组初始化:dp[0][0]=true
当p[j-1] == '*'时, dp[0][j]=dp[0][j-2]
因为此时用于匹配的s是空字符串,而'*'匹配任意个前面的字符,包括0个
所以s为空串也符合要求,p[1]='*'时dp[0][2]==true,后面dp[3]=='*'时dp[0][4]也同理
(p必须是第偶数都个为*,p才能和空串s匹配上)
*/
bool isMatch(string s, string p) {
    int s_len = s.size();
    int p_len = p.size();

    vector<vector<bool>> dp(s_len+1,vector<bool>(p_len+1,false));
    dp[0][0] = true;
    for (int i=2; i<=p_len; i+=2) {
        if (p[i-1] == '*') {
            dp[0][i] = dp[0][i-2];
        }
    }

    for (int i=1; i<=s_len; i++) {
        for (int j=1; j<=p_len; j++) {
            if (p[j-1] == '*') {
                dp[i][j] = dp[i][j-2] ||
                    (dp[i-1][j] && s[i-1] == p[j-2]) ||
                    (dp[i-1][j] && p[j-2] == '.');
            } else {
                dp[i][j] = dp[i-1][j-1] &&
                    (s[i-1] == p[j-1] || p[j-1] == '.');
            }
        }
    }
    return dp[s_len][p_len];
}
```

#### 戳气球求最大分数

```c++
// 动态规划
// 在nums两边各添加一个1
/*
dp[i][j]:区间[i,j]内所有气球能得到的最多硬币数
状态转移:枚举区间[i,j]内的所有位置k
假设k是该区间中最后一个被戳破的气球,所以它的两边分别是i和j
dp[i][j] = max(dp[i][j], dp[i][k]+dp[k][j]+arr[i]*arr[k]*arr[j]);
因为i<k<j,所以要从大到小遍历i,从小到大遍历j
保证计算时dp[i][k]和dp[k][j]已经被计算出来

初始化0
注意[i,j]区间要至少长度为3.所以:
新定义一个arr数组存储nums,在1首尾各加一个1
遍历顺序:
i是左区间,从n-1到0;
j是右区间,从i+2开始到n+1
*/
int maxCoins(vector<int>& nums) {
    int n = nums.size();

    vector<int> arr(n+2,1);
    for (int i=0; i<n; i++) {
        arr[i+1] = nums[i];
    }

    vector<vector<int>> dp(n+2,vector<int>(n+2,0));

    for (int i=n-1; i>=0; i--) {
        for (int j=i+2; j<=n+1; j++) {
            for (int k=i+1; k<j; k++) {
                dp[i][j] = max(dp[i][j], 
                dp[i][k]+dp[k][j]+arr[i]*arr[j]*arr[k]);
            }
        }
    }
    return dp[0][n+1];
}
```

#### 最长有效括号序列

```c++
int longestValidParentheses(string s) {
    int n = s.size();
    vector<int> dp(n,0);
    /*
    状态转移:
    若当前字符s[i]是(,则一定无效
    若当前字符s[i]是):
    若s[i-1]是(,dp[i] = 2 + dp[i-2];
    若不是,则该右括号可能和更左边的左括号匹配:
    和其匹配的更左边的左括号位置: i-dp[i-1]-1
    所以当 if (i - dp[i-1] -1 >= 0 && s[i - dp[i-1] -1] == '(')
    若匹配: dp[i] = dp[i-1] + 2;
    另外还要考虑和更左边的有效字符串可以连起来的情况:
    if (i-dp[i-1]-2 >= 0) dp[i] = dp[i] + dp[i-dp[i-1]-2];
    */
    int max_len = 0;
    for (int i=1; i<n; i++) {
        if (s[i] == ')') {
            if (s[i-1] == '(') {
                dp[i] = 2;
                if (i-2 >= 0) {
                    dp[i] = dp[i] + dp[i-2];
                }
            } else if (dp[i-1] > 0) {
                if (i-dp[i-1]-1>=0 && s[i-dp[i-1]-1]=='(') {
                    dp[i] = dp[i-1] + 2;
                    if (i-dp[i-1]-2>=0){
                        dp[i] = dp[i] + dp[i-dp[i-1]-2];
                    }
                }
            }
        }
        max_len = max(max_len, dp[i]);
    }
    return max_len;
}
```

#### 最大正方形

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内,找到只包含 `'1'` 的最大正方形,并返回其面积

递推公式考虑左边,上边,左上

```c++
int maximalSquare(vector<vector<char>>& matrix) {
    int n = matrix.size();
    int m = matrix[0].size();
    // dp[i+1][j+1]表示以matrix[i][j]为右下角的最大正方形边长
    vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
    int max_len = 0;
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            if (matrix[i][j] == '0') {
                continue;
            }         
            dp[i+1][j+1] = min(min(dp[i+1][j],dp[i][j+1]),dp[i][j])+1;
            max_len = max(max_len, dp[i+1][j+1]);
        }
    }
    return max_len * max_len;
}
```

#### 最小路径和

给定一个包含非负整数的 `mxn` 网格 `grid` 
请找出一条从左上角到右下角的路径使得路径上的数字总和为最小

```c++
// 二维DP数组
int minPathSum_1(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    vector<vector<int>> dp(n+1,vector<int>(m+1,INT_MAX));
    dp[0][1] = dp[1][0] = 0; // 确保dp[1][1] = grid[0][0]
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            dp[i+1][j+1] = min(dp[i][j+1],dp[i+1][j]) + grid[i][j];
        }
    }
    return dp[n][m];
}
// 使用一维数组
int minPathSum(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    vector<int> dp(m+1,INT_MAX);
    dp[1] = 0;
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            dp[j+1] = min(dp[j+1],dp[j]) + grid[i][j];
        }
    }
    return dp[m];
}
```

### 回溯

#### 单词搜索(单词是否存在于网格中)

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 
如果 `word` 存在于网格中,返回 `true` ;否则,返回 `false`

```c++
// 回溯法,DFS
// 通过在原方格中改字符为'#'表示访问过,不需要另外的visited数组
// 结束遍历条件:1.搜索路径字符串新加入的字母和目标单词对应位置不一致,返回false
// 2.搜索路径字符串等于目标单词,返回true
vector<vector<int>> directions{{1,0},{0,1},{-1,0},{0,-1}};
bool dfs(vector<vector<char>>& board, string &target, 
int i, int j, string &path) {
    if (path.back() != target[path.size()-1]) {
        return false;
    }
    if (path == target) {
        return true;
    }
    char c = board[i][j];
    board[i][j] = '#';
    for (int k=0; k<4; k++) {
        int next_i = i+directions[k][0];
        int next_j = j+directions[k][1];
        if (next_i >= 0 && next_i < board.size() 
        && next_j >= 0 && next_j < board[0].size()) {
            if (board[next_i][next_j] != '#') {
                path.push_back(board[next_i][next_j]);
                bool res = dfs(board,target,next_i,next_j,path);
                path.pop_back();
                if (res) return true;
            }
        }
    }
    board[i][j] = c;
    return false;
}
bool exist(vector<vector<char>>& board, string word) {
    for (int i=0; i<board.size(); i++) {
        for (int j=0; j<board[0].size(); j++) {
            string path;
            path.push_back(board[i][j]);
            bool res = dfs(board,word,i,j,path);
            if (res) return true;
        }
    }
    return false;
}
```

#### 求所有可能且有效括号组合

```c++
// 回溯搜索
// 1.DFS过程中判断当前是否可以填左/右括号,然后往下递归遍历+回溯
// 有效:填入左括号时,需要左括号数量<n,填入右括号时,需要右括号数量<左括号数量;
// 若左括号为left_num个,此时生成到的下标为i,则此时右括号数量为i-left_num
vector<string> res;
void dfs(int n, string path, int now_index, int left_num) {
    if (now_index == n*2) {
        res.push_back(path);
        return;
    }
    if (left_num < n) {
        path.push_back('(');
        dfs(n,path,now_index+1,left_num+1);
        path.pop_back();
    }
    if (now_index - left_num < left_num) {
        path.push_back(')');
        dfs(n,path,now_index+1,left_num);
        path.pop_back();
    }
}
vector<string> generateParenthesis(int n) {
    string path;
    dfs(n,path,0,0);
    return res;
}
```

#### 除法求值

```c++
class Solution {
public:
    double ans;
    void dfs(unordered_map<string,vector<string>> &edges,
    unordered_map<string,vector<double>> &weights, 
    double res, unordered_set<string> &visited, string last_visited, string target) {
      
        if (last_visited == target) {
            ans = res;
            return;
        }
        visited.insert(last_visited);
        for (int i=0; i<edges[last_visited].size(); i++) {
            if (visited.count(edges[last_visited][i]) == 0) {
                dfs(edges,weights,res*weights[last_visited][i],
                visited,edges[last_visited][i],target);
            }
        }
        visited.erase(last_visited);
    }

    // 转化为图问题
    // DFS即可
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        unordered_map<string,vector<string>> edges;
        unordered_map<string,vector<double>> weights;
        for (int i=0; i<values.size(); i++) {
            string a = equations[i][0];
            string b = equations[i][1];
            edges[a].push_back(b);
            weights[a].push_back(values[i]);
            edges[b].push_back(a);
            weights[b].push_back(1.0/values[i]);
        }
        vector<double> res;
        for (int i=0; i<queries.size(); i++) {
            ans = -1.0;
            unordered_set<string> visited;
            if (edges.count(queries[i][0]) > 0)
            dfs(edges,weights,1.0,visited,queries[i][0],queries[i][1]);
            res.push_back(ans);
        }
        return res;
    }
};
```

### 位运算

#### 汉明距离

```c++
// 对x和y向右移位,每次比较最后一位
// 直到x和y没有1
int hammingDistance(int x, int y) {
    int res = 0;
    while (x | y != 0) {
        int a = x & 1;
        int b = y & 1;
        if (a != b) res += 1;
        x >>= 1;
        y >>= 1;
    }
    return res;
}
```

#### 异或自反性

自反性 A XOR B XOR B = A xor 0 = A

### 拓扑排序

#### 课程表(队列实现拓扑排序)

这个学期必须选修 `numCourses` 门课程,记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程, 先修课程按数组 `prerequisites` 给出,其中 `prerequisites[i] = [ai, bi]`,表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 

判断是否可以完成所有课程的学习

```c++
// 拓扑排序
// 用队列存储入度为0的节点
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<vector<int>> grid(numCourses);
    vector<int> indegree(numCourses);
    for (auto v : prerequisites) {
        int a = v[0];
        int b = v[1];
        grid[b].push_back(a);
        indegree[a]++;
    }

    queue<int> q;
    for (int i=0; i<numCourses; i++) {
        if (indegree[i] == 0) {
            q.push(i);
        }
    }
    int res  = 0;
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        res++;
        for (int next : grid[cur]) {
            indegree[next]--;
            if (indegree[next] == 0) {
                q.push(next);
            }
        }
    }
    return res == numCourses;
}
```

#### 课程表 II(DFS判断有环)

题目同上,求一个序列

```c++
class Solution {
public:
    bool has_cycle = false;
    vector<int> visited;
    vector<int> result;
    vector<vector<int>> edges;
    void dfs(int startindex) {
        visited[startindex] = 1;
        for (int next : edges[startindex]) {
            if (visited[next] == 0) {
                dfs(next);
                if (has_cycle) {
                    return;
                }
            } else if (visited[next] == 1) {
                has_cycle = true;
                return;
            }
        }
        visited[startindex] = 2;
        result.push_back(startindex);
    }
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        visited.resize(numCourses);
        edges.resize(numCourses);
        for (auto v : prerequisites) {
            edges[v[1]].push_back(v[0]);
        }
        for (int i=0; i<numCourses && !has_cycle; i++) {
            if (visited[i] == 0) {
                dfs(i);
            }
        }
        if (has_cycle) {
            return {};
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
```

### 其他

#### 数组划分成和相等三份

```c++
bool canThreePartsEqualSum(vector<int>& A) {
    int sum = accumulate(A.begin(), A.end(), 0);
    if (sum % 3 != 0) {
        return false;
    }
    int count = 0, subSum = 0;
    for (int i = 0; i < A.size(); i ++) {
        subSum += A[i];
        if (subSum == sum / 3) {
            count ++;
            subSum = 0;
        }
        if (count == 3) {
            return true;
        }
    }
    return false;
}
```

#### 最短无序连续子数组

给你一个整数数组 `nums` ,你需要找出一个 连续子数组 
如果对这个子数组进行升序排序,那么整个数组都会变为升序排序
找出符合要求的最短子数组的长度

```c++
// 1.排序后比较
int findUnsortedSubarray_1(vector<int>& nums) {
    vector<int> sorted_nums(nums);
    sort(sorted_nums.begin(),sorted_nums.end());
    int right = nums.size()-1;
    int left = 0;
    for (int i=nums.size()-1;i>=0;i--) {
        if (nums[i] == sorted_nums[i]) {
            right--;
        } else {
            break;
        }
    }
    for (int i=0; i<nums.size(); i++) {
        if (nums[i] == sorted_nums[i]) {
            left++;
        } else {
            break;
        }
    }
    if (left == nums.size()) {
        return 0;
    }
    return right - left + 1;
}
// 2.不适用额外空间的方法
// 从右到左,寻找第一个不符合降序排列的数,在数字即将变大前返回
// 目标子数组右边界一定在该位置右边
// 之后求开头到该位置的最大元素,然后往右找比该最大元素更大的,就是真正的右边界
// 求左边界同理
#include<algorithm>
int findUnsortedSubarray(vector<int>& nums) {
    int right;
    int i;
    for (i=nums.size()-1; i>0; i--) {
        if (nums[i-1] > nums[i]) {
            break;
        }
    }
    if (i==0) {
        return 0;
    }
    int max_tmp = *max_element(nums.begin(),nums.begin()+i+1);
    for (;i<nums.size()-1;i++) {
        max_tmp = max(max_tmp, nums[i]);
        if (nums[i+1] >= max_tmp) {
            break;
        }
    }
    right = i;

    int left;
    for (i=0; i<nums.size()-1; i++) {
        if (nums[i+1] < nums[i]) {
            break;
        }
    }
    int min_tmp = *min_element(nums.begin()+i+1,nums.end());
    for (;i>0;i--) {
        min_tmp = min(min_tmp, nums[i]);
        if (nums[i-1] <= min_tmp) {
            break;
        }
    }
    left = i;

    return right - left + 1;
}
```

#### 顺时针旋转nxn矩阵

```c++
// 辅助矩阵
// matrix[i][j]旋转90度后到matrix[j][n-1-i]
// 同理matrix[n-1-j][i]旋转90度后到matrix[i][j]
// 所以新建一个辅助矩阵存原数据
void rotate_1(vector<vector<int>>& matrix) {
    auto matrix1 = matrix;
    int n = matrix.size();
    for (int i=0; i < n; i++) {
        for (int j=0; j < n; j++) {
            matrix[i][j] = matrix1[n-1-j][i];
        }
    }
}

// 原地修改
// 一共需要转n/2圈 for i in range(n/2)
// 每圈从i到n-i-1遍历j
/*
从第i行第j列开始的旋转过程如下:
1.临时变量tmp保存matrix[i][j]
2.matrix[i][j] = matrix[n-1-j][i]
3.matrix[n-1-j][j]=matrix[n-1-i][n-1-j]
4.matrix[n-1-i][n-1-j]=matrix[j][n-i-1]
5.matrix[j][n-i-1]=tmp
*/
void rotate(vector<vector<int>>& matrix) {
    int n = matrix.size();
    int loop = n / 2;
    for (int i=0; i<loop; i++) {
        for (int j=i; j<n-i-1; j++) {
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[n-1-j][i];
            matrix[n-1-j][i] = matrix[n-1-i][n-1-j];
            matrix[n-1-i][n-1-j] = matrix[j][n-i-1];
            matrix[j][n-i-1] = tmp;
        }
    }
}
```

#### POW(x,n)(快速幂)

递归算法实现的是快速幂运算.
它通过将问题规模不断缩小,能够在 O(log n) 时间复杂度内计算 x^n

```c++
// 递归法
double myPow(double x, int n) {
    if (n == 0) {
        return 1;
    }
    if (n == 1) {
        return x;
    }
    if (n == -1) {
        return 1 / x;
    }
    double tmp = myPow(x, n>>1);
    if (n % 2 == 0) {
        return tmp * tmp;
    } else {
        return tmp * tmp * x;
    }
}
```

#### 找到数组中消失的所有数字

```c++
// 原地修改:用对应下标乘-1表示出现过(只乘-1也不覆盖原数组元素)
vector<int> findDisappearedNumbers(vector<int>& nums) {
    vector<int> res;
    for (int i=0; i<nums.size(); i++) {
        int n = abs(nums[i]);
        if(nums[n-1]>0) nums[n-1] *= -1;
    }
    for (int i=0; i<nums.size(); i++) {
        if(nums[i]>0) res.push_back(i+1);
    }
    return res;

}
```

#### 任务调度器(同类任务间有冷却时间n)

```c++
// 桶思想
// 设所给任务中,单一种类任务的最多数量为X,冷却时间n
// 则建立X个桶子,可以保证每个桶子中存放的任务种类互不相同
// 执行一个桶内部的任务,不需要等待冷却时间(任务互不相同)
// 每个桶的大小定为n+1
// 如果一个桶满(n+1),执行完该桶中某类任务,到下一个桶中该类任务时冷却时间n正好结束
/*
(1) 任务种类不多,可以在大小为n+1的X个桶中放得下
1.若桶中任务数<n+1,则执行完桶中任务后,还需要等待第一个任务冷却时间结束才能执行下一个桶
所以除最后一个桶外,前面桶自身执行+等待下一个时间为n+1
最后一个桶不用等,时间=最后一个桶的任务数
2.若桶中任务数=n+1,则执行完桶中任务后,可以马上执行下一个桶
以上两种情况总时长 = (X-1) * (n+1) + 最后一个桶的任务数

最后一个桶的任务数计算:
任务数量==X的任务种类数
(如'A'类和'B'任务都有X个,则最后一个桶放2个)

(2) 任务种类很多,大小为n+1的X个桶中放不下
若某些桶中可能需要放大于n+1个任务
显然只要每个桶中任务互不相同,桶中放更多的任务不会导致需要等待冷却时间
对于完全不存在冷却时间的情况,时长=总的任务个数 S

最终结果只要在上面(1)(2)两种情况中取最大值即可
即结果=max((X-1) * (n+1) + 最后一个桶的任务数, S);
*/
// 
int leastInterval(vector<char>& tasks, int n) {
    vector<int> count_map(26,0);
    for (char c:tasks) {
        count_map[c-'A']++;
    }
    sort(count_map.rbegin(),count_map.rend());
    int last_bucket = 1;
    int max_num = count_map[0];
    while (last_bucket < count_map.size()) {
        if (count_map[last_bucket] == max_num) {
            last_bucket++;
        } else {
            break;
        }
    }
    int num1 = (max_num-1) * (n+1) + last_bucket;
    int num2 = tasks.size();
    return max(num1, num2);
}
```

#### 除自身以外数组的乘积

给你一个整数数组 `nums`,返回 数组 `answer` 
其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积
不允许使用除法,且在O(n)的时间复杂度内完成

```c++
// 计算后缀乘积和前缀乘积数组
// 将计算前缀乘积和得到结果都放在第二个循环中进行
// 减少一次循环,结果直接原地存在suf中
vector<int> productExceptSelf(vector<int>& nums) {
    vector<int> suf(nums.size(),1);
    for (int i=nums.size()-2; i>=0; i--) {
        suf[i] = nums[i+1] * suf[i+1];
    }
    int pre = 1;
    for (int i=0; i<nums.size(); i++) {
        suf[i] = pre * suf[i];
        pre = pre * nums[i];
    }
    return suf;
}
```

#### 二进制求和

(leetcode 67)

整体思路是将两个字符串较短的用 0 补齐, 使得两个字符串长度一致, 然后从末尾进行遍历计算

```c++
class Solution {
public:
    string addBinary(string a, string b) 
    {
        int asize = a.size(), bsize = b.size();
        while (asize > bsize)//补齐
        {
            b = '0' + b;
            bsize++;
        }
        while (asize < bsize)
        {
            a = '0' + a;
            asize++;
        }
        int carry = 0;  //进位
        // 注意输入的字符串是大端顺序,数字的低位在字符串的高位
        for (int i = asize - 1; i >= 0; i--)
        {
            int sum = a[i] - '0' + b[i] - '0' + carry;
            a[i] = (sum) % 2+'0';//本位数值
            carry = sum / 2;//进位更新
        }
        if (carry > 0)//有溢出
            a = '1' + a;
        return a;
    }
};
```

#### 二叉树的直径

分别对左孩子和右孩子递归,计算最大深度max(L,R)+1

将左右两个孩子的结果相加+1为以当前接待你为中心的直径
计算L+R+1,用一个全局变量保存递归过程中最大的直径

#### 字符串转换整数(atoi)

我们可以使用自动机这个概念

```c++
#include <ctype.h>
class Automaton {
    string state = "start";
    unordered_map<string, vector<string>> table = {
        {"start", {"start", "signed", "in_number", "end"}},
        {"signed", {"end", "end", "in_number", "end"}},
        {"in_number", {"end", "end", "in_number", "end"}},
        {"end", {"end", "end", "end", "end"}}
    };

    int get_col(char c) {
        if (isspace(c)) return 0;
        if (c == '+' or c == '-') return 1;
        if (isdigit(c)) return 2;
        return 3;
    }
public:
    int sign = 1;
    long long ans = 0;

    void get(char c) {
        state = table[state][get_col(c)];
        if (state == "in_number") {
            ans = ans * 10 + c - '0';
            ans = sign == 1 ? 
                min(ans, (long long)INT_MAX) 
                : min(ans, -(long long)INT_MIN);
        }
        else if (state == "signed")
            sign = c == '+' ? 1 : -1;
    }
};

class Solution {
public:
    int myAtoi(string str) {
        Automaton automaton;
        for (char c : str)
            automaton.get(c);
        return automaton.sign * automaton.ans;
    }
};
```
