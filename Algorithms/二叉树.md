## 1.概念与遍历

满二叉树:只有度为0和度为2的结点,并且度为0的结点在同一层上
深度为k,有2^k-1个节点的二叉树

完全二叉树:
除了最底层节点可能没填满外,其余每层节点数都达到最大值
并且最下面一层的节点都集中在该层最左边的若干位置
最底层为第 h 层(h从1开始),则该层包含 1~ 2^(h-1) 个节点

二叉搜索树:有序,左子树小于根,右子树大于根

平衡二叉搜索树:空树或左右子树高度相差不超过1

定义:
```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

### 递归遍历

>  **递归三要素:**
>
> **①确定递归函数的参数和返回值**
> **②确定递归的终止条件**
> **③确定单层递归中的逻辑**

前序遍历:
其他递归遍历同理

```c++
// 不需要返回值,需要树当前结点和存储结果的数组做参数
void traversal(TreeNode* cur, vector<int>& vec) {
    // 结束条件,遍历到NULL
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中
	traversal(cur->left, vec);  // 左
	traversal(cur->right, vec); // 右
}
```

### 迭代方式实现前/中/后序遍历

使用栈来实现,前序和后序思路类似,中序有所不同

**递归实现前序遍历**

遍历顺序中左右,右孩子先入栈,左孩子后入栈,才能使出栈的顺序是中左右
先把根节点放入栈中,每次:
①栈顶元素是当前要遍历的中间结点,出栈
②右孩子入栈
③左孩子入栈

```c++
st.push(root);
while (!st.empty()) {
    TreeNode* node = st.top(); // 中
    st.pop();
    result.push_back(node->val);
    if (node->right) st.push(node->right); // 右（空节点不入栈）
    if (node->left) st.push(node->left); // 左（空节点不入栈）
}
```

**迭代实现后序遍历**

后续遍历顺序左右中

先序遍历顺序是中左右,只要把其遍历顺序改为中右左,最后再把遍历结果逆序,即得到左右中
所以每次①栈顶出栈(中)②左孩子入栈③右孩子入栈

```c++
st.push(root);
while (!st.empty()) {
    TreeNode* node = st.top();
    st.pop();
    result.push_back(node->val);
    // 相对于前序遍历,这更改一下入栈顺序
    if (node->left) st.push(node->left);
    if (node->right) st.push(node->right);
}
// 循环结束后得到中右左的遍历顺序
reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
```

**迭代实现中序遍历**

先访问根节点(中间结点),但必须先遍历左孩子,再遍历中间结点
**访问顺序和左中右遍历顺序不一致**,导致无法不能像先序和后序(反转后)一样写出相对简洁的代码
因此需要一个当前结点指针cur负责访问,cur访问的顺序为访问顺序,栈弹出顺序为遍历处理顺序

设当前节点为根节点,之后循环进行以下步骤:
①用指针访问当前结点的左结点,同时将路径上结点入栈,直到到达NULL
②到达NULL,将栈顶出栈,出栈的元素为按中序遍历顺序当前应遍历到的数据
③置当前节点为右孩子

(到叶子结点,左孩子入栈,发现左孩子空,自身出栈,右孩子入栈,发现右孩子空,之后出栈的即是上一层结点)

> 继续循环的条件:cur和栈不同时为空
> cur不空,表示**此时需用cur继续访问二叉树,前往中序遍历左中右顺序规定的下一个结点位置**
> cur为空但栈不空,表示**此时应该出栈,获取遍历元素**;

```c++
stack<TreeNode*> st;
TreeNode* cur = root;
while (cur != NULL || !st.empty()) {
    if (cur != NULL) { // 指针来访问节点,访问到最底层
        st.push(cur); // 将访问的节点放进栈
        cur = cur->left; // 左
    } else {
        cur = st.top(); // 弹出的数据,就是要处理的数据(放进result数组里的数据)
        st.pop();
        result.push_back(cur->val); // 中
        cur = cur->right; // 右
    }
}
```

### 层次遍历(队列)

根节点入队,之后只要队列不空,进行以下循环
将目前为止队列中各结点依次出队,同时将出队的各结点的左右孩子分别依次入队

```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<vector<int>> result;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;
        // 这里一定要使用固定大小size,不要使用que.size(),因为que.size是不断变化的
        for (int i = 0; i < size; i++) {
            TreeNode* node = que.front();
            que.pop();
            vec.push_back(node->val);
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
        }
        result.push_back(vec);
    }
    return result;
}
```

补充:递归法

```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    int depth = 0;
    order(root, result, depth);
    return result;
}
void order(TreeNode* cur, vector<vector<int>> &result, int depth) {
    if (cur == nullptr) {
        return;
    }
    if (depth == result.size()) { // 每层第一个
        result.push_back(vector<int>());
    }
    result[depth].push_back(cur->val);
    order(cur->left, result, depth+1);
    order(cur->right, result, depth+1);
}
```

## 2.层次遍历题目

### 层次遍历Ⅱ

就是最后把result数组反转一下就可以了

### 二叉树的右视图

层序遍历的时候,判断是否遍历到单层的最后面的元素,如果是,就放进result数组中

### 给结点next指针赋值

```c++
Node* connect(Node* root) {
    queue<Node*> que;
    if (root != NULL) que.push(root);
    while (!que.empty()) {
        int size = que.size();
        Node* pre;
        for (int i=0;i<size;i++) {
            Node* cur = que.front();
            if (i>0) {
                pre->next = cur;
            }
            pre = cur;
            que.pop();
            if(cur->left) que.push(cur->left);
            if(cur->right) que.push(cur->right);
        }
        pre->next = NULL;
    }
    return root;
}
```

## 3.翻转二叉树

使用先序遍历和后序遍历都可以,但中序不行(原因见后)

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右
        return root;
    }
};
```

不能使用中序的原因:

> 中序:先给左孩子递归调用invert,然后swap,之后给右孩子递归调用invert
> swap后原来的左孩子变成右孩子,导致原来的左孩子(新右孩子)被调用两次invert,原来的右孩子没被翻转过
>
> 除非swap前后都调用`invertTree(root->left);`

## 4.对称二叉树

### 递归法

比较的是两个子树的里侧和外侧的元素是否相等
本题遍历只能是**“后序遍历”**,因要通过递归函数返回值判断两个子树的内侧节点和外侧节点是否相等

因要比两个子树的里侧和外侧的元素是否相等,所以一个子树遍历顺序是左右中,另一个是右左中

递归三部曲:

①参数和返回值

返回值:bool
参数:left和right子树指针

②递归终止条件

①左右都空,对称,返回true
②左右一个空,一个不空,不对称,返回false
③左右都不空,还需要比较左右孩子结点的val
若`left->val != right->val`,则一定不对称,返回false
④左右不为空,且`left->val == right->val`,则需要进一步判断

③单层递归逻辑

之前的判断流程之后之后才进行递归比较
对下一层的两个外侧和两个内侧分别递归调用compare,返回两个比较结果的&&

```c++
bool outside = compare(left->left, right->right);
bool inside = compare(left->right, right->left);
bool isSame = outside && inside;
return isSame;
```

完整代码:

```c++
class Solution {
public:
    bool compare (TreeNode* left, TreeNode* right) {
        if (!left && !right) {
            return true;
        }
        if (!left || !right) {
            return false;
        }
        if (left->val != right->val) {
            return false;
        }
        bool llrr = compare(left->left,right->right);
        bool lrrl = compare(left->right,right->left);
        return llrr && lrrl;
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left, root->right);
    }
};
```

### 迭代法

比较2个结点:把二者同时加入队列中

**为了比较,空节点也要入队**

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将根节点的左子树头结点加入队列
        que.push(root->right);  // 将根节点的右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            // 每次出队的连续2个都是要比较的结点
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空,右节点为空,此时说明是对称的
                continue;
            }

            // 左右一个节点不为空,或者都不为空但数值不相同,返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            // 加入时不判断空,NULL也要加入队列
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

### 判断相同的树

同理,同时遍历两棵树

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p && !q) {
        return true;
    }
    if (!p || !q) {
        return false;
    }
    if (p->val != q->val) {
        return false;
    }
    return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);
}
```

### 和另一棵树相同的子树

暴力搜索,从每一个和B树根节点相同的A树结点开始,同时遍历AB两数,逐个匹配

```c++
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if (!root) {
            return false;
        }
        if (root->val == subRoot->val) {
            if(compareTwoTrees(root,subRoot)) {
                return true;
            }
        }
        return isSubtree(root->left,subRoot) || isSubtree(root->right,subRoot);
    }
    bool compareTwoTrees (TreeNode* root, TreeNode* subRoot) {
        if (!root && !subRoot) {
            return true;
        }
        if (!root || !subRoot) {
            return false;
        }
        if (root->val != subRoot->val) {
            return false;
        }
        return compareTwoTrees(root->left,subRoot->left) && compareTwoTrees(root->right,subRoot->right);
    }
};
```

## 5.二叉树的最大深度

### 递归法

**二叉树结点的深度和高度**:

> 二叉树节点的深度: 指从根节点往下到该节点的最长简单路径边的条数/结点数
> 二叉树节点的高度: 指从该节点往下到叶子节点的最长简单路径边的条数/结点数
> (力扣按节点个数计算,即根节点深度是1,叶子节点高度是1)
> 求深度可以从上到下去查,所以前序遍历(中左右)
> 而高度只能从下到上去查,所以后序遍历(左右中)

本题求的是二叉树的最大深度:
**而根节点的高度就是二叉树的最大深度**,所以求根节点的高度即可

> 上面说求深度必须用**前序遍历**(需通过参数传入depth)
> **但本题求最大深度,却用了后序遍历,因为本题把最大深度转换为根节点的高度**

代码:

```c++
int maxDepth(TreeNode* root) {
    // 后序遍历
    if(root==NULL) return 0; // 递归终止条件
    return max(maxDepth(root->left),maxDepth(root->right))+1;
}
```

若使用**前序遍历**,遵循**回溯法的一般过程**:(需要传入depth参数)

> ```c++
> int result;
> void getdepth(TreeNode* node, int depth) {
>     result = depth > result ? depth : result; // 中
> 
>     if (node->left == NULL && node->right == NULL) return ;
> 
>     if (node->left) { // 左
>         depth++;    // 深度+1
>         getdepth(node->left, depth);
>         depth--;    // 回溯,深度-1
>     }
>     if (node->right) { // 右
>         depth++;    // 深度+1
>         getdepth(node->right, depth);
>         depth--;    // 回溯,深度-1
>     }
>     return ;
> }
> ```
>
> **简化后:**
>
> ```c++
> int result;
> void getdepth(TreeNode* node, int depth) {
>     result = depth > result ? depth : result; // 中
>     if (node->left == NULL && node->right == NULL) return ;
>     if (node->left) { // 左
>         getdepth(node->left, depth + 1);
>     }
>     if (node->right) { // 右
>         getdepth(node->right, depth + 1);
>     }
>     return ;
> }
> ```

### 迭代法

在层序遍历过程中记录层数即可

## 6.二叉树的最小深度

最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量
(一定是要到**叶子结点**才算,若根节点自己就是叶子节点,则深度为1)
<img src=".\images\18.JPG" alt="18" style="zoom:67%;" />

### 递归法

```c++
int getDepth(TreeNode* node) {
    if (node == NULL) return 0;
    int leftDepth = getDepth(node->left);
    int rightDepth = getDepth(node->right);
    // 当一个左子树为空,右不为空,这时并不是最低点
    if (node->left == NULL && node->right != NULL) { 
        return 1 + rightDepth;
    }   
    // 当一个右子树为空,左不为空,这时并不是最低点
    if (node->left != NULL && node->right == NULL) { 
        return 1 + leftDepth;
    }
    int result = 1 + min(leftDepth, rightDepth);
    return result;
}
```

### 迭代法

使用层序遍历的方式来解决

只有当该层某个结点的左右孩子都为空的时候,才说明遍历到最低点了
**如果其中一个孩子不为空则不是最低点**

```c++
int minDepth(TreeNode* root) {
    int depth = 0;
    queue<TreeNode*> que;
    if(root) que.push(root);
    while(!que.empty()){
        int size = que.size();
        depth++;
        for (int i=0; i<size; i++){
            TreeNode* cur = que.front();
            que.pop();
            if (!cur->left && !cur->right) {
                return depth;
            }
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }
    }
    return depth;
}
```

## 7.完全二叉树的节点个数

### 普通二叉树的方法

后序

```c++
int countNodes(TreeNode* root) {
    if (root == NULL) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

### 完全二叉树的方法

完全二叉树的两种情况:
①最后一层满,即满二叉树
②最后一层不满

对于①,可使用2^k-1计算结点个数
对于②,就递归其左右孩子,直到遇到满二叉树为止,然后用①的公式计算

判断是不是①(满二叉树):
**在题目已经说了是完全二叉树的情况下:**
向左遍历left = left->left的深度和向右遍历right->right的深度相同,则是满二叉树
(该结论建立在已经是完全二叉树的基础上,否则不能这么判断)

时间复杂度O(logN x logN)

```c++
int countNodes(TreeNode* root) {
    if (!root) {
        return 0;
    }
    TreeNode* left = root->left;
    TreeNode* right = root->right;
    int leftdepth = 0;
    int rightdepth = 0;
    while (left) {
        left = left->left;
        leftdepth++;
    }
    while (right) {
        right = right->right;
        rightdepth++;
    }
    if (leftdepth == rightdepth) {
        return (2<<leftdepth) -1;
    }
    return countNodes(root->left) + countNodes(root->right) + 1;
}
```

## 8.平衡二叉树

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1

### 递归法

后续遍历,先获得左右子树各自的高度,再判断高度差,确定是否平衡

递归终止条件:
NULL,返回0

**因为二叉树平衡与否由左右孩子的高度之差来判断,所以左右孩子递归调用的返回值应为各自树的高度**

返回值:以当前结点为根节点二叉树的树的高度
`result = 1 + max(leftHeight, rightHeight);`
如果发现左右子树二者高度差已经大于1,则已经不是平衡二叉树,再返回高度没意义,返回-1表示不平衡
如果两个孩子递归调用返回的高度值中有任意一个为-1,则这棵树一定不是平衡二叉树,直接返回-1

```c++
class Solution {
public:
    int judge(TreeNode* cur) {
        if (!cur) {
            return 0;
        }
        int leftHeight = judge(cur->left);
        if (leftHeight == -1) return -1;
        int rightHeight = judge(cur->right);
        if (rightHeight == -1) return -1;
        if (abs(rightHeight-leftHeight) > 1) return -1;
        return max(rightHeight,leftHeight)+1;
    } 
    bool isBalanced(TreeNode* root) {
        return judge(root) != -1;
    }
};
```

**迭代法**

可以使用层序遍历来求深度,但是就不能直接用层序遍历来求高度了,这就体现出求高度和求深度的不同
所以用迭代法麻烦,不如直接用递归法

## 9.二叉树的所有路径

### 回溯法

使用前序遍历
<img src="./images/19.jpg" alt="19" style="zoom:67%;" />

递归函数参数需要传入:记录每一条路径的path
每次遍历到达最底下的叶子结点的时候,就往result中保存本次的path

递归终止条件:
不能是`cur==NULL`,因为在到达叶子结点时就要保存路径了
所以应该是`cur->left == NULL && cur->right == NULL`,此时需要保存路径至result

> 如果在`cur==NULL`时保存路径:
> 则会导致到达叶子结点的左孩子(NULL)和右孩子(NULL)时都会分别保存一次路径,保存两次

到达叶子结点时的处理:转为string

```c++
string sPath;
for (int i = 0; i < path.size() - 1; i++) {
    // 将path里记录的路径转为string格式
    sPath += to_string(path[i]);
    sPath += "->";
}
sPath += to_string(path[path.size() - 1]); // 记录最后一个节点(叶子节点)
result.push_back(sPath); // 收集一个路径
return;
```

单层递归处理逻辑:

> **将path的回溯隐藏在函数参数的传递中(参数传递的是拷贝)**:
> (**如果参数是引用类型,就要手动回溯(pop()**)

```c++
// 当前结点加入path
path.push_back(cur->val);

// 检查当前是否是叶子节点
...
  
if (cur->left) { // 左 
    traversal(cur->left, path, result);
}
if (cur->right) { // 右
    traversal(cur->right, path, result);  
}
```

**完整代码**

```c++
class Solution {
public:
    vector<string> result;
    void traverse(TreeNode* cur, vector<int> path) {
        path.push_back(cur->val);
        string path_str;
        if (!cur->left && !cur->right) {
            for (int i=0; i<path.size()-1; i++) {
                path_str += to_string(path[i]);
                path_str += "->";
            }
            path_str += to_string(path[path.size()-1]);
            result.push_back(path_str);
        }
        if (cur->left) {
            traverse(cur->left,path);
        }
        if (cur->right) {
            traverse(cur->right,path);
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<int> path;
        if(root) traverse(root, path);
        return result;
    }
};
```

**精简版本的代码:**

使用string作为path

```c++
void traversal(TreeNode* cur, string path, vector<string>& result) {
    path += to_string(cur->val); // 中
    if (cur->left == NULL && cur->right == NULL) {
        result.push_back(path);
        return;
    }
    if (cur->left) traversal(cur->left, path + "->", result); // 左
    if (cur->right) traversal(cur->right, path + "->", result); // 右
}
```

如果展开写,代码如下:

```c++
if (cur->left) {
    path += "->";
    traversal(cur->left, path, result); // 左
    path.pop_back(); // 回溯 '>'
    path.pop_back(); // 回溯 '-'
}
if (cur->right) {
    path += "->";
    traversal(cur->right, path, result); // 右
    path.pop_back(); // 回溯 '>' 
    path.pop_back(); //  回溯 '-' 
}
```

**精简版本完整代码:**

```c++
class Solution {
public:
    vector<string> res;
    void traverse(TreeNode* cur, string path) {
        path += to_string(cur->val);
        if (!cur->left && !cur->right) {
            res.push_back(path);
            return;
        }
        if (cur->left) {
            traverse(cur->left, path+"->");
        }
        if (cur->right) {
            traverse(cur->right, path+"->");
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        string path;
        if (root) traverse(root, path);
        return res;
    }
};
```

## 10.左叶子之和

**递归法**

**首先要注意是判断左叶子,不是二叉树左侧节点,所以不要上来想着层序遍历**

> 左叶子明确定义:
> 节点A左孩子不为空,且左孩子的左右孩子都为空(说明是叶子节点),则A节点的左孩子为左叶子节点
> 即有可能一棵二叉树没有左叶子
>
> 判断条件:
> `if (node->left != NULL && node->left->left == NULL && node->left->right == NULL)`

递归函数返回值:左叶子之和

终止条件:到达NULL,到达叶子结点

左边值:左孩子是左叶子,等于左孩子的val
不是,对左孩子递归调用,获取返回值

右边值:对右孩子递归调用,获取返回值

```c++
class Solution {
public:
    int leftLeavesSum(TreeNode* root) {
        if (!root) {
            return 0;
        }
        if (root->left && !root->left->right &&!root->left->left) {
            return root->left->val+leftLeavesSum(root->right);
        } else {
            return leftLeavesSum(root->left)+leftLeavesSum(root->right);
        }  
    }    
    int sumOfLeftLeaves(TreeNode* root) {
        return leftLeavesSum(root);
    }
};
```

**迭代法**

在层序遍历过程中遇到左叶子,统计即可

## 11.找树左下角的值

在树的最后一行找到最左边的值

本题用层序遍历比较简单,用递归法反而比较困难

**递归法**

注意并不是一直往左孩子走就行,因为这样找到的不一定是**最后一层**
最后一行:找要找深度最大的叶子节点,所以需要把depth作为传入递归函数的参数
另外还需要两个全局变量,maxLen用来记录最大深度,result记录最大深度最左节点的数值

当遇到叶子节点的时候,就需要更新最大深度

如何保证找到的是最左边的值:
可以使用前序遍历,保证左边的优先被搜索
这样到最大深度并更新maxlen时,最先到达的就是本层最左边的结点,并被result记录

```c++
class Solution {
public:
    int maxdepth;
    int result;
    void findRes(TreeNode*root, int depth) {
        if(!root) {
            return;
        }
        if(depth > maxdepth){
            maxdepth = depth;
            result = root->val;
        }
        findRes(root->left,depth+1);
        findRes(root->right,depth+1);
    }
    int findBottomLeftValue(TreeNode* root) {
        maxdepth = -1;
        findRes(root,0);
        return result;
    }
};
```

**迭代法**

比递归法简单,只需记录最后一行第一个即可

## 12.路径总和

给定一个二叉树和一个目标和
①判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和
②找出所有这样的路径

**递归**

前中后序都可以,因为中结点没有处理逻辑

递归函数参数需要一个计数器,记录目前路径上各节点的和

> 为了方便,计数器可以初始等于目标和,遍历中不断递减
> 如果最后到叶子节点时==0,则找到路径;不等于0则不满足要求

**递归函数是否需要返回值:**
①如本题①,找到一条路径就行,需要及时返回,则需要返回值(返回值用bool表示是否找到即可)
②如果需要搜索整棵二叉树(寻找所有路径),且不需要处理递归返回值,如本题②,则不需要返回值
③如果需要搜索整棵二叉树,且需要处理返回值(如后面寻找公共祖先的题目),则需要返回值

层内处理逻辑:

若当前是叶子结点,判断计数器是否==0,如是返回true,否则返回false
若当前是非叶子结点,递归调用左孩子和右孩子中有任意一个返回true,则返回true,否则返回false

寻找是否有路径代码:

```c++
class Solution {
public:
    bool hasPath(TreeNode* root, int targetSum) {
        if (!root) {
            return false;
        }
        if (!root->left && !root->right) {
            if (targetSum - root->val == 0) {
                return true;
            }
        }
        return hasPathSum(root->left,targetSum-root->val) || hasPathSum(root->right,targetSum-root->val);
    }
    bool hasPathSum(TreeNode* root, int targetSum) {
        return (hasPath(root,targetSum));
    }
};
```

寻找出所有路径代码:

```c++
class Solution {
public:
    vector<vector<int>> res;
    void findPath(TreeNode* cur, int count, vector<int> path) {
        if (!cur) {
            return;
        }
        path.push_back(cur->val);
        if (!cur->left && !cur->right) {
            if(count-cur->val==0) {
                res.push_back(path);
                return;
            }
        }
        findPath(cur->left, count-cur->val, path);
        findPath(cur->right, count-cur->val, path);
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        findPath(root, targetSum, vector<int>());
        return res;
    }
};
```

**迭代**

①只判断是否

层次遍历使用的queue存储的元素设为一个pair
存储二叉树结点指针和从根节点到该节点的路径和
每次结点出队时判断pair的第二个值(路径和)是否等于目标和

②寻找所有路径

用迭代法比较麻烦,建议使用递归法

## 13.已知遍历序列构造二叉树

### 已知中序后序遍历序列

> 以后序数组的最后一个元素为切割点,先切中序数组,根据中序数组,反过来再切后序数组
> 一层一层切下去,每次后序数组最后一个元素就是节点元素
>
> 由此过程可以得知,使用递归方法

- 第一步:如果数组大小为零的话,说明是空节点了
- 第二步:如果不为空,那么取后序数组最后一个元素作为节点元素
  (如遍历序列长度=1,则该结点为叶子节点,直接返回该节点即可,不用进行后面)
- 第三步:找到后序数组最后一个元素在中序数组的位置,作为切割点
- 第四步:切割中序数组,切成中序左数组和中序右数组
- 第五步:切割后序数组,切成后序左数组和后序右数组
- 第六步:递归处理左区间和右区间

整体框架:

```c++
TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {

    // 第一步
    if (postorder.size() == 0) return NULL;

    // 第二步:后序遍历数组最后一个元素,就是当前的中间节点
    int rootValue = postorder[postorder.size() - 1];
    TreeNode* root = new TreeNode(rootValue);

    // 叶子节点
    if (postorder.size() == 1) return root;

    // 第三步:找切割点
    int delimiterIndex;
    for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
        if (inorder[delimiterIndex] == rootValue) break;
    }

    // 第四步:切割中序数组,得到 中序左数组 和 中序右数组
    // 第五步:切割后序数组,得到 后序左数组 和 后序右数组

    // 第六步
    root->left = traversal(中序左数组, 后序左数组);
    root->right = traversal(中序右数组, 后序右数组);

    return root;
}
```

**难点:如何切割,特别是如何处理边界值**
注意确定切割的标准,是左闭右开,还是左闭右闭(**注意循环不变量要统一!**)

切割中序数组,以左闭右开为标准

```c++
// 找到中序遍历的切割点
int delimiterIndex;
for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
    if (inorder[delimiterIndex] == rootValue) break;
}

// 左闭右开区间:[0, delimiterIndex)
vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
// [delimiterIndex + 1, end)
vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end());
```

切割后序数组(后序数组中最后一个数字不要了)

后序数组没有明确的切割元素来以其为中心进行左右切割
所以切割时使用后序左数组和后序右数组的大小进行切割
后序左数组大小和上面求得的中序左数组大小相同,右数组同理

```c++
// postorder 舍弃末尾元素,因为这个元素就是中间节点,已经用过了
postorder.resize(postorder.size() - 1);

// 左闭右开,注意这里使用了左中序数组大小作为切割点:[0, leftInorder.size)
vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
// [leftInorder.size(), end)
vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());
```

**在代码实现中,可以不创建新的vector,直接只传递中序数组和后序数组的起始和终止下标**

```c++
class Solution {
public:
    TreeNode* process(vector<int>& inorder, vector<int>& postorder,
        int inbegin, int inend, int postbegin, int postend) {
        if (inbegin==inend) {
            return NULL;
        }
        int rootvalue = postorder[postend-1];
        int rootindex = -1;
        for (int i=inbegin; i<inend; i++) {
            if (inorder[i] == rootvalue) {
                rootindex = i;
                break;
            }
        }

        TreeNode* root = new TreeNode(rootvalue);

        int leftinbegin = inbegin;
        int leftinend = rootindex;
        int rightinbegin = rootindex+1;
        int rightinend = inend;

        int leftpostbegin = postbegin;
        int leftpostend = postbegin + (leftinend - leftinbegin);
        int rightpostbegin = leftpostend;
        int rightpostend = postend-1;

        root->left = process(inorder,postorder,leftinbegin,leftinend,leftpostbegin,leftpostend);
        root->right = process(inorder,postorder,rightinbegin,rightinend,rightpostbegin,rightpostend);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return process(inorder,postorder,0,inorder.size(),0,postorder.size());
    }
};
```

### 已知中序先序遍历序列

获取先序遍历数组第一个元素,就是当前的中间节点,用其切割中序数组
之后再根据中序数组的大小再切割先序数组

## 14.最大二叉树

给定一个不含重复元素的整数数组,用其建立最大二叉树

> - 二叉树的根是数组中的最大元素
> - 左子树是通过数组中最大值左边部分构造出的最大二叉树
> - 右子树是通过数组中最大值右边部分构造出的最大二叉树

**前序遍历,先构造中间结点,再左右**

返回值:创建的新节点

终止条件:数组大小等于1,则到叶子结点,不用继续往下递归了
在创建结点后返回结点即可

层内处理逻辑:
①先要找到数组中最大的值和对应的下标,最大的值构造根节点,下标用来下一步分割数组
②若①中找到的下标左边有数字:在最大值所在的下标左区间构造左子树
③若①中找到的下标右边有数字:在最大值所在的下标右区间构造右子树

注:上面②③的判断是为了不让空节点进入下一步的递归调用
可以不进行判断左右区间是否有值,没有值时进入下一层递归调用,调用开始时也会判断返回,更简洁

另外同上一题,不需要创建新的vector传给下一层,代价太大
只需要传递给下一层起始下标值即可

```c++
class Solution {
public:
    TreeNode* construct(vector<int>& nums, int begin, int end) {
        if (end<begin) {
            return NULL;
        }
        int maxindex = -1;
        int max = -1;
        for (int i=begin; i<=end; i++) {
            if (nums[i] > max) {
                max = nums[i];
                maxindex = i;
            }
        }
        TreeNode* root = new TreeNode(nums[maxindex]);
        root->left = construct(nums,begin,maxindex-1);
        root->right = construct(nums,maxindex+1,end);
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return construct(nums, 0, nums.size()-1); 
    }
};
```

## 15.合并二叉树

两个二叉树重叠覆盖在一起
(某个位置若原来两棵树都有值,则相加)

如何同时遍历两个二叉树:
和遍历一个树逻辑是一样的,只不过传入两个树的节点,同时操作

**递归法**

用前中后哪种遍历顺序都可以

不创建新节点,在原地进行操作

**参数和返回值:**
传入2个结点,返回合并后结点

中止条件:(包括二者中其中一个为NULL和都为NULL)
```c++
if (t1 == NULL) return t2; // 如果t1为空,合并之后就应该是t2
if (t2 == NULL) return t1; // 如果t2为空,合并之后就应该是t1
```

单层递归的逻辑(使用先序遍历,先处理本中间结点)

```c++
t1->val += t2->val;                             // 中
t1->left = mergeTrees(t1->left, t2->left);      // 左
t1->right = mergeTrees(t1->right, t2->right);   // 右
return t1;
```

**迭代法**

迭代法同时遍历两棵树:
**把两个树的节点同时加入队列进行比较**

不创建新节点,在原地进行操作

> **和判断对称二叉树不同,空结点不加入队列,需要在加入前就进行处理**
> (一个把赋值左右孩子指针赋值给另一个 or 不用管)

因为最后返回的是root1
所以如果t1->left/right为空,t2->left/right不为空,则把t2指针的给t1赋值过去
如果t1->left/right不为空,t2->left/right为空,则不用管

```c++
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
    if (t1 == NULL) return t2;
    if (t2 == NULL) return t1;
    queue<TreeNode*> que;
    que.push(t1);
    que.push(t2);
    while(!que.empty()) {
        TreeNode* node1 = que.front(); que.pop();
        TreeNode* node2 = que.front(); que.pop();
        // 此时两个节点一定不为空,val相加
        node1->val += node2->val;

        // 如果两棵树左节点都不为空,加入队列
        if (node1->left != NULL && node2->left != NULL) {
            que.push(node1->left);
            que.push(node2->left);
        }
        // 如果两棵树右节点都不为空,加入队列
        if (node1->right != NULL && node2->right != NULL) {
            que.push(node1->right);
            que.push(node2->right);
        }

        // 当t1的左节点为空,t2左节点不为空
        // NULL没必要加入队列,因为现在就可以直接赋值过去
        if (node1->left == NULL && node2->left != NULL) {
            node1->left = node2->left;
        }
        // 当t1的右节点为空,t2右节点不为空
        // NULL没必要加入队列,因为现在就可以直接赋值过去
        if (node1->right == NULL && node2->right != NULL) {
            node1->right = node2->right;
        }
    }
    return t1;
}
```

## 16.二叉搜索树

### BST搜索

递归法:

终止条件:到达NULL或找到目标值,返回当前结点

迭代法:

**由于BST结点的有序性,所以在搜索中可以不需要辅助队列/栈**
根据大于/小于关系决定往左/右走即可

> **如果已经知道是BST,则因其有序性,迭代法搜索节点时不需要辅助栈/队列**
> (对于之后的其他已知是BST的题目也适用)

### BST验证

**递归法**

**在中序遍历下,遍历BST所得序列有序**

注意搜索树中不能有相同元素

①所以只需中序遍历,然后判断所得序列是否有序

②**在中序遍历递归过程中直接进行判断**

注意:1.不能只单纯比较该节点的左节点小于此中间节点,右节点大于此中间节点
中间结点要大于左边所有结点,小于右边所有结点

所以需要设立一个变量,表示当前结点左边所有结点中的最大值

2.最小结点val可能是int最小值

所以最大值初始化为:`long long maxVal = LONG_MIN`

递归终止条件:`if (root == NULL) return true;`

> 注意:不要错误地写成return false,导致总是输出false

**单层内递归逻辑:**

进行中序遍历
①递归调用左边(在递归左边过程中更新了maxVal),返回bool left
②比较当前结点(中间结点)是否>maxVal,如否,则不是BST,直接return false
如果是,则更新maxVal为当前结点val
③递归调用右边,返回bool right
④`return left && right; `

补充:如果测试数据中最小的是long long最小值,则不能把naxVal 初始化为 LONG_MIN
**应该用一个变量记录上一个结点,每次用中间结点和上一个结点比较,然后把该变量设为本中间结点**

> 注意:pre应该是TreeNode*类型,如其是NULL,则表示中序遍历序列中第一个
> 不应该是int类型(记录上一个结点的val),因为还需要在设一个标志去表示是否为序遍历序列中第一个

```c++
TreeNode* pre = nullptr;
bool isValidBST(TreeNode* root) {
    if (!root) return true;
    bool left = isValidBST(root->left);
    if (pre && root->val <= pre->val) {
        return false;
    }
    pre = root;
    bool right = isValidBST(root->right);
    return left && right;
}
```

**迭代法**

修改之前使用栈实现中序遍历的代码
在遍历元素出队处加入比较和记录前一个结点的代码即可

```c++
bool isValidBST(TreeNode* root) {
    stack<TreeNode*> st;
    TreeNode* pre = nullptr;
    TreeNode* cur = root;
    while (cur != nullptr || !st.empty()) {
        if (cur) {
            st.push(cur);
            cur = cur->left;
        } else {
            cur = st.top();
            st.pop();
            if (pre != nullptr && cur->val <= pre->val) {
                return false;
            }
            pre = cur;
            cur = cur->right;
        }
    }
    return true;
}
```

### BST最小绝对差

计算树中任意两节点的差的绝对值的最小值

方法一:
先中序遍历BST,然后用得到的遍历序列数组找

方法二:
在遍历的过程中就进行寻找(递归/迭代均可)

类似于上一题,需要**用一个pre变量记录一下cur节点的前一个节点**
每次和前一个计算差的绝对值即可

> 题目说了是BST,就要利用BST有序的特点
> 由于有序,就可以记录前一个结点,并只和前一个结点比较

### BST中的众数

**如果不是二叉搜索树**

遍历整棵树,用map统计频率

由于map无法根据value排序,所以要把map转化成vector再排序

```c++
bool static cmp (const pair<int, int>& a, const pair<int, int>& b) {
    return a.second > b.second; // 按照频率从大到小排序
}

vector<pair<int, int>> vec(map.begin(), map.end());
sort(vec.begin(), vec.end(), cmp); // 给频率排个序
```

**考虑二叉搜索树的特性**

**BST中序遍历有序,如有相同值则一定相邻,因此又可以利用上面记录前一个结点的方法**

该中间结点与前一个结点比较,如果相同,count++,否则count重置为1

注意:可能存在众数不唯一的情况,因此用一个vector记录结果
如果新获取到的众数的频率==原来记录的众数的频率,则把该新结果加入vector
如果新获取到的众数频率>原来记录的众数的频率,则先清空vector,再把该新结果加入vector

**迭代法:**

```c++
vector<int> findMode(TreeNode* root) {
    vector<int> res;
    int count = 0;
    int maxcount = 0;
    stack<TreeNode*> st;
    TreeNode* pre = NULL;
    TreeNode* cur = root;
    while (cur || !st.empty()) {
        if (cur) {
            st.push(cur);
            cur = cur->left;
        } else {
            cur = st.top();
            st.pop();
			
            // 第一个/和上一个不同:重置count;和上一个相同:count++
            if (!pre) {
                count = 1;
            } else if (pre->val == cur->val) {
                count++;
            } else {
                count = 1;
            }
			
            // 当count>=maxcount,记录众数
            // 当count>maxcount说明过去记录的不是众数,需要清空结果并更新maxcount
            if (count >= maxcount) {
                if (count>maxcount) {
                    maxcount = count;
                    res.clear();
                }
                res.push_back(cur->val);
            }

            pre = cur;
            cur = cur->right;
        }
    }
    return res;
}
```

## 17.二叉树最近公共祖先

(注意规定一个结点也可以是自己的祖先)

从下往上回溯->后序遍历,先处理子结点,再处理自身

如找到⼀个节点,发现左子树出现结点p,右子树出现节点q,或者 左子树出现结点q,右子树出现节点p
那么该节点就是节点p和q的最近公共祖先

终止条件:遇到p或遇到q或遇到NULL,返回自身

单层处理逻辑:
①递归调用左右子树
②若返回的结果都不为空,则该节点为最近公共祖先,return 该节点
若返回的结点左不为空,右空,则最近各个祖先在该节点的下面或上面(反正不是该结点),return 不为空的左结点
若返回的结点左为空,右不为空,同理,return 不为空的右节点
若返回的结点都为空,则返回NULL

> 注意:**`p`或`q`自身为最近公共祖先的情况**,例如,首先遇到`p`,`q`在`p`的下面,最终的最近公共祖先就是`p`
> 因为已知p和q以及他们的公共祖先在树中一定存在,所以若在遇到`p`时还没遇到`q`,则有两种情况:
> ①`q`在`p`的下面,最终的最近公共祖先就是`p`
> ②`q`在二叉树的另一条路径上,它们的公共祖先在上面
> 无论是哪一种情况,都直接返回`p`即可
>
> > **终止条件:遇到p或遇到q或遇到NULL,返回自身**
> > (终止条件已经覆盖了 包括 "`p`自身为最近公共祖先" 在内 的①②两种情况)

**注意:此方法总是需要遍历搜索整棵树** 
(而不是找到结果后剩下的就不继续遍历了,对比:下一题)
因为搜索过程中无法判断是否找到,只能把本结点的结果传递给上层
<img src=".\images\21.JPG" alt="21" style="zoom: 60%;" />

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || root==p || root==q) {
        return root;
    }
    TreeNode* left = lowestCommonAncestor(root->left,p,q);
    TreeNode* right = lowestCommonAncestor(root->right,p,q);
    if (left && right) {
        return root;
    } else if (left) {
        return left;
    }
    return right;
}
```

## 18.二叉搜索树最近公共祖先

> **相比于普通二叉树,本题要利用好BST有序的特点**

**递归法**

在有序树里,判断一个结点的左子树有p,右子树有q:
如果 中间节点是 q 和 p 的公共祖先, 那么 中节点的数组一定是在 [p, q]区间的
这样判断了是二者的公共祖先

不仅如此,在从上到下找到的第一个满足在 [p, q]区间的结点,一定是p和q的**最近**公共祖先
它上面一个结点是公共祖先,但不在该区间内
它下面一个结点不是公共祖先,会错过这个区间,
所以最近公共祖先只能是该节点(满足在该区间内的结点)
<img src=".\images\20.JPG" alt="20" style="zoom:50%;" />

返回值:找到的结点

递归终止条件:
因为题目规定一定能找到公共祖先,所以不需要

单层递归逻辑:
如果`cur->val > p->val && cur->val > q->val`
说明区间在左边,对左子树递归调用
小于同理,说明在右边

除了这两种情况外,就剩下本节点val在[p,q]区间里的情况,直接返回本节点即可

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root==NULL) return NULL;
        if ((p->val<=root->val&&root->val<=q->val)||(q->val<=root->val&&root->val<=p->val)) return root;
        if (p->val < root->val && q->val < root->val) {
            TreeNode* left = lowestCommonAncestor(root->left,p,q);
            if (left) return left;
        }
        TreeNode* right = lowestCommonAncestor(root->right,p,q);
        return right;
    }
```

**注意本题只要在左边找到就直接返回,不用搜索右边,即不用搜索整棵树**

>搜索一条边的写法:
>(若左边找到就直接返回,不用看右边了)
>
>```c++
>if (递归函数(root->left)) return ;
>if (递归函数(root->right)) return ;
>```
>
>搜索整棵树的写法:
>(上一题普通二叉树寻找最近公共祖先)
>
>```c++
>left = 递归函数(root->left);
>right = 递归函数(root->right);
>left与right的逻辑处理;
>```
>

**迭代法**

方法相同,但更加简洁,因为不用层层往上返回结果
**(在树中搜索节点时不需要栈/队列,因为是BST,节点有序)**

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    while(root) {
        if (root->val > p->val && root->val > q->val) {
            root = root->left;
        } else if (root->val < p->val && root->val < q->val) {
            root = root->right;
        } else return root;
    }
    return NULL;
}
```

## 19.BST操作

### BST插入

不是平衡树,插入时不用调整结构,直接插入即可

①使用返回值

终止条件:走到NULL
创建新节点并返回即可
(上一层递归调用时用left/right指针接住递归调用返回值)

②不使用返回值:

使用一个指针记录上一次访问的结点(即父结点)
走到NULL时:创建新节点,并将其设为上一次访问结点(父结点)的left/right

```c++
TreeNode* node = new TreeNode(val);
if (val > parent->val) parent->right = node;
else parent->left = node;
return;
```

迭代法:

在搜索过程中使用pre记录上一个结点,用以插入

### BST删除

BST删除需要涉及到结构调整

终止条件:走到NULL,没找到要删除的结点,直接返回

找到要删除的结点:
①是叶子结点,直接返回NULL
②只有左/右孩子,直接返回左/右孩子
③左右孩子都不为空:
①将要删除节点的**左子树头结点(左孩子)**放到其右子树的最左边节点的左孩子上
**②返回要删除节点的右孩子**

```c++
TreeNode* cur = root->right; // 找右子树最左面的节点
while(cur->left != nullptr) {
    cur = cur->left;
}
cur->left = root->left; // 把要删除的节点的左子树放在cur的左孩子的位置
TreeNode* tmp = root;   // 把root节点保存一下,下面来删除
root = root->right;     // 返回旧root的右孩子作为新root
delete tmp;             // 释放节点内存
return root;
```

当前还未找到要删除的结点:

用当前结点的left/right接住递归调用的返回值

```c++
if (root->val > key) root->left = deleteNode(root->left, key);
if (root->val < key) root->right = deleteNode(root->right, key);
return root;
```

迭代法:

同样在搜索过程中使用pre记录上一个结点
找到后把左子树移动到右子树最左下后,然后把右孩子赋值给pre的left/right

### BST修剪

给定最小边界L 和最大边界 R, 通过修剪二叉搜索树, 使得所有节点的值在[L, R]中 (R>=L)

**递归法**

> 错误想法:递归处理,遇到 root->val < low || root->val > high 的时候直接return NULL
> 错误原因:[1, 3]区间在二叉搜索树的中还要考虑节点0的右子树,不能直接把节点0剪掉

当发现我们发现节点0并不符合区间要求时,把0的右孩子(2)直接赋给3的左孩子
(即把节点0从二叉树中移除)
<img src="./images/22.jpg" alt="22" style="zoom: 60%;" />

终止条件:返回NULL

对于不在区间范围内的节点:直接返回其左/右孩子的递归调用结果

> 不符合要求的当前节点自身以及其左或右孩子被从二叉树中直接跳过(移除)了
> **对于小于区间的结点,其自身和其左孩子被移除,返回其右孩子**
> **对于大于区间的结点,其自身和其右孩子被移除,返回其左孩子**

```c++
if (root->val < low) {
    TreeNode* right = trimBST(root->right, low, high);
    return right;
}
if (root->val > high) {
    TreeNode* left = trimBST(root->left, low, high);
    return left;
}
```

对于在区间范围内的节点:
对其左右孩子进行递归调用,并用自己的left和right指针接住返回结果

```c++
root->left = trimBST(root->left, low, high); // root->left=符合条件的左孩子
root->right = trimBST(root->right, low, high); // root->right=符合条件的右孩子
return root;
```

**迭代法**

(在树中搜索节点时不需要栈/队列,因为是BST,节点有序)

- 将root移动到[L, R] 范围内,注意是左闭右闭区间

- 剪枝左子树

  > root初始为[L, R]区间中最上面的结点
  > 1.cur==root,检查root->left是否在区间中,如果root->left小于区间:
  > 则为root->left(cur->left)位置寻找符合条件的节点
  >
  > 2.之后cur往左边移动一次,即cur==root->left
  > 检查root->left->leftt(cur->left)是否在区间中,如果root->left->left小于区间:
  > 则为root->left->left(cur->left)位置寻找符合条件的节点
  > ....
  >
  > 以此类推,直到cur移动cur->left==NULL为止
  > (因BST有序性,只需检查cur->left,若存在节点且不符合条件,为该位置寻找符合条件的节点)

- 剪枝右子树

```c++
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if (!root) return nullptr;

        // 处理头结点，让root移动到[L, R] 范围内,注意是左闭右闭
        while (root != nullptr && (root->val < L || root->val > R)) {
            if (root->val < L) root = root->right; // 小于L往右走
            else root = root->left; // 大于R往左走
        }
        TreeNode *cur = root;
        // 此时root已经在[L, R] 范围内,处理左孩子元素小于L的情况       
        while (cur != nullptr) {
            while (cur->left && cur->left->val < L) {
                cur->left = cur->left->right;
            } // 若没有找到符合条件的,cur->left会是NULL
            cur = cur->left;
        }
        cur = root;

        // 此时root已经在[L, R] 范围内,处理右孩子大于R的情况
        while (cur != nullptr) {
            while (cur->right && cur->right->val > R) {
                cur->right = cur->right->left;
            }
            cur = cur->right;
        }
        return root;
    }
};
```

## 20.有序数组建立BST

将一个按照升序排列的有序数组,转换为一棵高度平衡二叉搜索树(高度差<=1)

**递归法:**

给的是有序数组,**要平衡:只需每次取数组中间的元素作为分割点**
之后递归左边和右边的部分

> 长度为偶数,取哪一个都可以
> 递归过程中要检查区间定义的循环不变量,如左闭右闭

终止条件:left>right(左闭右闭)

**迭代法:**

使用三个queue
一个用来存储node
另外两个分别用来存储处理区间的左边界下标和右边界下标

```c++
while (存储node的queue不空) {
    // 计算本轮区间的mid,用本次的根节点存储
    
	从node的queue中取出node(为本次的根节点,对应本次区间最中间的元素);
	从另外两个队列中取出本次区间的左边界和右边界下标;
    int mid = (left+right) / 2;
    本次根节点->val = nums[mid];
    
    // 处理本轮根节点的左右孩子
    if (left <= mid - 1) {
		// 即mid左边至少还有一个元素,左边需要之后继续处理,入队
        创建新节点(作为本轮根节点的左孩子,也是mid左边区间的根节点);
        本轮的根节点->left = 刚创建的新节点;
        创建的新节点入队;
        mid左边区间的左边界left和右边界mid-1分别入队;
        // 注意左边界是left,不是0!
    }
    
    if (right >= mid + 1) {
        // 与上面同理...
    }
}
```

代码:

```c++
TreeNode* sortedArrayToBST(vector<int>& nums) {
        queue<TreeNode*> node_queue;
        queue<int> left_queue;
        queue<int> right_queue;
        TreeNode* root = NULL;
        if(!nums.empty()){
            root = new TreeNode(0);
            node_queue.push(root);
            left_queue.push(0);
            right_queue.push(nums.size()-1);
        }
        while (!node_queue.empty()) {
            int left_index = left_queue.front(); left_queue.pop();
            int right_index = right_queue.front(); right_queue.pop();
            int mid = (left_index+right_index)/2;
            TreeNode* cur = node_queue.front(); node_queue.pop();
            cur->val = nums[mid];

            if(left_index+1<=mid){
                TreeNode* left = new TreeNode(0);
                cur->left = left;
                node_queue.push(left);
                left_queue.push(left_index);
                right_queue.push(mid-1);
            }

            if(right_index-1>=mid){
                TreeNode* right = new TreeNode(0);
                cur->right = right;
                node_queue.push(right);
                left_queue.push(mid+1);
                right_queue.push(right_index);
            }
        }
        return root;
    }
```

## 21.BST转为累加树

将BST转换为累加树Greater Sum Tree,使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和

**BST有序**,若其写成从小到大的递增数组,给其中每个数求数组中大于等于该数的值之和:
**对该递增数组从后到前进行累加即可,BST中也是同理**

对BST逆中序遍历(右中左),然后顺序累加即可

```c++
int pre = 0; // 记录前一个节点的数值
void traversal(TreeNode* cur) { // 右中左遍历
    if (cur == NULL) return;
    traversal(cur->right);
    cur->val += pre;
    pre = cur->val;
    traversal(cur->left);
}
```

迭代法:

修改之前迭代法中序遍历代码即可
