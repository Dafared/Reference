### 1.无重复字符最长子串

滑动窗口

窗口右边不和窗口中的重复,窗口向右扩大,加入set
窗口右边和窗口中的重复,从左边缩小窗口
直到窗口中和窗口右边相同的那个元素离开窗口

### 2.不同的二叉搜索树II

(1) 递归法暴力搜索

传入参数:**子树的树节点范围(int left, int right)**
需要返回满足树节点在[left,right]内的子树的所有情况
分别让该范围内的每个数充当二叉搜索树的根节点,获取以该节点为根节点的树的所有情况
对范围[left,right]内每个值都重复同样的过程(分别获取各自为根节点的所有情况)
并都将结果都保存进vector中,向上层返回

递归终止条件:left>right,返回的vector中只有nullptr(`return {nullptr}`)

若以某个值为二叉搜索树的根节点的值时:
已经通过递归获得了:
①其所有可能的左子树的根节点集合
②其所有可能的右子树的根节点集合
用嵌套循环遍历①和②:获得以该节点为根节点的二叉搜索树的所有情况:
对每种情况的左子树和右子树,都新建一个根节点:
用循环遍历得到的左子树和右子树作为该根节点的左孩子右孩子
然后把这个根节点保存进vector中

对范围[left,right]内每个根节点都重复同样的过程

对于二叉搜索树来说,若以编号x为根节点
其左边的子树必然是编号[left,x-1]的所有节点组成
其右边的子树必然是编号[x+1,right]的所有节点组成
向左边递归调用范围[left,x-1]
向右边递归调用范围[x+1,right]

(2) 记忆化搜索
空间换时间
使用一个数组去保存树节点在[left,right]区间内的子树的所有情况
(`vector<vector<vector<TreeNode>>> memory;`)
若再次需要用到[left,right]区间的结果,发现之前保存过,可直接用保存过的结果返回
(刚开始需要用`memory.resize(n+1,vector<vector<TreeNode>>(n+1));`初始化空间)

```c++
class Solution {
    vector<vector<vector<TreeNode*>>> mem;
public:
    vector<TreeNode*> findres(int left, int right) {
        vector<TreeNode*> res;
        if (right < left) {
            return {nullptr};
        }
        if (!mem[left][right].empty()) {
            return mem[left][right];
        }
        for (int i=left;i<=right; i++) {      
            vector<TreeNode*> left_sons = findres(left,i-1);
            vector<TreeNode*> right_sons = findres(i+1,right);
            for (auto l : left_sons) {
                for (auto r : right_sons) {
                    TreeNode* new_root = new TreeNode(i);
                    new_root->left = l;
                    new_root->right = r;
                    res.push_back(new_root);
                }
            }
        }
        mem[left][right] = res;
        return res;
    }
    vector<TreeNode*> generateTrees(int n) {
        mem.resize(n+1,vector<vector<TreeNode*>>(n+1));
        return findres(1,n);
    }
};
```

### 3.最长连续序列(leetcode 128)

要求O(N)复杂度
所以不能先排序,排序已经是O(nlogn)
使用哈希表:
①将数组中所有数字加入哈希表O(n)
②遍历数组,当发现nums[i]-1不在哈希表中时:
则nums[i]**可能是**若干个连续数字的开始
从nums[i]开始,依次通过哈希表判断nums[i]+1,nums[i]+2,....是否在数组中存在
统计从nums[i]开始的最长连续序列
重复以上①②,最后返回以上过程中出现过的最长连续序列
(因当nums[i]-1不存在时才进入内层循环,所以时间复杂度仍是O(n))

### 4.0和1个数相同的最长子数组(leetcode 525)

**前缀和+哈希表**

计算前缀和的作用:便于快速计算子数组的元素和
若前缀和数组为prefix,则下标从j+1到k的子数组的元素和为prefix[k]-prefix[j]

可以将0视为-1,则-1和1个数相同的子数组就是元素和=0的子数组
即对于下标从j+1到k的子数组满足prefix[k]-prefix[j]=0,即prefix[k]=prefix[i]

实际上得到元素和=0的不需要prefix数组,只需要一个哈希表
因求的是最长长度,哈希表中存储某个前缀和**第一次出现的下标**
若之后发现该前缀和之前出现过,则当前的下标和第一次出现的下标之间的子数组和为0

```c++
int findMaxLength(vector<int>& nums) {
    vector<long long> pre_sum(nums.size()+1, 0);
    unordered_map<long long, int> m;
    int max_len = 0;
    m[0] = 0;
    for (int i = 1; i <= nums.size(); i++) {
        if (nums[i - 1] == 1) {
            pre_sum[i] = pre_sum[i - 1] + 1;
        } else {
            pre_sum[i] = pre_sum[i - 1] - 1;
        }
        if (m.find(pre_sum[i]) != m.end()) {
            max_len = max(max_len, i - m[pre_sum[i]]);
        }
        if (m.find(pre_sum[i]) == m.end()) {
            m[pre_sum[i]] = i;
        }
    }
    return max_len;
}
```

### 5.重复的DNA序列 (leetcode 187)

**滑动窗口+哈希表**

从左到右使用滑动窗口得到每个长度为10的子串
用哈希表记录每个以子串的出现次数

每次检查以 s[i] 为结尾的子串, 需要构造出新的且长度为 10 的字符串
令 C=10, 复杂度为 `O(n *  C)`

**字符串哈希**

字符串哈希:快速检查两个子串是否相同

字符串哈希计算公式为:
`hash[i] = hash[i-1] *Base + idx(s[i]);`
(类似十进制的表示,14,一开始是 0,然后 0 * 10 + 1 = 1,接着 1*10 + 4 = 14)

使用`P[i]`数组表示`Base^i`,即底的i次方

计算子串s[i,...,j]的哈希值:**使用前缀和思想**
`h[j]-h[i-1]*p[j-i+1]`

推导过程:
<img src=".\images\26.JPG" alt="26" style="zoom:80%;" />

使用该方法的**时间复杂度为(O(n))**
①计算h数组和p数组的时间复杂度为O(n)
②计算子串的哈希值时,可以使用前缀和思想,在O(1)时间内得到哈希值

另外,如果希望做到O(n)
最后用作计数的哈希表map不能用string作为key,只能使用int

①计算哈希数组h和次方数组p
②遍历数组,计算每个长度为10的子串的哈希值
③检查子串哈希值是否存在过,如存在过且本次是出现的第二次,则将对应区间子串加入答案
然后把map中的计数++

```c++
#define BASE 131
vector<string> findRepeatedDnaSequences(string s) {
    unordered_map<uint64_t,int> count_map;
    vector<string> res;
    vector<uint64_t> h(s.size()+1,0);
    vector<uint64_t> p(s.size()+1,0);
    p[0] = 1;
    for (int i=0; i<s.size(); i++) {
        p[i+1] = p[i] * BASE;
        h[i+1] = h[i] * BASE + s[i];
    }
    for (int i=10; i<=s.size(); i++) {
        uint64_t hash = h[i] - h[i-10] * p[10];
        if (count_map.find(hash) != count_map.end()) {
            if (count_map[hash] == 1) {
                res.push_back(s.substr(i-10,10));
            }
        }
        count_map[hash] ++;
    }
    return res;
}
```

### 6.最长重复子串(leetcode 1044)

**字符串哈希+二分查找最大长度**

p通常默认设为1313131/131

①计算哈希数组h和次方数组p

②编写check函数,检查某个长度 len 作为最大长度, 是否存在合法方案
(寻找是否有长度为len的符合要求的重复子串)

③使用二分查找,寻找可能的最大长度

```c++
#define BASE 131
class Solution {
public:
    string check(vector<uint64_t> &p, vector<uint64_t> &h, int len, string &s) {
        unordered_set<uint64_t> count_set;
        for (int i=len; i<=s.size(); i++) {
            uint64_t hash = h[i] - h[i-len] * p[len];
            if (count_set.find(hash) != count_set.end()) {
                return s.substr(i-len,len);
            }
            count_set.insert(hash);
        }
        return "";
    }
    string longestDupSubstring(string s) {
        vector<uint64_t> p(s.size()+1,0);
        vector<uint64_t> h(s.size()+1,0);
        p[0] = 1;
        for (int i=1; i<=s.size(); i++) {
            p[i] = p[i-1] * BASE;
            h[i] = h[i-1] * BASE + s[i-1];
        }
        int right = s.size();
        int left = 0;
        string res_str = "";
        while (left <= right) {
            int mid = (left+right) >> 1;
            string tmp = check(p,h,mid,s);
            res_str = res_str.size() < tmp.size() ? tmp : res_str;
            if (!tmp.empty()) {
                left = mid+1;
            } else {
                right = mid-1;
            }
        }
        return res_str;
    }
};
```

### 7.二进制求和(leetcode 67)

整体思路是将两个字符串较短的用 0 补齐, 使得两个字符串长度一致, 然后从末尾进行遍历计算

```c++
class Solution {
public:
	string addBinary(string a, string b) 
	{
		int asize = a.size(), bsize = b.size();
		while (asize > bsize)//补齐
		{
			b = '0' + b;
			bsize++;
		}
		while (asize < bsize)
		{
			a = '0' + a;
			asize++;
		}
		int carry = 0;  //进位
        // 注意输入的字符串是大端顺序,数字的低位在字符串的高位
		for (int i = asize - 1; i >= 0; i--)
		{
			int sum = a[i] - '0' + b[i] - '0' + carry;
			a[i] = (sum) % 2+'0';//本位数值
			carry = sum / 2;//进位更新
		}
		if (carry > 0)//有溢出
			a = '1' + a;
		return a;
	}
};
```

### 8.二叉树的直径(leetcode 543)

分别对左孩子和右孩子递归,计算最大深度max(L,R)+1

将左右两个孩子的结果相加+1为以当前接待你为中心的直径
计算L+R+1,用一个全局变量保存递归过程中最大的直径

### 9.字符串转换整数(atoi) (leetcode 8)

我们可以使用自动机这个概念

```c++
#include <ctype.h>
class Automaton {
    string state = "start";
    unordered_map<string, vector<string>> table = {
        {"start", {"start", "signed", "in_number", "end"}},
        {"signed", {"end", "end", "in_number", "end"}},
        {"in_number", {"end", "end", "in_number", "end"}},
        {"end", {"end", "end", "end", "end"}}
    };

    int get_col(char c) {
        if (isspace(c)) return 0;
        if (c == '+' or c == '-') return 1;
        if (isdigit(c)) return 2;
        return 3;
    }
public:
    int sign = 1;
    long long ans = 0;

    void get(char c) {
        state = table[state][get_col(c)];
        if (state == "in_number") {
            ans = ans * 10 + c - '0';
            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);
        }
        else if (state == "signed")
            sign = c == '+' ? 1 : -1;
    }
};

class Solution {
public:
    int myAtoi(string str) {
        Automaton automaton;
        for (char c : str)
            automaton.get(c);
        return automaton.sign * automaton.ans;
    }
};
```

### 10.循环队列

**1.数组**

规定循环队列最多只能有capacity-1个元素
当循环队列中只剩下一个空存储单元时,则表示队列已满

判空条件是 rear == front

判满条件是`((rear + 1) % capacity) == front`

front=(rear+1) mod capacity

计算长度:(rear−front+capacity) mod capacity

```c++
class MyCircularQueue {
private:
    int front;
    int rear;
    int capacity;
    vector<int> elements;

public:
    MyCircularQueue(int k) {
        this->capacity = k + 1;
        this->elements = vector<int>(capacity);
        rear = front = 0;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        elements[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return elements[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return elements[(rear - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return rear == front;
    }

    bool isFull() {
        return ((rear + 1) % capacity) == front;
    }
};
```

**2.链表**

保存链表的头和尾即可

### 11.双端循环队列

**1.数组**

```c++
class MyCircularDeque {
private:
    vector<int> elements;
    int rear, front;
    int capacity;

public:
    MyCircularDeque(int k) {
        capacity = k + 1;
        rear = front = 0;
        elements = vector<int>(k + 1);
    }

    bool insertFront(int value) {
        if (isFull()) {
            return false;
        }
        front = (front - 1 + capacity) % capacity;
        elements[front] = value;
        return true;
    }

    bool insertLast(int value) {
        if (isFull()) {
            return false;
        }
        elements[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    bool deleteFront() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        return true;
    }

    bool deleteLast() {
        if (isEmpty()) {
            return false;
        }
        rear = (rear - 1 + capacity) % capacity;
        return true;
    }

    int getFront() {
        if (isEmpty()) {
            return -1;
        }
        return elements[front];
    }

    int getRear() {
        if (isEmpty()) {
            return -1;
        }
        return elements[(rear - 1 + capacity) % capacity];
    }   

    bool isEmpty() {
        return rear == front;
    }

    bool isFull() {
        return (rear + 1) % capacity == front;
    }
};
```

**2.链表**

使用双向链表来模拟双端队列

### 12.最短回文串 (leetcode 214)

**1.暴力**

①寻找从开头开始的最长回文串

②把剩余内容反转,加到前面去

**2.KMP**

考虑暴力方法:如果只想把字符串变成回文串,只需把整个串反转,加到前面去
但这样生成的回文串不一定是最短的:
因为反转后的末尾若干字符可能和原字符串头部若干字符相同,导致重复

所以只需求出反转后字符串末尾后缀和原字符串头部前缀相同的最大长度
即求最长相等前后缀长度,即可使用kmp算法求next数组得到
(注意求的是整个字符串的最长相等前后缀长度,所以next数组长度是字符串长度+1)

设原字符串为s,反转后字符串为rev_s,构造字符串s+"#"+rev_s
用next求这个新字符串的最长相等前后缀长度
然后从rev_s后面去掉这个长度的后缀,把rev_s前面剩余部分加到原字符串前面即可

```c++
class Solution {
public:
    vector<int> getNext(string &s) {
        vector<int> next(s.size()+1,0);
        next[0] = -1;
        int j = -1;
        int i = 0;
        while (i <s.size()) {
            if (j == -1 || s[i] == s[j]) {
                next[i+1] = j+1;
                i++;
                j++;
            } else {
                j = next[j];
            }
        }
        return next;
    }
    string shortestPalindrome(string s) {
        string ori = s;
        string rev_s = s;
        reverse(rev_s.begin(),rev_s.end());
        s = s + "#" + rev_s;
        vector<int> next = getNext(s);
        int len = next[next.size()-1];
        string add = rev_s.substr(0,rev_s.size()-len);
        return add + ori;
    }
};
```

### 13.最小生成树

**(1)Prim算法**

①选取minDist数组中当前距离最小生成树最近的结点(第一次随便选一个)
②将其加入最小生成树
③对所有当前不在树中的结点更新minDist数组
(`minDist[j] = min(minDist[j],grid[j][cur])`)

**(2)克鲁斯卡尔算法**

(1)先对边排序
(2)建立一个并查集
③遍历每个边,检查其两个端点是否在并查集中
若不在,则加入并查集,并把该条边加入最小生成树

### 14.二维数组寻找目标值 (LCR-121)

每一行都按照从左到右递增的顺序排序
每一列都按照从上到下递增的顺序排序
判断数组中是否含有某整数

若把该二维数组以右上角为轴逆时针旋转45度
则可以看成以右上角元素为根节点的二叉搜索树
模仿二叉搜索树的搜索过程

```c++
bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
    int i = matrix.size() - 1, j = 0;

    while(i >= 0 && j < matrix[0].size()) {
        if(matrix[i][j] > target) i--;
        else if(matrix[i][j] < target) j++;
        else return true;
    }
    return false;
}
```

### 15.H指数

至少发表了 h 篇论文, 并且 至少 有 h 篇论文被引用次数大于等于 h

1.先降序排序

```c++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        sort(citations.rbegin(),citations.rend());
        int h_max = 0;
        for (int i=1; i<=citations.size(); i++) {
            if (citations[i-1] >= i) {
                h_max = i;
            }
        }
        return h_max;
    }
};
```

2.计数排序

设数组共有n篇论文

先用一个计数数组统计每个引用数对应的论文有多少篇
大于n的按n篇统计

然后从高引用数开始遍历计数数组
如果遇到计数值>=引用数,则返回当前引用数位最大的h指数

```c++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        vector<int> count(n+1,0);
        for (int c : citations) {
            if (c > n) {
                count[n]++;
            } else {
                count[c]++;
            }
        }
        int paper_count = 0;
        for (int i=n; i>=0; i--) {
            paper_count += count[i];
            if (paper_count >= i) {
                return i;
            }
        }
        return 0;
    }
};
```

### 16.最大公约数

对于两个非负整数a,b,a>b

`gcd(a,b) = gcd(b,a%b);`

```c++
int gcd(int big, int small) {
    while (small > 0) {
        int tmp = small;
        small = big%small;
        big = tmp;
    }
    return big;
}
```

### 17.矩阵中最长递增路径

不需要遍历所有格子进行DP

而是每次在 matrix 里遇到一个还没有 store 值 的格子,就从它开始往底下DFS即可

### 18.尽可能使字符串相等

## 答案二分

### 分割数组的最大值

将这个数组分成 k 个非空的连续子数组
设计一个算法使得这 `k` 个子数组各自和的最大值最小

### 爱吃香蕉的珂珂

### H指数Ⅱ

### D 天内送达包裹

### 小张刷题计划

注意check函数的写法:

```c++
class Solution {
public:
    int solveProblems(vector<int>& time, int T) {
        int days = 1;
        int cur_sum = 0;
        int cur_max = 0;
        // cur_sum为不包括当前范围内的最大值
        // 所以每一天新开始时,第一个元素加入后,cur_sum=0,cur_max=time[i]
        for (int i=0; i < time.size(); i++) {
            int next; 
            next = min(cur_max,time[i]);   
            if (next + cur_sum <= T) {
                cur_sum += next;
                cur_max = max(cur_max,time[i]);
            } else {
                days++;
                cur_max = time[i];
                cur_sum = 0;
            }
        }
        return days;
    }
    int minTime(vector<int>& time, int m) {
        int left = 0;
        int right = accumulate(time.begin(), time.end(), 0);
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (solveProblems(time, mid) > m) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
};
```

