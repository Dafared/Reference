## 1.链表操作

### 移除链表元素

删除链表第一个结点时需要特殊处理
因此,为了不特殊处理头结点,可以设置一个**虚拟头结点**
这样,所有节点就都可以按照统一的方式进行移除了

最后return的头结点应是虚拟头结点的下一个,而不是人为设置的虚拟头结点

### 设计单链表

> - get(index): 获取链表中第 index 个节点的值,如果索引无效，则返回-1
> - addAtHead(val): 在链表的第一个元素之前添加一个值为 val 的节点,插入后，新节点将成为链表的第一个节点
> - addAtTail(val): 将值为 val 的节点追加到链表的最后一个元素
> - addAtIndex(index,val): 在链表中的第 index 个节点之前添加值为 val 的节点,如果 index 等于链表的长度，则该节点将附加到链表的末尾,如果 index 大于链表长度，则不会插入节点,如果index小于0，则在头部插入节点
> - deleteAtIndex(index): 如果索引 index 有效，则删除链表中的第 index 个节点

类维护一个虚拟头结点成员和一个size成员

```c++
class MyLinkedList {
public:
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    MyLinkedList() {
        dummy_head_ = new LinkedNode(0);
        size_ = 0;
    }
    
    int get(int index) {
        if (index < 0 || index >= size_) {
            return -1;
        }
        LinkedNode* cur = dummy_head_->next;
        while (index--) {
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        LinkedNode* new_node = new LinkedNode(val);
        new_node->next = dummy_head_->next;
        dummy_head_->next = new_node;
        size_++;
    }
    
    void addAtTail(int val) {
        LinkedNode* cur = dummy_head_;
        for(int i=0; i<size_; i++) {
            cur = cur->next;
        }
        LinkedNode* new_node = new LinkedNode(val);
        cur->next = new_node;
        size_++;
    }
    
    void addAtIndex(int index, int val) {
        if (index < 0 || index > size_) {
            return;
        } 
        LinkedNode* cur = dummy_head_->next;
        LinkedNode* pre = dummy_head_;
        while (index--) {
            cur = cur->next;
            pre = pre->next;
        }
        LinkedNode* new_node = new LinkedNode(val);
        new_node->next = cur;
        pre->next = new_node;
        size_++;
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size_) {
            return;
        } 
        LinkedNode* cur = dummy_head_->next;
        LinkedNode* pre = dummy_head_;
        while (index--) {
            cur = cur->next;
            pre = pre->next;
        }
        pre->next = cur->next;
        delete(cur);
        cur = NULL;
        size_--;
    }
private:
    size_t size_;
    LinkedNode* dummy_head_;
};
```

### 双链表

```c++
class MyLinkedList {
public:
    struct LinkedNode{
        int val;
        LinkedNode* next;
        LinkedNode* pre;
        LinkedNode(int v): val(v), next(nullptr), pre(nullptr) {}
    };
    MyLinkedList() {
        dummy_head_ = new LinkedNode(0);
        size_ = 0;
    }
    
    int get(int index) {
        if (index < 0 || index >= size_) {
            return -1;
        }
        LinkedNode* cur = dummy_head_->next;
        while (index--) {
            cur = cur->next;
        }
        return cur->val;
    }
    
    // 插入需要设置:
    // 1.new节点的pre和next;
    // 2.new之前节点的next;
    // 3.new之后节点的pre;
    void addAtHead(int val) {
        LinkedNode* new_node = new LinkedNode(val);
        new_node->pre = dummy_head_;
        new_node->next = dummy_head_->next;
        if (dummy_head_->next != nullptr) {
            dummy_head_->next->pre = new_node;
        }
        dummy_head_->next = new_node;
        size_++;
    }
    
    void addAtTail(int val) {
        LinkedNode* cur = dummy_head_;
        for (int i=0; i<size_; i++) {
            cur = cur->next;
        }
        LinkedNode* new_node = new LinkedNode(val);
        new_node->pre = cur;
        cur->next = new_node;
        size_++;
    }
    
    void addAtIndex(int index, int val) {
        if (index < 0 || index > size_) {
            return;
        }
        LinkedNode* pre = dummy_head_;
        while(index--) {
            pre = pre->next;
        }
        LinkedNode* new_node = new LinkedNode(val);
        new_node->pre = pre;
        new_node->next = pre->next;
        if (pre->next != nullptr) {
            pre->next->pre = new_node;
        }
        pre->next = new_node;
        size_++;
    }
    
    // 删除节点需要设置:
    // 1.被删节点下一个节点的pre
    // 2.被删节点前一个节点的next
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size_) {
            return;
        }
        LinkedNode* pre = dummy_head_;
        while(index--) {
            pre = pre->next;
        }
        LinkedNode* cur = pre->next;
        if (cur->next != nullptr) {
            cur->next->pre = pre;
        }
        pre->next = cur->next;
        delete(cur);
        cur = nullptr;
        size_--;
    }
private:
    LinkedNode* dummy_head_;
    size_t size_;
};
```

### 双链表+循环链表

```c++
class MyLinkedList {
private:
    struct LinkedList{
        int val;
        LinkedList* next;
        LinkedList* pre;
        LinkedList(int val) : val(val), next(nullptr), pre(nullptr) {}
    };
    LinkedList* dummy_head_;
    int size_;
public:
    MyLinkedList() {
        dummy_head_  = new LinkedList(0);
        size_ = 0;
    }
    
    int get(int index) {
        if (index < 0 || index >= size_) {
            return -1;
        }
        LinkedList* cur = dummy_head_->next;
        while (index--) {
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        LinkedList* tmp = new LinkedList(val);
        tmp->pre = dummy_head_;
        if (dummy_head_->next) {
            tmp->next = dummy_head_->next;
            dummy_head_->next->pre = tmp;
        } else {
            tmp->next = dummy_head_;
            dummy_head_->pre = tmp;
        }
        dummy_head_->next = tmp;
        size_++;
    }
    
    void addAtTail(int val) {
        LinkedList* tmp = new LinkedList(val);
        tmp->next = dummy_head_;
        if (dummy_head_->pre) {
            tmp->pre = dummy_head_->pre;
            dummy_head_->pre->next = tmp;
        } else {
            tmp->pre = dummy_head_;
            dummy_head_->next = tmp;
        }
        dummy_head_->pre = tmp;
        size_++;
    }
    
    void addAtIndex(int index, int val) {
        if (index < 0 || index > size_) {
            return;
        }
        if (size_ == 0) {
            addAtHead(val);
        } else if (index == size_) {
            addAtTail(val);
        } else {
            LinkedList* pre = dummy_head_;
            LinkedList* tmp = new LinkedList(val);
            while (index--) {
                pre = pre->next;
            }
            tmp -> next = pre->next;
            tmp -> pre = pre;
            pre->next->pre = tmp;
            pre->next = tmp;
            size_++;
        }
        
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size_) {
            return;
        }
        LinkedList* pre = dummy_head_;
        while (index--) {
            pre = pre->next;
        }
        LinkedList* tmp = pre->next;
        pre->next->next->pre = pre;
        pre->next = pre->next->next;
        delete tmp;
        tmp = nullptr;
        size_--;
    }
    void traverse() {
        LinkedList* tmp = dummy_head_->next;
        while(tmp != dummy_head_) {
            cout<<tmp->val<<" ";
            tmp = tmp->next;
        }
        cout<<endl;
    }
};
```

## 2.反转链表(双指针)

从头开始逐个反转每个结点的next指针即可

使用一个**pre指针和cur指针**从头遍历数组,反转每个cur指针指向结点的next指针到pre

另外需要用**一个临时变量**存储原来的cur->next

```c++
ListNode* reverseList(ListNode* head) {
    ListNode* pre = nullptr;
    ListNode* cur = head;
    while (cur) {
        ListNode* cur_next = cur->next;
        cur->next = pre;
        pre = cur;
        cur = cur_next;
    }
    return pre;
}
```

### 递归反转链表

和双指针法是一样的逻辑,同样是当cur为空时循环结束,不断将cur指向pre的过程

```c++
ListNode* reverse(ListNode* pre,ListNode* cur){
    // 递归终止条件cur == NULL
    if(cur == NULL) return pre;
    ListNode* temp = cur->next;
    cur->next = pre;
    // 可以和双指针法的代码进行对比,如下递归的写法,其实就是做了这两步
    // pre = cur;
    // cur = temp;
    return reverse(cur,temp);
}
ListNode* reverseList(ListNode* head) {
    // 和双指针法初始化是一样的逻辑
    // ListNode* cur = head;
    // ListNode* pre = NULL;
    return reverse(NULL, head);
}
```

## 3.链表区间反转

**反转链表Ⅱ, Leetcode 92**

要求将链表中从left到right部分的结点反转

①先将待反转的区域反转
②将原来链表中left前结点的next设为反转后新的头结点(原来反转区域的最后一个结点right)
将反转部分新的尾结点(原来反转区域的第一个结点)的next设为原来链表中right后的结点
③因为需要用到left的前一个结点,为了不特殊处理第一个结点,引入虚拟头结点

1.记录left,right以及left前一个,right后一个位置的指针
2.反转left到right区域的链表
3.处理首尾

```c++
ListNode* reverseBetween(ListNode* head, int left, int right) {
    ListNode* begin;
    ListNode* end;
    ListNode* left_pre;
    ListNode* right_next;
    ListNode* left_p;
    ListNode* right_p;
    ListNode* dummy_head = new ListNode(0, head); 
    ListNode* cur = dummy_head;
    int count = 1;
    // 获取left,right以及left前一个,right后一个位置的指针
    while (cur) {
        if (count == left) {
            left_pre = cur;
            left_p = cur->next;
        }
        if (count == right+1) {
            right_p = cur;
            right_next = cur->next;
            break;
        }
        count++;
        cur = cur->next;
    }
    ListNode* pre = left_p;
    cur = left_p->next;
    // 反转从left到right区域内的结点
    while (cur != right_next) {
        ListNode* tmp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = tmp;
    }
    // 处理区域两头左右两侧的结点
    left_pre->next = right_p;
    left_p->next = right_next;
    return dummy_head->next;
}
```

**精简代码:**

注意题目给的left和right是从0开始还是1开始!

内部反转后处理头尾**只需要记录组前的一个节点pre_group**

> 反转的内部区间是pre_group之后的right-left+1个节点

①pre_group->next和反转后组内的最后一个(原来的第一个)
②当前pre为反转后组内的第一个(原来的最后一个)
③当前cur为反转后组后第一个节点
处理头尾,需要给两个next指针赋值:
①组前节点的next②反转后组内的最后一个(反转前组内的第一个)节点的next
pre_group->next->next = cur;
pre_group->next = pre;

```c++
ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* dummy_head = new ListNode();
        dummy_head->next = head;
        ListNode* pre_group = dummy_head;
        for (int i=0; i<left-1; i++) {
            pre_group = pre_group->next;
        }
        ListNode* pre = nullptr;
        ListNode* cur = pre_group->next;
        for (int i=0; i<right-left+1; i++) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        pre_group->next->next = cur;
        pre_group->next = pre;
        return dummy_head->next;
}
```

## 4.链表结点两两交换

模拟即可

设交换结点1和结点2,结点0为结点1的前一个结点,结点3为结点2的后一个结点:
①第0个结点next改为指向第2个结点
②第2个结点next改为指向第1个结点
③第1个结点next改为指向第3个结点
按以上方法,依次从前到后,每2个结点一组处理整个链表

(使用虚拟头结点避免特殊处理第一个结点)

**注意在first和second交换位置后下一组的pre是first不是second!**

```c++
ListNode* swapPairs(ListNode* head) {
    ListNode* dummy_head = new ListNode(0, head);
    ListNode* pre = dummy_head;
    while (pre->next && pre->next->next) {
        ListNode* first = pre->next;
        ListNode* second = pre->next->next;
        ListNode* second_next = second->next;
        pre->next = second;
        second->next = first;
        first->next = second_next;
        pre = first;
    }
    return dummy_head->next;
}
```

## 5.链表删除倒数第N个(双指针)

双指针的典型应用
基本思想:先让fast指针移动n步,然后fast和slow指针同时移动
当fast指针走到末尾,slow指针处就是要删除的结点

实际操作时:
①由于删除某结点时,**实际需要的是该结点的上一个结点**,而不是这个结点本身
所以实际上**fast结点先走n+1步**,这样fast到末尾时slow结点指向倒数第n个结点的上一个结点
②使用**虚拟头结点**,不用特殊处理第一个结点
③判断快指针走到链表末尾:`fast==nullptr`

①刚开始快慢指针都指向虚拟头结点
②快指针先走n+1步
③之后快慢指针同时往后移动,直到fast==NULL

```c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy_head = new ListNode(0,head);
    ListNode* fast = dummy_head;
    ListNode* slow = dummy_head;
    int count = n+1;
    while (count--) {
        fast = fast->next;
    }
    while (fast) {
        fast = fast->next;
        slow = slow->next;
    }
    ListNode* tmp = slow->next;
    slow->next = tmp->next;
    delete(tmp);
    tmp = nullptr;
    return dummy_head->next;
}
```

## 6.链表相交

①分别求出长短两个链表的长度,计算二者长度差
②设A长B短,让curB指针指向B链表开始处
让curA指针从开始处移动二者长度差的距离,使两个指针分别离各自链表结尾处距离相同
(让curA移动到,和curB 末尾对齐的位置)

如果链表A和B有相交,则二者相交开始的位置一定在当前指针curA,curB位置到链表结尾位置之间
<img src="./images/16.jpg" alt="16" style="zoom: 67%;" />

之后,比较curA和curB,并同时向后移动curA和curB,如遇到curA==curB,则两个链表从此处开始相交

## 7.环形链表II(双指针)

如链表有环,返回链表开始入环的第一个节点;没环返回null

使用快慢指针的方法
具体推导见[环形链表](https://programmercarl.com/0142.环形链表II.html)

①快慢指针都存链表开始出发,fast指针每次走两步,slow指针每次走一步
如果有环,二者必定会相遇(且是在环中相遇)

②二者相遇后,停止移动fast和slow
之后,设置指针index1指向链表开始,index2指向fast和slow二者相遇处,
index1和index2同时向前移动,index1和index2二者相遇的位置即环的入口处

> 由数学推导知,链表开头到环入口距离 = n \* (环长) + 快慢指针相遇处到向前走到环入口的距离
>
> 另外:①由于fast速度是慢指针的2倍,慢指针入环时快指针已在环内某处
> 所以易知slow指针必定在环内走的第一圈被fast指针追上相遇
>②二者相对速度=1,所以也不存在快指针越过慢指针的情况
> 
>**注意因为可能没有环,fast指针移动时注意fast和fast->next为NULL的情况!**

代码:

```c++
ListNode *detectCycle(ListNode *head) {
    ListNode* fast = head;
    ListNode* slow = head;
    while (fast && fast->next) {
        fast = fast->next->next;
        slow = slow->next;
        if (slow == fast) {
            break;
        }
    }
    if (!fast || !fast->next) {
        return NULL;
    }
    ListNode* p1 = head;
    ListNode* p2 = slow;
    while (p1 != p2) {
        p1 = p1->next;
        p2 = p2->next;
    }
    return p1;
}
```

## 8.回文链表

注意给的是单链表,只能单向访问

1.方法一:先复制到数组中,再进行比较

2.方法二:反转后半部分链表

①用快慢指针,快指针走两步,慢指针走一步,快指针遇到终止位置时,慢指针就在链表中间位置
后半部分的链表从slow开始到原链表末尾结束(如长度是奇数,则后半部分多一个结点)
②反转后半部分链表
③从前到后依次比较两部分链表的元素
(链表长度为奇数时,最中间的元素和是否回文无关;因在后半部分反转后,原链表最中间的元素(后半部第一个元素)**被反转到后半部分链表最后一个,所以不会被比较**(因该情况下后半部分长度比前半部分大1))

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }
        ListNode* list2 = reverselinkedlist(slow);
        ListNode* list1 = head;
        while (list1 != slow) {
            // 注意虽然后半部分反转了,但前半部分最后一个的next仍指向原来的后半部分第一个slow!
            // 所以仍用list1 == slow 判断结束
            if (list1->val != list2->val) {
                return false;
            }
            list1 = list1->next;
            list2 = list2->next;
        }
        return true;
    }
    ListNode* reverselinkedlist(ListNode* head) {
        ListNode* pre = NULL;
        ListNode* cur = head;
        while (cur) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

## 9.重排链表

(注意是单链表,无法从后往前!)

方法一:放进数组,从数组头和尾开始取元素构造新链表

方法二:链表放进双向队列,然后通过双向队列一前一后弹出数据,来构造新的链表

方法三:将链表分割成两个链表,然后把第二个链表反转,之后在通过两个链表拼接成新的链表

```c++
class Solution {
public:
    void reorderList(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        ListNode* pre = NULL;
        while (fast && fast->next) {
            fast = fast->next->next;
            if (!(fast && fast->next)) {
                pre = slow;
            }
            slow = slow->next;
        }
        if (!pre) {
            // 链表只有一个元素,无需分割+反转后半部分,直接返回
            return;
        }
        pre->next = NULL; // 让前半部分最后一个元素的next=NULL
        ListNode* list2 = reverse(slow); //list2为L_n,L_n-1,...
        ListNode* list1 = head; //list1为L_0,L_1,L_2,...
        ListNode* dummy_head = new ListNode(); //虚拟头结点,避免特殊处理第一个
        ListNode* cur = dummy_head; 
        bool flag = true;
        while (list1 && list2) {
            if (flag) {
                cur->next = list1;
                list1 = list1->next;
                cur = cur->next;
                flag = false;
            } else {
                cur->next = list2;
                list2 = list2->next;
                cur = cur->next;
                flag = true;
            }
        }
        
        while (list1) {
            cur->next = list1;
            list1 = list1->next;
            cur = cur->next;
        }
        while (list2) {
            cur->next = list2;
            list2 = list2->next;
            cur = cur->next;
        }
    }
    ListNode* reverse(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = NULL;
        while (cur) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

## 10.合并两个有序链表

**注意使用虚拟头结点,避免特殊处理第一个结点**

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode* dummy_head = new ListNode(0);
    ListNode* cur = dummy_head;
    while (list1 && list2) {
        if (list1->val <= list2->val) {
            cur->next = list1;
            list1 = list1->next;
            cur = cur->next;
        } else {
            cur->next = list2;
            list2 = list2->next;
            cur = cur->next;
        }
    }
    while (list1) {
        cur->next = list1;
        list1 = list1->next;
        cur = cur->next;
    }
    while (list2) {
        cur->next = list2;
        list2 = list2->next;
        cur = cur->next;
    }
    return dummy_head->next;
}
```

## 11.合并K个有序链表

**Leetcode 23**

### 逐一比较/优先队列

思想:找出当前所有链表中头结点val最小的一个,把该结点接在上一个后面,以此类推

**自己第一次写用了该思路,但用的是逐一比较的方法得到当前所有链表中最小的一个:**

**注意vector删除指定元素时迭代器失效的问题**

vector删除指定元素方法:

```c++
vector<int> a = { 12, 23, 34, 45, 56, 67, 78, 89 };
auto iter = a.begin();
while (iter != a.end()) 
{
    if (*iter > 30) 
    {	
        // erase()函数返回指向被删除元素的下一元素的迭代器
        iter = a.erase(iter);//用iter接收返回值
    }
    else //不要忘记这一段
    {
        ++iter;
    }
}
```

代码:
没有使用优先队列,而是原地比较,所以空间复杂度为O(1)
时间复杂度:vector寻找和删除代价都是O(k),设链表长度为n,则共kn个结点
因此总的时间复杂度是O($k^2n$)

```c++
ListNode* mergeKLists(vector<ListNode*>& lists) {
    ListNode* dummy_head = new ListNode(0);
    ListNode* cur = dummy_head;
    auto iter = lists.begin();
    while (iter != lists.end()) {
        if (!*iter) {
            iter = lists.erase(iter);
        } else {
            iter++;
        }
    }
    while (!lists.empty()) {
        int min = INT32_MAX;
        int min_index = -1;
        for (int i=0; i<lists.size(); i++) {
            if (lists[i]->val < min) {
                min_index = i;
                min = lists[i]->val;
            }
        }
        cur->next = lists[min_index];
        cur = cur->next;
        lists[min_index] = lists[min_index]->next;
        if (!lists[min_index]) {
            lists.erase(lists.begin() + min_index);
        }
    }
    return dummy_head->next;
}
```

**改进:可以使用优先队列选出当前所有链表头结点值最小的那个**

优先队列定义:

> (优先队列升序:**从头到尾升序**,从先出队的到后出队的依次升序,比较器为>)
> (优先队列降序:**从头到尾降序**,从先出队的到后出队的依次降序,比较器为<)
> (想象尾在左边,头在右边,队尾(入)-----队头(出))
>
> **想让小的先出来,传入>**
> **想让大的先出来,传入<**

```c++
struct Status {
    int val;
    ListNode *ptr;
    bool operator < (const Status &rhs) const {
        return val > rhs.val;
    }
};

priority_queue <Status> q;
```

合并过程:
**(弹出一个链表当前头结点后,需要把其下一个结点再加入优先队列)**

```c++
for (auto node: lists) {
    if (node) q.push({node->val, node});
}
ListNode* dummy_head = new ListNode(0);
ListNode* cur = dummy_head;
while (!q.empty()) {
    auto min = q.top().ptr;
    cur->next = min;
    cur = cur->next;
    q.pop();
    if (min->next) {
        // 每弹出一个链表的结点,就要把其下一个结点再入队
        q.push({min->next->val, min->next});
    }
}
return dummy_head->next;
```

使用优先队列,所以空间复杂度为O(k)
时间复杂度:优先队列插入和删除代价都是O(logk),设链表长度为n,则共kn个结点
因此总的时间复杂度是O($logk\times kn$)

### 分治合并

不同于上面,同时比较所有链表当前头结点,逐一得到结果链表的各个结点
而是直接对各个链表两两合并,直到只剩一个链表
采用归并法合并各个链表
<img src="./images/17.jpg" alt="17" style="zoom:67%;" />

归并代码:
`mergeTwoLists()`为合并两个链表的函数(该函数中注意输入为NULL的情况)

```c++
ListNode* merge(vector <ListNode*> &lists, int l, int r) {
    // 对划分的前后两部分链表分别递归调用merge
    // 并对返回的两个已经递归归并好的链表进行合并
    // 递归终止条件:l到r的范围中只有一个元素
    // 递归终止往上返回后,合并两个链表
    if (l == r) return lists[l];
    if (l > r) return nullptr;
    int mid = (l + r) >> 1;
    return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
}
```

空间复杂度:递归会使用到 O(log⁡k) 空间代价的栈空间
时间复杂度:**递归logk次,每次时间复杂度O(kn)**,所以总的时间复杂度是O($logk\times kn$)

## 12.链表排序

**Leetcode 148**

### 归并排序

**每轮递归用快慢指针把链表分成两部分+使用归并排序**

```c++
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return merge(head);
    }
    ListNode* merge(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        ListNode* pre = NULL; //别忘了设为NULL
        while (fast && fast->next) {
            fast = fast->next->next;
            if (!(fast && fast->next)) {
                pre = slow;
            }
            slow = slow->next;
        }
        // slow:后半部分链表的开始结点;pre:前半部分链表的最后一格结点
        if (!pre) { // 链表只有一个结点或为空链表
            return head;
        }
        pre->next = NULL;
        // 会一致往下调用merge递归,直到以head和slow开头的链表都只有一个结点,merge()结束
		// 然后mergeTwoLists对这两个单独的结点排序,得到长度为2的有序链表,向上返回
        // 之后合并返回的2个长度为2的有序链表,得到长度为4的有序链表,然后再向上返回...
        return mergeTwoLists(merge(head),merge(slow));
    }
    // 合并两个有序链表的函数
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (!list1 || !list2) {
            return !list1? list2 : list1;
        }
        ListNode* dummy_head = new ListNode(0);
        ListNode* cur = dummy_head;
        while (list1 && list2) {
            if (list1->val <= list2->val) {
                cur->next = list1;
                cur = cur->next;
                list1 = list1->next;
            } else {
                cur->next = list2;
                cur = cur->next;
                list2 = list2->next;
            }
        }
        while (list1) {
            cur->next = list1;
            cur = cur->next;
            list1 = list1->next;
        }
        while (list2) {
            cur->next = list2;
            cur = cur->next;
            list2 = list2->next;
        }
        return dummy_head->next;
    }
};
```

### 快速排序

(本例超时)

```c++
ListNode* sortList(ListNode* head) {
    if (!head) return head;
    ListNode* end = head;
    while (end->next) {
        end = end->next;
    }
    quickSort(head,end);
    return head;
}
void quickSort(ListNode* begin, ListNode* end) {
    if (!begin || !end || begin == end) {
        return;
    }
    int base = begin->val; // 以begin结点数据为本轮快排的“基准”
    ListNode* left = begin;
    ListNode* right = begin->next;
    // 把链表中比base小的数据交换到链表前半部分
    while (right) {
        if (right->val < base) {
            left = left->next;
            if (left != right) {
                swap(left->val, right->val);
            }
        }
        right = right->next;
    }
    // 此时链表前半部分(left之前的部分(包括left))均小于base
    // 把基准值 begin->val和left->val交换,让基准值处于中间
    // 此时基准值左边的结点都比base小,右边的结点都比base大
    swap(begin->val, left->val);
    quickSort(begin, left);
    quickSort(left->next, end);
}
```

正确做法

```c++
struct Node 
{
	int key;
	Node* next;
	Node(int nKey, Node* pNext)
		: key(nKey)
		, next(pNext)
	{}
};
 
 
Node* GetPartion(Node* pBegin, Node* pEnd)
{
	int key = pBegin->key;
	Node* p = pBegin;
	Node* q = p->next;
 
	while(q != pEnd)
	{
		if(q->key < key)
		{
			p = p->next;
			swap(p->key,q->key);
		}
 
		q = q->next;
	}
	swap(p->key,pBegin->key);
	return p;
}
 
void QuickSort(Node* pBeign, Node* pEnd)
{
	if(pBeign != pEnd)
	{
		Node* partion = GetPartion(pBeign,pEnd);
		QuickSort(pBeign,partion);
		QuickSort(partion->next,pEnd);
	}
}
```

## 13.两数相加

要进位: 结果  = add % 10; 新的进位 = add / 10;
别忘了**两个链表都遍历完毕时,进位数可能不等于0,相加结果还要再多一位**

```c++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode* dummy_head = new ListNode(0);
    ListNode* cur = dummy_head;
    int c_num = 0;
    while (l1 && l2) {
        int add = l1->val + l2->val + c_num;
        if (add < 10) {
            ListNode* res = new ListNode(add);
            cur->next = res;
            cur = cur->next;
            c_num = 0;
        } else {
            ListNode* res = new ListNode(add % 10);
            cur->next = res;
            cur = cur->next;
            c_num = add / 10;
        }
        l1 = l1->next;
        l2 = l2->next;
    }
    while (l1) {
        int add = l1->val + c_num;
        if (add < 10) {
            ListNode* res = new ListNode(add);
            cur->next = res;
            cur = cur->next;
            c_num = 0;
        } else {
            ListNode* res = new ListNode(add % 10);
            cur->next = res;
            cur = cur->next;
            c_num = add / 10;
        }
        l1 = l1->next;
    }
    while (l2) {
        int add = l2->val + c_num;
        if (add < 10) {
            ListNode* res = new ListNode(add);
            cur->next = res;
            cur = cur->next;
            c_num = 0;
        } else {
            ListNode* res = new ListNode(add % 10);
            cur->next = res;
            cur = cur->next;
            c_num = add / 10;
        }
        l2 = l2->next;
    }
    // 别忘了两个链表都遍历完毕时,进位数可能不等于0,相加结果还要再多一位
    if (c_num != 0) {
        ListNode* res = new ListNode(c_num);
        cur->next = res;
    }
    return dummy_head->next;
}
```

## 14.K个一组反转链表

自己第一次写的:

```c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 删除一组,需要用到该组前面的一个结点
        // 所以设置虚拟头结点比较方便,第一组组前结点为虚拟头结点
        ListNode* dummy_head = new ListNode(0, head);
        ListNode* pre_group = dummy_head; // 一组k个结点的前一个结点(组前结点)
        ListNode* end_group = nullptr; // 一组k个结点内部的最后一个结点(组内末尾结点)
        ListNode* cur = dummy_head;
        // 当前cur处于组前结点,设置count=3
        int count = k;
        while (cur) {
            // count==0:走到一组k个中的最后一个
            // 1.反转组;2.设置下一组的组前结点;3.重置k
            if (count == 0) {
                // cur到了一组k个中的最后一个,设置组内末尾结点         
                end_group = cur;
                // pre_group->next为k个中第一个,反转后就是k个中最后一个
                cur = pre_group->next;
                // 进行反转(包括处理该组和其左右两边其他结点的连接!)
                reverse_group(pre_group, end_group);
                // 设置下一组的组前结点
                pre_group = cur;
                
                // 重置count=k
                count = k;
            }
            cur = cur->next;
            count--;
        }
        return dummy_head->next;
    }
    void reverse_group(ListNode* pre_group, ListNode* end_group) {
        // 输入k个结点之前的组前结点, 以及k个结点内的组内末尾结点
        ListNode* begin = pre_group->next;
        ListNode* after = end_group->next;
        ListNode* pre = pre_group->next;
        ListNode* cur = nullptr;
        if (pre_group->next) {
            cur = pre_group->next->next;
        }
        while (cur != after) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        // pre为该组k个结点反转后的最前面的结点
        // 原来的begin在反转后成为该组k个结点最后面的结点
        pre_group->next = pre;
        begin->next = after;
    }
};
```

