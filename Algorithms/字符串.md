## 1.反转字符串(双指针)

原地反转字符串

双指针法,从字符串头和尾同时往中间走
在过程中交换对应的元素

## 2.反转字符串Ⅱ

> 每2k个字符,反转前k个
> 剩余不足2k,但大于k,依旧反转前k个
> 剩余不足k个,全部反转

遍历字符串下标的指针初始=0,每次循环加2k
每次要分剩余的字符>=k个和不足k个两种情况

## 3.替换空格(双指针)

**不能从前到后处理**,因为每当遇到空格,需要进行替换时都要把该空格后面的字符全部**往后移动一次**
每次移动都是O(N),因而导致了总的O(N^2)的时间复杂度

应该**预先给字符串扩充大小,然后从后往前进行处理**
**扩容后从后往前处理**,遇到的字符都可以直接被移动到最终位置,即**所有字符只需被移动一次**

先统计字符串中空格的个数=count
然后用resize()对string扩容,让其大小增大2\*count (size扩成替换后的大小)

> string的 reserve() 和 resize()
> reserve()为容器预留足够的空间,避免不必要的重复分配,预留空间大于等于字符串长度,可通过capacity()查看
> resize()调整字符串大小,如字符串长度变小,多余字符被截掉;若长度变大,可设置填充的字符,大小用size()查看

字符串扩容后,使用双指针,**分别位于扩容后字符串和原字符串最后一个位置**
两个指针同时往前移动,如遇到原字符串中非空格字符.将其复制到扩容后字符串的新位置即可
若遇到原字符串中空格字符,在扩容后字符串对应位置插入替换内容"%20"(后面的指针额外往前移动2格)

## 4.翻转串内单词(局部反转+整体反转)

要求不使用辅助空间

①去掉多余空格
②反转整个字符串
③反转每个单词

①后反转整个字符串和每个单词,可调用reverse函数,或自己编写反转函数

**去掉多余空格**
(包括两个单词之间多余一个的空格+字符串前部和后部的空格)

注意:不要使用从头到尾遍历字符串+遇到空格后用erase()删除的方法
因为erase()删除本身就是O(N),导致整个删除过程总的复杂度为O(N^2)

**方法一:使用数组删除指定元素的题目的类似方法--快慢指针**
快指针遍历整个原字符串所有元素
慢指针负责存储"除多余空格外的其他要保留字符"
快指针遍历过程中遇到多余的空格,不操作慢指针,只把快指针继续后移一格
除此之外,把快指针当前所指的元素保存到慢指针当前所指位置,快慢指针都后移一格
**最后用resize调整去掉多余空格后字符串大小**

```c++
class Solution {
public:
    string reverseWords(string s) {
        removeSpaces(s);
        reverse(s,0,s.size()-1);
        int slow = 0;
        for(int i=0; i<=s.size(); i++) {
            if (i==s.size() || s[i] == ' ') {
                reverse(s,slow,i-1);
                slow = i+1;
            }
        }
        return s;
    }
    void removeSpaces(string &s) {
        int slow = 0;
        int fast = 0;
        // 去掉开头的空格
        while (fast < s.size() && s[fast] == ' ') {
            fast++;
        }
        while (fast < s.size()) {
            // 去掉两个单词之间多余的空格
            // 如果fast和fast的下一个都是空格,则跳过fast
			// fast经过单词之间连续多个空格,只会把最后一个写入s[slow]
            // 但字符串最后部分有多个空格,也会写入一个空格到s[slow],需要后面再去除
            if (fast < s.size() - 1 && s[fast] == ' ' && s[fast+1] == ' ') {
                fast++;
                continue;
            }
            s[slow] = s[fast];
            slow++;
            fast++;
        }
        // 去除当前字符串最后面可能多余的一个空格
        // 上面在字符串中进行了slow次 s[slow] = s[fast];操作
        // 若后面多了一个空格,则最后得到字符串大小为slow-1;否则为slow
        if (slow - 1 > 0 && s[slow - 1] == ' ') {
            s.resize(slow - 1);
        } else {
            s.resize(slow);
        }
    }
    void reverse(string &s, int left, int right) {
        while (left < right) {
            swap(s[left], s[right]);
            left++;
            right--;
        }
    }
};
```

**方法二:方法一快慢指针的简化版,人工添加空格**

每当快指针遇到一个单词的开头,**如果不是第一个单词(`slow != 0`),就先人工添加一个空格**
之后继续遍历直到该单词结束(同时把该单词存储到慢指针位置)

之后继续寻找下一个单词的开头,重复以上操作

```c++
void removeSpaces(string &s) {
    int slow = 0;
    for (int i=0; i<s.size(); i++) {
        if (s[i] != ' ') {
            if (slow != 0) {
                s[slow++] = ' ';
            }
            while (i<s.size() && s[i] != ' ') {
                s[slow++] = s[i++];
            }
        }
    }
    s.resize(slow);
}
```

## 5.左旋转字符串(局部反转+整体反转)

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部
要求不使用额外空间,只在本串上进行操作

类似上一题,也可使用局部反转+整体反转来实现

1. 反转区间为前n的子串
2. 反转区间为n到末尾的子串
3. 反转整个字符串

### 右旋转字符串

类似,把字符串后面的若干个字符转移到字符串的头部

1. 反转整个字符串
2. 反转区间为前n的子串
3. 反转区间为n到末尾的子串

若要像左旋转一样先局部反转最后再反转整个字符串
则需要先①反转倒数n个字符串②反转后n个字符串前面的其余字符串②反转整个字符串
**看清要移动的是头部还是尾部!**

## 6.模式匹配(strStr()实现)

### KMP算法

> 示例:要在字符串S中寻找是否存在字符串T
> S: a b c a b c ....
> T: a b c a b d ....
> 在第六个字符处匹配失败(要求是d,实际是c)
>
> 暴力方法:第6个字符串匹配失败后,模式串T之前比较过的5个字符全部作废
> 需要重新开始与T中各字符逐一比较

所以,传统暴力方法可以进行改进

由上,当匹配失败时,不一定非要从T的开头开始重新逐个比较,而是可能可以直接从T中间某个位置开始比较
可以这样做的条件是:对于**模式串T中**与字符串S当前字符匹配失败的那个字符之前**已匹配过的部分来说**,存在前缀与后缀相同的情况,即严谨的说,"**前面部分存在相等前后缀**"

而具体可从T中间什么位置重新开始比较,取决于**前面部分的最长相等前后缀长度**

> 如上例,对于T中'd'前面的5个字符来说,最长相等前后缀为'a''b'(后两个与前两个相同)
> 即,该例中,前面部分最长相等前后缀长度=2
> 所以d匹配失败后,可以从T的第2+1=3个字符('c',下标=2)重新开始比较

我们可以预先通过对模式串T的结构进行分析,推断出每个位置匹配失败时,分别可跳转到中间什么位置重新开始比较;分析结果存储在与T等长的next数组中,其每个元素代表T在该位置匹配失败时应跳转到的位置下标

**求next数组**

易知,当T在第一或第二个字符就匹配失败,T只能回到第一个元素重新比较(下标=0)
又为了编程方便(后面会提),让next[0]=-1,所以next[0]=-1,next[1]=0

求next数组的代码:
```java
int i = 0;
int j = -1;
vector<int> next(needle.size());
next[0] = -1;
while(i < needle.size()-1) {
    if (j == -1 || needle[i]==needle[j]) {
        next[i+1] = j+1;
        i++;
        j++;
    } else {
        j = next[j];
    }
}
```

`i`为用于遍历整个T数组的下标
`j`表示要与`i`位置字符进行比较的前缀字符的下标
先分别初始化为0,-1
j初始化为-1的作用是:当回到字符串开头或刚开始时,字符串开头第一个字符就不匹配时
也可以将i和j分别++,让`i`继续向前移动一格,同时设next[i]=0

> 当不匹配时,①T第一个字符就不匹配,需要移动`i`至下一位置,`j`需停留在下标0处
> ②T除此之外的不匹配,都不需要移动`i`,只移动`j`到`next[j]`
> 当匹配时,i和j都同时往后移动一位
> 设next[0]为-1可将不匹配的第一种情况和匹配时的情况统一处理
>
> 若是不用回到开头,需要从公共前后缀的下一个开始重新开始比较,即`next[i+1]=j+1`
> 但若回到字符串开头,为了和上面情况统一,让`next[0]=-1`,`j=next[0]=-1`后,可让`next[i+1]=j+1=0`

求next数组其余部分:

①`T[i] == T[j]`,前后缀字符相同,匹配成功
`next[i+1]=next[j+1]`(若正式比较时,在i+1处匹配失败,可跳转到j+1处)
`i`和`j`继续移动到下一个位置

②`T[i] != T[j]`,前后缀字符不同,匹配失败
让`j=next[j]`(j移动到next[j]位置重新开始与i及i以后位置的字符比较)

(求next数组进行前后缀匹配也和模式匹配同理,当匹配失败时不一定要跳转到开头重新开始比,可能只需用已经前面已经求出的next数组跳转到中间某位置重新开始比即可)

**KMP算法主体流程**

最后,如果指针`j`走到T字符串最后,则找到,匹配成功
返回的开始下标为`i - T.size()`

**注意无符号数与有符号数不能直接比较大小!**

```java
int strStr(string haystack, string needle) {
    vector<int> next = getNext(needle);
    int i=0;
    int j=-1;
    while(i<(int)haystack.size() && j<(int)needle.size()) {
        if (j==-1 || haystack[i] == needle[j]) {
            i++;
            j++;
        } else {
            j = next[j];
        }
    }
    if (j == needle.size()) {
        return i - needle.size();
    }
    return -1;
}
```

**KMP算法改进**

KMP算法存在的问题:
①模式串google,若在第四个字符处匹配失败,则根据next数组,需回到第一个字符再次匹配,但第一个字符与第四个字符相同(都是g),所以理所当然地会再次匹配失败,最终j变为-1,这个过程多进行了一次无意义的匹配
因此可直接将next\[3\](对应第四个失败)改为-1
②模式串aaaab,若在第四个字符处匹配失败,则根据next数组,需回到第三个字符再次匹配,之后再依次回到第二个,第一个,最终j变为-1
由于前几个字符相同,多匹配了很多次
因此next[1],next[2],next[3]均可改为-1

按以上规则优化next数组得到的新数组称为**nextval数组**

**nextval数组求法:**
先算出next数组
先令next1[0]=-1

```java
vector<int> next1(needle.size());
next1[0] = -1;
for (int i=1; i<next.size(); i++){
    if (needle[i] == needle[next[i]]) {
        next1[i] = next1[next[i]];
    } else {
        next1[i] = next[i];
    }
}
```

## 7.重复的子字符串

### 移动匹配 

将2个同样的该字符串首尾相接
如果该字符串可由某个重复的子字符串组成,则首尾相接处必定会出现一个完整的该字符串

> 如给定字符串为"ababab",拼接起来"ababab ababab"
> 前一个字符串的后4个和第二个字符串的前2个可以组成新的"ababab"

(为了避免找到原来的字符串,对拼接后的字符串掐头去尾)

```c++
bool repeatedSubstringPattern(string s) {
    string s1 = s + s;
    string s2 = s1.substr(1,2*s.size()-2);
    return s2.find(s) != std::string::npos;
}
```

### KMP

原字符串中最长相等前后缀不包含的子串为最小重复子串(如果存在)
如果用next数组出的这个最小重复子串的长度可以整除字符串长度,则返回true

注意求的是整个原字符串的最长相等前后缀
而之前的next数组表示的是该下标位置之前的部分的最长相等前后缀
所以这次求的next数组长度为`s.size()+1`

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        vector<int> next = getNext(s);
        int len = s.size();
        if (next[len] != 0 && len % (len-next[len]) == 0) {
            return true;
        }
        return false;
    }
    vector<int> getNext(string s) {
        vector<int> next(s.size()+1);
        next[0] = -1;
        int i=0;
        int j=-1;
        while(i<s.size()){
            if (j==-1 || s[i]==s[j]) {
                next[i+1] = j+1;
                i++;
                j++;
            } else {
                j = next[j];
            }
        }
        return next;
    }
};
```

