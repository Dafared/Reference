# 1.动态规划解题步骤

**某⼀问题有很多重叠子问题**
动态规划中每⼀个状态⼀定是由上⼀个状态推导出来的
(这点不同于贪心,贪心没有状态推导,而是直接看局部最优,和之前的状态没有关系)

**解题五步法:**
①确定dp数组及其下标的含义
②确定递推公式,即状态是怎么转移的
③dp数组如何初始化(有时怎么初始化和递推公式有关)
④确定遍历顺序(依赖顺序)
⑤验证时举例推导dp数组

**debug方法**:把dp数组打印出来,看看究竟是不是按照⾃⼰思路推导的

例子:斐波那契数用动态规划的方法解决
①dp数组:斐波那契数列每一项的值
②递推公式:`dp[i]=dp[i-1]+dp[i-2]`
③初始化:dp[0]=0,dp[1]=1
④后面的依赖前面的,所以从前到后

# 2.基础动规题目

## 1.爬楼梯

https://leetcode-cn.com/problems/climbing-stairs/

①dp[i]表示到第i阶的方法数
②dp[i]可以来自dp[i-1]也可以来自dp[i-2],所以dp[i]=dp[i-1]+dp[i-2]
③dp[1]=1,dp[2]=2(不考虑初始化dp[0]更容易理解)
④从3开始,从前向后

## 2.最小花费爬楼梯

https://leetcode-cn.com/problems/min-cost-climbing-stairs/

cost[i]是从第 i 个台阶向上爬需要支付的费用,一旦支付此费用,即可选择向上爬一个或两个台阶

①dp[i]到达第i个台阶所花费的最少体力
②dp[i]=`min(dp[i-1],dp[i-2])+cost[i]`或`min(dp[i-1]+cost[i-1]+dp[i-2]+cost[i-2])`
③通过dp[0]和dp[1]推出,只需要初始化这两个,则dp[0]=0,dp[1]=0
(可从下标为0或1的台阶直接开始,所以dp[0]和dp[1]初始化为0)
④从i=2开始从前到后遍历cost数组

注意:本题问的是到达楼梯顶部的最低花费
(cost最后一个元素对应最后一个台阶,从此再往上爬一个才是楼梯顶部)
所以答案是dp[cost.size()],不是dp[cost.size()-1],dp数组要比cost数组大小大一个

## 3.不同路径

https://leetcode-cn.com/problems/unique-paths/

暴力解法:
只向右或向下:可转为二叉树
即求该二叉树所有的叶子节点数(使用dfs),但超时

```java
int dfs(int i, int j, int m, int n) {
     if (i > m || j > n) return 0;
     if (i == m && j == n) return 1;
     return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
 }
 int uniquePaths(int m, int n) {
 	return dfs(1, 1, m, n);
 }
```

动态规划解法:

①dp\[i][j]:到(i,j)的不同路径数
②dp\[i][j]=dp\[i - 1][j] + dp\[i][j - 1]
③dp\[i][0]和dp\[0][j]全为1
④由其左边和正上方的格子推导而来,所以从左到右一层层遍历

使用一维数组:
dp[i]先全初始化为1

二维数组中`dp[i][j]=dp[i - 1][j] + dp[i][j - 1]`
而若用一维滚动数组,一维数组中`dp[i]`本身就相当于上一层的`dp[i-1][j]`
再加上`dp[i-1]`(相当于`dp[i][j-1]`)得到的新`dp[i]`即相当于本层的`dp[i][j]`

```java
for (int j = 1; j < m; j++) {
    for (int i = 1; i < n; i++) {
        dp[i] += dp[i - 1];
    }
}
```

## 4.不同路径有障碍

https://leetcode-cn.com/problems/unique-paths-ii/

①dp\[i][j]:到(i,j)的不同路径数
②dp\[i][j]=dp\[i - 1][j] + dp\[i][j - 1],但若(i,j)为障碍则dp\[i][j]=0
③没有障碍dp\[i][0]和dp\[0][j]全为1,若遇到障碍,障碍及障碍之后的全为0
④由其左边和正上方的格子推导而来,所以从左到右一层层遍历

## 5.整数拆分

https://leetcode.cn/problems/integer-break/

①dp[i]:分拆数字i,可以得到的最大乘积
②i可由是`j*(i-j)`二者直接相乘得到,也可以由`j*dp[i-j]`(继续拆分`i-j`,最终大于2个数字相乘)
(因为dp[i]表示拆分数字i得到的最大乘积,所以的`dp[i-j]`不包括`i-j`本身!)
所以`dp[i]=max(dp[i],max(j*(i-j),j*dp[i-j])`(max中不仅有上面两者,还要和之前的dp[i]比较!)
③dp[2]=1(0和1没意义)
④**从i=3开始遍历,对于每个i,从1到i-1遍历j**
实际上j从1遍历到<=i/2即可

## 6.不同的二叉搜索树

https://leetcode-cn.com/problems/unique-binary-search-trees/

本题只考虑形状

n=1一种,n=2两种
n=3,dp[3]=元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点 搜索树的数量
元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
即`dp[3] = dp[2]*dp[0]+dp[1]*dp[1]+dp[0]*dp[2]`

①dp[i]1到i为节点组成的⼆叉搜索树的个数
②dp[i] += dp[j - 1] * dp[i - j]\(当共有i个节点且j为根节点,左边有j-1个节点,右边有i-j个)
③只需初始化dp[0]=1
④i从1开始遍历,每个i从1到i遍历j

# 3.0/1背包

## 1.基础01背包

有N件物品和⼀个最多能被重量为W 的背包,第i件物品的重量是weight[i],得到的价值是value[i],每件物品只能用⼀次,求解将哪些物品装入背包里物品价值总和最大

①dp\[i][j]表示从下标下标为0-i的物品中任意取放入容量为j的背包价值总和最大值
②dp\[i][j]=max(dp\[i-1][j],dp\[i-1][j-weight[i]]+value[i])
即两种情况:拿或者不拿这件(第i件)物品(拿物品需要`j>=weight[i]`)
③初始化,dp\[i][0]全为0,dp\[0][j],当j<weight[0]则为0,否则=value[0]
④两个嵌套for循环,先遍历物品或背包都行,先遍历物品更好理解

```java
for(int i=0;i<weight.length;i++){
    for(int j = 0; j <= bagWeight; j++){
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];//别忘了weight[i]>当前容量j时不更新!
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);}
    }
}
```

使用二维数组,两个for循环顺序可以颠倒

注意:dp数组如果用例内置数组,一定要设定值初始化,否则,数组内刚开始会是未定义的任意值

```c++
int dp[10];//错误,数组内为未定义的随机初始值
int dp[10] = {};//正确,默认为0
int dp[10]();//正确,默认为0
```

## 2.使用一维滚动数组

把上一层的dp[i-1]拷贝到dp[i]上
`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`
因价值都大于0,则都初始化为0即可
`dp[j]`表示容积为j的背包,所存物品的最大价值

遍历顺序与二维数组不同:
外层for遍历物品,从小到大,与二维相同
内层for遍历背包容量,**需要倒序遍历**,从大到小
因一维滚动数组得到dp[j]要依据本数组中前面的(`dp[j - weight[i]]`),所以若正序遍历,先改了前一个,会对后面的造成影响.
前面已经放了某物品后面继续放,导致一个物品被重复放入;而若倒序遍历,则可保证每个物品只放一个
相反,若用二维数组,其状态转移依据是上一层的前一个,本层前面的改了不会影响到后面的状态转移,所以无此限制
(本质还是二维数组遍历,且右下角的值依赖上一层左上角,因此要保证左边的值仍然是上一层的,所以从右向左覆盖)

**注意倒序遍历背包容量:`j >= weight[i]`**

```java
for(int i = 0; i < weight.size(); i++)
	for(int j = bagWeight; j >= weight[i]; j--) 
```

另外,使一维滚动数组,**两个for循环的嵌套顺序不能颠倒**
因一维dp的写法,背包容量一定要倒序遍历,而如果遍历背包容量放在上一层,**则每个dp[j]就只会放入一个物品**

> 更新dp数组依赖于前面的数据,如果使用一维滚动数组,外层循环遍历容量,且容量从后面开始遍历,则内层循环遍历商品时,dp[i]前面的数据还没有,所以每个dp[i]只能放入一件物品;相反,如果外层先遍历物品,在外层第二件及以后商品的循环过程中,内层倒序遍历容量时前面的数据已经有了前面外层遍历过的商品,可以在次基础更新dp[i],放入本次循环的商品

**补充:01背包问题递推公式总结**

①dp数组存储的是当前容量/总和下最大价值(形如原始背包问题)
则递推公式形如`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`
②dp数组存储的是构成当前容量/总和的总方法数(组合的数量)
则递推公式形如`dp[j] += dp[j - nums[i]]`(初始化dp[0]=1)
③dp数组存储的是构成当前容量/总和的物品的最多个数(最大子集大小)
则递推公式形如`dp[j] = max(dp[j], dp[j - weight[i]] + 1)`
(两种情况:是否把该元素加入子集,选择加入时加的是1而不是value[i])

## 3.分割等和子集

https://leetcode-cn.com/problems/partition-equal-subset-sum/

01背包,背包体积为数字总和的1/2(sum/2)
重量和价值都为数字的和
背包如果正好装满,说明找到了总和为 sum / 2 的子集

**当`dp[target]==target`的时候,背包就装满了**

①dp[i],容量i时,其中最大的子集总和
②dp[j]=max(dp[j],dp[j-nums[i]]+nums[i])
③dp[0]=0
④i遍历所有数字,j从背包最大(sum/2)到该数字的值nums[i],倒序遍历

最终如果dp[sum/2]==sum/2,则返回true
若dp[sum/2]<sum/2,则返回false

## 4.最后一块石头的重量Ⅱ

https://leetcode-cn.com/problems/last-stone-weight-ii/

**本题就是要尽量让石头分成重量接近的两堆,相撞之后剩下的石头最小,这样就化解成01背包问题了**

目标:要尽可能分成总和相同的两堆,背包大小target=sum/2
1.dp[j]表示容量为j的背包最多装dp[j]重量的石头
2.`dp[j] = max(dp[j], dp[j - weight[i]] + weight[i])`
3.题中石头数量1到30,大小1到1000,所以dp数组可以开成15*1000大小,全初始化为0
4.遍历石头,倒序遍历背包

最终一堆重量dp[target],另一堆sum-dp[target],因为向下取整,所以sum - dp[target] 一定>=dp[target]
那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]

## 5.目标和

假设给定nums[]中所有前面放加号的数字总和为x,则前面放减号的数字总和是sum - x
所以我们要求的是 x + [- (sum - x)] = x - (sum - x) = target
可得x = (target + sum) / 2,则此时会变成求背包中的物品是否可以相加得x

注意:若`(target + sum)%2!=0 `则本题无解
若sum<|target|,本题也无解

理论上可以使用回溯法暴力搜索,但会超时

可转化为01背包问题

dp数组含义:`dp[i]`表示可以用给定数字相加得到i的方法数
递推公式:`dp[j] += dp[j - nums[i]]`(如果选择了nums[i],则会有dp[j - nums[i]]种方法数)
由递推公式可知,dp[0] 一定要初始化为1,才能确保后面的结果正确

## 6.一和零

本题中strs 数组里的元素就是物品,每个物品只能选一次
而m 和 n相当于是一个背包,两个维度的背包,01背包,只是背包容量有两个维度,分别放0和1两种数字

`dp[i][j]`:最多有i个0和j个1的strs的最大子集的大小为`dp[i][j]`
递推公式:`dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);`

最外层是物品的循环,遍历所有的字符串,分别计算每个字符串中的0和1的数目
由于背包容量有两个维度,所以背包容量的循环有两层(每层都是从后往前)

## 7.兑换最小商品数量

小明同学在活动中获得了X积分,这些积分可以用来兑换商品
现有N种不同类型的商品并且每种商品的数量有限
编号为i的商品所需积分为points[i],对应的数量为counts[i]
如果小明想要恰好用完X积分来兑换商品,最少需要选择多少件商品?
如果无法恰好用X积分兑换商品,请返回-1

 `dp[j]` 表示使用恰好 `j` 积分所需的最小商品数量

```c
int minItemsToExchange(int X, const vector<int>& points, const vector<int>& counts) {
    // 初始化 DP 数组
    vector<int> dp(X + 1, numeric_limits<int>::max());
    dp[0] = 0; // 用 0 积分需要 0 件商品

    // 遍历每种商品
    for (size_t i = 0; i < points.size(); ++i) {
        int point_value = points[i];
        int max_count = counts[i];

        // 进行动态规划更新
        for (int j = X; j >= point_value; --j) {
            for (int k = 1; k <= max_count; ++k) {
                if (j >= k * point_value) {
                    if (dp[j - k * point_value] != numeric_limits<int>::max()) {
                        dp[j] = min(dp[j], dp[j - k * point_value] + k);
                    }
                }
            }
        }
    }

    // 返回结果
    return dp[X] == numeric_limits<int>::max() ? -1 : dp[X];
}

int main() {
    int X = 10; // 小明的积分
    vector<int> points = {2, 3, 5}; // 商品所需积分
    vector<int> counts = {3, 2, 1}; // 商品数量

    int result = minItemsToExchange(X, points, counts);
    cout << result << endl; // 输出结果

    return 0;
}
```

# 4.完全背包

## 1.基础完全背包

**每种物品有无限个**

与01背包的唯一区别就是遍历顺序不同

1.二维数组解决:
**决定要装当前物品时,状态转移不再依据上一层而是本层**

```java
for(int i=0;i<weight.size();i++){
    for(int j = 0; j <= bagWeight; j++){
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; 
        else dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);}
		// 区别:dp[i-1][j-weight[i]]改为dp[i][j-weight[i]]
    }
}
```

2.一维数组解决:
区别:可以添加多次,所以**内层背包容量的循环需要从小到大正序遍历**
**另外,别忘了j要>=weight[i]**

```java
for(int i = 0; i < weight.size(); i++) {
    for(int j = weight[i]; j <= bagWeight ; j++) {//别忘了j要>=weight[i]
    	dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

不同于01背包,纯完全背包两个for循环顺序可以颠倒(因为是从前往后遍历)
(实际题目可能不一定,要进一步变化)

```java
for(int j = 0; j <= bagWeight; j++) {
    for(int i = 0; i < weight.size(); i++) {
    	if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]]+ value[i]);
    }
}
```

**补充:完全背包递推公式的不同情况**

按照dp数组含义:①求最大价值,递推公式类似原始背包
②组合数③排列数:二者循环嵌套顺序不同,但递推公式都类似于`dp[j]+=dp[j-count[i]]`
④元素的最多或最少个数:`max(dp[j], dp[j - weight[i]] + 1)`或`min(dp[j], dp[j - weight[i]] + 1)`
初始化dp[0]=0;求max,dp数组其余位置初始化为小于物品最小值;求min,dp数组其余位置初始化为大于物品最大值

## 2.换零钱Ⅱ

https://leetcode-cn.com/problems/coin-change-2/

完全背包.数量不限求和

纯完全背包是凑成背包最大价值是多少,而本题是要求凑成总金额的物品组合个数
求的是组合数,不是排列数,不要求顺序,2,1,1和1,2,1是同一种组合方式
求方法数的递推公式,均类似于`dp[j]+=dp[j-count[i]]`

①dp[j]:组合数
②dp[j]+=dp[j-count[i]]
③dp[0]=1,其余全0(累加时无关项不会造成影响)
④迭代时两个for循环的顺序决定了得到的说组合数还是排列数

**外层遍历物品,内层遍历背包容量,统计的是组合数**
**外层遍历背包容量,内层遍历物品,统计的是排列数**

```java
for (int i = 0; i < coins.size(); i++) {
    for (int j = coins[i]; j <= amount; j++) {
    	dp[j] += dp[j - coins[i]];
    }
}
```

**另外:如果求的是排列数,可以用动规;**
**但如果要把每种排列的具体情况都求出来,只能用回溯算法爆搜**

**求排列数和组合数的区别:**

> dp[0]初始化为1,dp数组其余初始化为0
> 背包大小amount=6,物品数组coins={1,5}
>
> ①外层遍历物品,内层遍历背包容量,统计的是组合数
> (对于每个容量值来说,由于物品在外层遍历,所以放入物品的先后顺序已经被确定)
>
> ```c++
> for (int i = 0; i < coins.size(); i++) 
>  for (int j = coins[i]; j <= amount; j++) 
>  	dp[j] += dp[j - coins[i]];
> ```
>
> 遍历过程:
>     j: 0 1 2 3 4 5 6
>    1: 1 1 1 1 1 1 1
>    5: 1 1 1 1 1 2 2
>
> 因为只能先放1,再放5,因此对于dp[6]来说,1和5只有一种情况(不存在1,5和5,1两种不同情况),是组合数
> 而不是排列数(1,5和5,1看作两种情况)
>
> ②外层遍历背包容量,内层遍历物品,统计的是排列数
>
> ```c++
> for (int i = 1; i <= amount; i++) 
>  for (int j = 0; j < coins.size(); j++) 
>  	if(i>=coins[j]) dp[i] += dp[i - coins[j]];
> ```
>
> 遍历过程:
> 物品 i: 1 5
> dp[0]: 1 1
> dp[1]: 1 1
> dp[2]: 1 1
> dp[3]: 1 1
> dp[4]: 1 1
> dp[5]: 1 2
> dp[6]: 2 3
>
> 求dp[6]时,当物品为conins[0]=1时,dp[6]=0+dp[6-1]=dp[5]=2,
> 此时2包括了:①1,1,1,1,1,1②5,1两种排列方式
> (在dp[5]的基础上加1,dp[5]本身有2种组合方式,所以在dp[5]基础上加1也有2种)
> 而当物品为conins[1]=5时,dp+=dp[6-5]=2+dp[1]=3
> 加的1表示在dp[1]的基础上加5,即排列方式:1,5
> 由此可见,内层遍历物品,外层遍历容量,1,5和5,1是不同的情况

## 3.排列总和

https://leetcode-cn.com/problems/combination-sum-iv/

完全背包,数量不限求和
求排列数

①dp[j]:和为j的排列个数
②dp[i] += dp[i - nums[j]]
③dp[0]=1,其余全0(累加时无关项不会造成影响)
④外层遍历背包,内层遍历物品为排列数

## 4.爬楼梯Ⅱ

https://leetcode-cn.com/problems/climbing-stairs/

1阶,2阶,.... m阶就是物品,楼顶就是背包,每⼀阶可以重复使用,例如跳了1阶,还可以继续跳1阶
问跳到楼顶有几种方法其实就是问装满背包有几种方法
完全背包,数量不限求和,求的是排列数(1,2和2,1不是同一种方法)

①dp[j],到第j阶台阶方法数
②dp[i] += dp\[i - j](j为1,2,...m(每次走到阶数))
③dp[0]等于1,其余为0(除dp[0]外后面的都是推导得到的)
④target外循环,nums内循环

```java
for (int i = 1; i <= n; i++) { 
     for (int j = 1; j <= m; j++) { 
     	if (i - j >= 0) dp[i] += dp[i - j];//从第0阶开始
     }
}
```

## 5.换零钱

https://leetcode-cn.com/problems/coin-change/

要求硬币数量最少
**由于本题求的不是方法数,只是最少硬币的个数,所以不在乎是组合还是排列**

①dp[j]:凑成j最少的硬币个数
②`dp[j]=min(dp[j], dp[j-coins[i]]+1)`(看装或不装该枚硬币哪个总数量少)
③dp[0]=0,其余设一个较大值(为了初始化项不对min产生干扰)
④本题不在乎是组合还是排列,如可以coins放在外循环,target在内循环,都正序

注意:本题递推公式求最小,**所以初始化要是INT_MAX**,而不是0
另外,dp[0]要初始化为0,而不是1,因为dp是硬币数而不是方法数,0时硬币数也是0

**为了防止递推公式在+1时溢出**,需要在前面加上判断:
当`if(dp[j-coins[i]]!=INT_MAX)`时才执行min
(若等于INT_MAX,则意味着初始化后还未修改过,只比较那些已经被修改过的)
**(如果`dp[j-coins[i]`未修改过,等于INT_MAX,进行INT_MAX+1就会溢出)**

如果dp[amount]仍然等于INT_MAX,则没无法组成target

## 6.完全平方数

类似于上一题换零钱
完全平方数就是物品,刚开始初始化为INT_MAX
因为题目中完全平方数是从1开始,所以dp[0]初始化为0

> 为什么本题没有放溢出的判断:`if(dp[j-coins[i]]!=INT_MAX)`?
> ①上一题换零钱中,遍历coins时coins大小不定,内层循环从coins[i]开始
> dp[j-coins[i]]有可能是dp数组中还没处理的元素,其值为INT_MAX,**进行INT_MAX+1就会溢出**
> ②而本题中,物品是完全平方数.物品遍历从1开始,按递增顺序,所以,
> 内层循环从`j=i*i`开始,访问`dp[j-i*i]`时,`dp[j-i*i]`一定已经赋值过了,**一定不是INT_MAX**

```c++
for(int i=1;i*i<=n;i++){
    for(int j=i*i;j<=n;j++){
        dp[j] = min(dp[j],dp[j-i*i]+1);
    }
}
```

## 7.单词拆分

https://leetcode.cn/problems/word-break/description/

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict
判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词

单词就是物品,字符串s就是背包,单词能否组成字符串,就是物品能不能把背包装满
拆分时可以重复使用字典中的单词,说明就是一个完全背包问题

为了方便查找,把wordDict放在一个unordered_set里

dp[i]:当字符串长度为i,若dp[i]为true,表示从头开始长度为i的字符串可以拆成字典中出现的单词
递推公式为:`if(dp[j]==true && 子串[i,j]在字典中) dp[i]=true;`
为了让递推正常进行,dp[0]初始化为true,其余初始化为false

递推顺序:字符串有顺序,所以实际本题要按照求排列数确定顺序
所以背包容量在外层,内层为物品

> 例如: s = "applepenapple", wordDict = ["apple", "pen"]
> "apple","pen" 是物品,那么我们要求物品的组合一定是"apple" + "pen" + "apple"才能组成"applepenapple".若是"apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 则是不可以的

外层字符串长度为i,内层遍历物品时从j=0开始,检查是否满足:
字符串区间`[0,j]`可以拆分的同时区间`[j,i]`可被匹配到字典中的单词
**即不是直接遍历字典中的单词,而是遍历长度i字符串中的区间,检查其是否可以匹配某个单词**

当外层i循环到某个值时,内层循环要检查从开头开始,长度为i的字串是否满足可拆分的要求
内层循环从0到i遍历j,检查在子串区间[0,j]已符合要求的前提下,字典中是否有某个单词可匹配子串[i,j]
即检查是否可在前面某个匹配成功的结果基础上,再选用一个字典中的单词(物品)使字符串(0-i)符合要求

```c++
// 注意:以下两种递推公式写法不同,第二种是错误的!
// 第一种(正确):
if(dp[j]&&(dictSet.find(s.substr(j,i-j))!=dictSet.end()))
	dp[i] = true; 
// 第二种(错误):
dp[i] = dp[j]&&(dictSet.find(s.substr(j,i-j))!=dictSet.end());
// 第一种写法在dp[i]已被设为true(已确定可以匹配)后,不会把dp[i]改回false
// 但第二种写法有可能在dp[i]已确定可拆分后,再次把其改为false,导致错误
```

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dictSet(wordDict.begin(),wordDict.end());
        vector<bool> dp(s.size()+1,false);
        dp[0] = true;
        for(int i = 1;i<=s.size();i++){
            for(int j = 0;j<i;j++){
                if(dp[j]&&(dictSet.find(s.substr(j,i-j))!=dictSet.end())){
                    dp[i] = true; 
                }
            }
        }
        return dp[s.size()];
    }
};
```

# 5.小偷问题

## 1.线形房屋

当前房屋偷与不偷取决于前一个房屋和前两个房屋是否被偷了
因此,当前房屋是否偷与前面两个房屋是否偷过可形成递推关系

dp[i]表示从开始到第i间房(包括第i间房)可偷到的最大金额

dp[i]的递推公式有两种情况,这两种情况取最大:
如果不考虑偷上一间房(第i-1间),则第i间当前第i间可偷,dp[i] = dp[i-2] + nums[i]
如果考虑偷上一间(不一定真的偷),则本间(第i间)房和上一间相连,不能偷, 此时dp[i] = dp[i-1]
因此递推公式为`dp[i] = max(dp[i-2] + nums[i], dp[i-1]);`

dp数组初始化:由递推公式知需要初始化dp[0]和dp[1]
dp[0]=nums[0],dp[1] = max(nums[0],nums[1])

## 2.环形房屋

第一间房和最后一间房屋也是相邻的,构成环形

因此,第一间房和最后一间房会有以下三种情况:
①两者都不偷
②只偷第一间
③只偷最后一间
即第一间房和最后一间房不能同时考虑

所以对以下两个线性区间使用上一题的方法
①`[0,nums.size()-1]`(不考虑最后一间)
②`[1,nums.size()]`(不考虑第一间)

## 3.树形房屋

暴力递归

```c++
class Solution {
public:
    int rob(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return root->val;
        
        // 偷父节点
        int val1 = root->val;
        if (root->left) val1 += rob(root->left->left) + rob(root->left->right); 
        // 跳过root->left，相当于不考虑左孩子了
        if (root->right) val1 += rob(root->right->left) + rob(root->right->right); 
        // 跳过root->right，相当于不考虑右孩子了
        
        // 不偷父节点
        int val2 = rob(root->left) + rob(root->right); // 考虑root的左右孩子
        return max(val1, val2);
    }
};
```

以上代码超时,因为包含了重复计算

> 计算了root的四个孙子(左右孩子的孩子)为头结点的子树的情况,又计算了root的左右孩子为头结点的子树的情况,计算左右孩子的时候其实又把孙子计算了一遍

**树型DP**

本题一定是要后序遍历,因为通过两个子分支的递归函数返回值来做下一步计算
关键是要讨论当前节点抢还是不抢

如果抢了当前节点,两个孩子就不能动
如果没抢当前节点,就可以把左右孩子纳入考虑(不一定真的偷)

某节点的递归返回值:一个长度为2的数组,包含在偷与不偷该节点的情况下,分别可得的最大金钱
遇到空节点,则返回{0,0}

①偷本节点:本节点房屋的价值+左分支返回值中不偷左孩子的最大价值+右分支返回值中不偷右孩子的最大价值
②不偷本节点:左分支返回值中考虑左孩子的最大价值+右分支返回值中考虑右孩子的最大价值
本节点把两个值放入数组并返回

最终,对根节点返回数组的两个元素取最大,作为最终结果

# 6.股票问题

## 1.单次买卖

`dp[i][0]`表示第i天结束时持有股票,手头所拥有的最多现金
`dp[i][1]`表示第i天结束时不持有股票,手头所拥有的最多现金

**注意:题目限定了只能买一次和卖一次**,不能多次交易,因此dp数组表示的是单次交易花出去和净赚到的钱
所以`dp[i][0]`买入股票后钱是`-prices[i]`,而不是`dp[i-1][1]-prices[i]`,因为只能在一开始买一次,所以买的时候当前现金一定是0,不存在卖了,手上有一定现金,然后再买的情况;而`dp[i][0]`表示的是赚到的钱(即卖出价减买入价),而不只是卖出价,所以卖出的情况是`prices[i]-dp[i][0]`,而不只是`prices[i]`

当天持有股票的两种情况:①前一天已经持有②当天买入(之前没买)
`dp[i][0] = max(dp[i - 1][0], -prices[i]) `
(因为prices前有负 号,所以实际上取的是买入价较低的情况)

当天不持有股票的两种情况:①前一天已经不持有(之前已经卖出)②当天卖出
`dp[i][1] = max(dp[i-1][1], prices[i] + dp[i - 1][0])`
(dp数组表示持有的现金,买股票后是负的,所以用+号)

初始化:`dp[0][0]`表示第0天持有股票,所以`dp[0][0] = -prices[0]`
第0天不持有股票`dp[0][1] = 0`

## 2.尽可能多次买卖

题目规定不能同时参与多次交易,即再次购买前必须出售掉之前的股票

贪心:

按一天分割成很多天,把所有正的日利润累加即可

动规:

`dp[i][0]`表示第i天结束时持有股票,手头所拥有的最多现金
`dp[i][1]`表示第i天结束时不持有股票,手头所拥有的最多现金

不同于上一题只能买一次,因可以无限次买卖,所以当买入时手上可能已经持有了若干现金
所以`dp[i][0]`当天买入的情况要用前一天不持有股票时的现金去减去当天股票价格

`dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]) `
`dp[i][1] = max(dp[i-1][1], prices[i] + dp[i - 1][0])`

## 3.两次买卖

设置5个状态:

1. 没有进行过操作(可以不设置这个状态)
2. 第一次持有股票
3. 第一次不持有股票
4. 第二次持有股票
5. 第二次不持有股票

`dp[i][0] = dp[i-1][0]`
`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]) `
`dp[i][2] = max(dp[i - 1][2], prices[i] + dp[i - 1][1])`
`dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])`
`dp[i][4] = max(dp[i - 1][4], prices[i] + dp[i - 1][3])`

初始化:

第二次买入依赖于第一次的状态:
`dp[0][3]`第0天第二次买入,**相当于当天买入,卖出,再买入**
所以也和`dp[0][1]`初始化一样

`dp[0][1] = -prices[0]`
`dp[0][3] = -prices[0]`

## 4.k次买卖

和上面类似,定义一个二维数组`dp[i][j]`
第二维度(即状态个数) = `2*k+1`(即0 - 2k)

所有状态中,除了0以外,奇数就是买入,偶数就是卖出

```c++
//递推公式
for (int j = 0; j < 2 * k - 1; j += 2) {
    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
}
//初始化
for (int j = 1; j < 2 * k; j += 2) {
    dp[0][j] = -prices[0];
}
```

## 5.股票买卖有冷冻期

可尽可能多买卖,卖出股票后无法在第二天买入股票 (即冷冻期为 1 天)
两次交易需要[买入, 卖出, 冷冻期, 买入, 卖出]

规定4个状态:
(即把之前的卖出状态拆成三种状态,分别是刚卖出,冷冻期和冷冻期已过)
0:今天结束时持有股票
1:之前已卖出,卖出后没有再操作,且当前不处于冷冻期(所以至少是两天前卖出)
2:今天当天卖出(前一天结束时持有,今天结束时已卖出,不持有)
3:今天处于冷冻期
<img src=".\images\dp1.png" alt="dp1" style="zoom: 80%;" />

状态转变成买入状态(状态0);
①前一天就是买入状态(状态0) `dp[i][0]=dp[i-1][0]`
②前一天是冷冻期(状态3),今天买入`dp[i][0]=dp[i-1][3]-prices[i]`
③前一天是已卖出状态(状态2),今天买入`dp[i][0]=dp[i-1][2]-prices[i]`

`dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]);`

状态转变成卖出状态(状态1):
①前一天就是状态1`dp[i][1]=dp[i-1][1]`
②前一天是冷冻期(状态3)`dp[i][1]=dp[i-1`][3]

`dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);`

状态转变成今天卖出状态(状态2),之前只能是状态0买入状态
`dp[i][2] = dp[i - 1][0] + prices[i];`

状态转变成冷冻期状态(状态3),之前只能是当天卖出状态(状态2)
`dp[i][3] = dp[i - 1][2];`

dp数组初始化:

`dp[0][0]=-prices[i]`

最后结果是后三个状态(之前卖出状态拆成的三种状态)的最大者
`max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2]))`

## 6.股票买卖有手续费

类似于股票问题第二题
只是卖出股票的`dp[i][1]`递推公式略有区别,要减去手续费

```c++
dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
```

此外,由于不知道手续费是多少,**如果手续费很高,可能会出现`dp[size-1][0]>dp[size-1][1]`的情况**
所以最后`return max(dp[nums.size()-1][0],dp[nums.size()-1][1]);`

# 7.子序列问题

## 1.最长上升子序列

https://leetcode-cn.com/problems/longest-increasing-subsequence/

子序列:不一定连续,只要不改变相对顺序即可

1.dp[i]:i之前包括i的最长上升子序列
2.dp[i]等于j从0遍历到i-1过程中,以j结尾且满足nums[i]>nums[j]的最长升序子序列长度+1的最大值
`if(nums[i]>nums[j]) dp[i] = max(dp[i],dp[j]+1)`
3.每个都初始化为1
4.遍历顺序:嵌套for

最后结果取的是所有dp[i]中的最大值

## 2.最长连续递增序列

https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/

本题要求连续,所以只需比较前一个,而不用像上一题一样遍历比较从0到前一个的所有元素
`if(nums[i]>nums[i-1]) dp[i] = dp[i-1]+1;`
初始化为1

最后结果取的是所有dp[i]中的最大值

本题每个位置只和前一个位置有关,所以贪心也可以求解

遇到nums[i] > nums[i - 1]的情况,count就++,否则count重置为1
记录过程中count的最大值就可以了

```java
if (nums.length == 0) return 0;
int result = 1; // 连续⼦序列最少也是1
int count = 1;
for (int i = 0; i < nums.size() - 1; i++) {
    if (nums[i + 1] > nums[i]) { // 连续记录
        count++;
    } else { // 不连续，count从头开始
        count = 1;
    }
    if (count > result) result = count;
}
```

## 3.最长重复子数组

https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/

子数组即连续的子序列

**(1)使用二维数组**

用二维数组可以记录两个字符串的所有比较情况

1.dp\[i][j]两个维度分别表示:A以下标i-1为结尾的部分和B以下标j-1为结尾的部分,二者最长重复子数组长度
由此定义可知,i和j都要从1开始
(如果定义是以i结尾和以j结尾,可以,但初始化部分处理麻烦)

2.当A[i-1]==B[j-1]时,dp\[i][j]=dp\[i-1][j-1]+1

递推过程:
<img src=".\images\3.JPG" alt="3" style="zoom: 67%;" />

3.dp\[i][0]和dp\[0][j]没有意义,但要有初始值,初始化为0

4.两层for循环,一个A,一个B,都从1开始

因递推公式为dp\[i][j]=dp\[i-1][j-1]+1,为了编程实现简单,不在数组下标为0处特殊处理,设dp\[i][j]表示下标i-1和j-1的最长重复子串长度,下标从1开始遍历到A.size()(dp数组长度为A.size()+1),而不是定义dp是以i结尾和以j结尾

在遍历的过程中,记录最大的dp\[i][j]值

**(2)一维滚动数组**

因dp\[i][j]由dp\[i-1][j-1]推出,所以在一维数组中dp[i]由dp[i-1]推出
此时遍历B数组的时候,因为要依赖前面的元素,所以要从后向前遍历,避免被覆盖

注意:若A[i-1]==B[j-1],按递推公式赋值;但若不等于,则要赋值为0!

```java
int result = 0;
 for (int i = 1; i <= A.size(); i++) {
     for (int j = B.size(); j > 0; j--) {
         if (A[i - 1] == B[j - 1]) {
         	dp[j] = dp[j - 1] + 1;
         } else dp[j] = 0; // 注意这里不相等的时候要有赋0的操作
         if (dp[j] > result) result = dp[j];
     }
 }
```

## 4.最长公共子序列

https://leetcode.cn/problems/longest-common-subsequence/description/

子序列不一定是连续子序列,但要保持相对顺序

1.dp\[i][j]:以下标i-1为结尾的A,和以下标j-1为结尾的B,最长公共子序列长度
2.当`A[i-1]==B[j-1]`时,找到一个公共元素,`dp[i][j]=dp[i-1][j-1]+1`
当`A[i-1]!=B[j-1]`时,看①子串`text1[0, i-2]`与子串`text2[0, j-1]`的最长公共子序列;
②子串 `text1[0, i-1]`与子串`text2[0, j-2]`的最长公共子序列; 取二者最大的
即`dp[i][j]=max(dp[i-1][j],dp[i][j-1])`

> 查看以下二者的值,比较,取最大作为`dp[i][j]`
> ①s的0到i-1部分和t的0到j-2部分最长相同子序列长度
> ②s的0到i-2部分和t的0到j-1部分最长相同子序列长度

3.全初始化为0
4.由三个方向得来,需要从左到右,从上到下一层层遍历
<img src=".\images\2.JPG" alt="2" style="zoom:40%;" />

`for (int i = 1; i <= text1.size(); i++)`
`for (int j = 1; j <= text2.size(); j++)`

## 5.不相交的线

比较在A数组中用于连接的数字和在B数组中用于连接的数字
如果这两个数组中用于连接的数字满足**对应相同数字的相对位置相同**,则相同数字连线后不会相交
即,A数组中用于连接的数字和在B数组中用于连接的数字分别组成子序列,这两个子序列要相同

此时,寻找最多条不相交的线,就转化成了寻找两个数组的最长公共子序列长度

## 6.最大子序和

给定一个整数数组 nums
找到一个具有最大和的连续子数组,返回其最大和

**1.贪心解法**

从左向右遍历,不断累加子序和,当和<0时置0,从下一个元素重新开始
最后返回这一过程中记录到的子序和的最大值

注意遍历需要从下标0开始(开始时count=0),不能从下标1开始(开始时count=nums[0])
因为无法取到只取第二个(下标=1)的元素的情况

> 从下标0开始,刚开始和就是遍历的第一个元素nums[0];从下标1开始遍历,第一个得到的和是nums[0]+nums[1],而不是遍历的第一个元素nums[1],如和<0直接置0,无法做到只取nums[1]

**2.动态规划**

`dp[i]`记录下标0到i(包括i)的数组的最大子序和
递推公式有两种情况①之前的和加上当前数字**②从当前数字从头开始计算(=nums[i])**
即`dp[i] = max(dp[i-1]+nums[i],nums[i])`
初始化:`dp[0] = nums[0]`(由题意知子序最小长度为1,不能为0)

## 7.判断子序列

https://leetcode.cn/problems/is-subsequence/description/

给定字符串 s 和 t ,判断 s 是否为 t 的子序列
相同子序列:元素相对位置相同,可以不连续

> **如果是连续子序列,可直接用KMP算法,但子序列不一定要求连续**

`dp[i][j]`记录s字符串下标0到i-1部分和t字符串下标0到j-1部分相同子序列的长度
如果`s[i-1]==t[j-1]`,则`dp[i][j] = dp[i-1][j-1]+1`
如果`s[i-1]!=t[j-1]`,则`dp[i][j] = dp[i][j-1]`

> 注意:题目问的不是s和t的最长公共子序列,而是s是否是t的子序列
> 是s要完整地包含在t中,只需要**在t中找s,不用在s中找t**
> 所以`s[i-1]!=t[j-1]`时的递推公式不需要`dp[i-1][j]`

初始化:`dp[0][j]`和`dp[0][j]`都初始化为0
遍历顺序:因为`dp[i][j]`递推公式依赖的是二维数组中左上角+左边
所以从上到下,一层一层从左到右遍历

(如果只依赖左上角,才可以使用一维数组解决,否则只能使用二维数组)

最后如`dp[s.size()][t.size()] == s.size()`,则返回true

## 8.不同的子序列

https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html

给定一个字符串s和一个字符串 t,计算在s的子序列中t出现的个数

> 如果是连续子序列,可直接用KMP算法,但子序列不一定连续

`dp[i][j]`:s字符串下标0到i-1的部分的子序列中t字符串下标0到j-1部分出现的次数

当`s[i-1]==t[i-1]`时,因子序列不要求连续,有两种情况,**求的是个数,所以两种情况相加**
①使用s[i-1]进行匹配,`dp[i][j] = dp[i-1][j-1]`
②不使用s[i-1]进行匹配(忽略`s[i-1]==t[i-1]`]),`dp[i][j] = dp[i-1][j]`
所以当`s[i-1]==t[i-1]`时`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`

> 两种情况的例子: s = "abcc", t="abc"
> 当i=4,j=3时,s字符串下标0到3的部分与t下标0到2的部分匹配
> 可与t匹配的s子序列有两种情况,即使用s[3]与不使用s[3]
> ①使用s[3],s的子序列s[0]s[1]s[3]与t匹配
> ②不使用s[3],(忽略s[3]=t[2]),s的子序列s[0]s[1]s[2]与t匹配

当不相等时,`dp[i][j] = dp[i - 1][j]`

初始化:`dp[0][j]`初始化为0(不包括j=0时的情况)
`dp[i][0]=1`,因为s下标0到i-1部分的子序列和空字符串匹配,**空字符串也是s的一个子序列**
特别地,`dp[0][0]=1`,因为空字符串也是空字符串的子序列

遍历顺序:因为`dp[i][j]`递推公式依赖左上角+上边
所以同样从上到下,从左到右按层遍历

## 9.两个字符串删除操作

有两个单词word和word2,找到使word1和word2相同所需最小步数,每步可删除任意一个字符串中一个字符

`dp[i][j]`记录word的下标0到i-1部分和word2的下标0到j-1部分要达到相等需要删除最少次数

当`word[i-1]==word2[j-1]`时,`dp[i][j]=dp[i-1][j-1]`
当`word[i-1]!=word2[j-1]`时,有3种情况需要考虑,取一下三种情况最小值:
①删除word[i-1],`dp[i][j]=dp[i-1][j]+1`
②删除word2[j-1],`dp[i][j]=dp[i][j-1]+1`
③同时删除word[i-1]和word2[j-1],`dp[i][j]=dp[i-1][j-1]+2`
因为③可以等同于先①后②,所以情况③可以合并进前两种情况中
所以不等于时,`dp[i][j] = min(dp[i-1][j],dp[i][j-1])+1`

初始化:`dp[0][j]=j`(删除j次成为空字符串),`dp[i][0]=i`
遍历顺序:从上到下,从左到右按层遍历

## 10.编辑距离

两个单词 word1 和 word2,计算出 word1 转换成 word2 所使用的最少操作数
可对这两个单词进行的操作:①插入②删除③替换

`dp[i][j]`记录word1的下标0到i-1部分和word2的下标0到j-1部分要达到相等需要最少操作数
当`word1[i-1]==word2[j-1]`时,`dp[i][j]=dp[i-1][j-1]`

当`word1[i-1]!=word2[j-1]`时,
①先考虑删除操作,同上一题,`dp[i][j] = min(dp[i-1][j],dp[i][j-1])+1`
②插入操作,word2增加一个元素,等价与word1删除一个元素,所以不需要另外考虑

> 如word1 = "ad", word2 = "a",在word2后面增加一个d同时在word1后面删除一个d
> 最终得到两个字符串仍为"a"和"ad",说明就操作数而言,插入和另一个单词删除等价

③替换操作`dp[i][j] = dp[i-1][j-1] + 1`

所以最终当不等于时,`dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1`

初始化:`dp[0][j]=j,dp[i][0]=i`
遍历顺序:从上到下,从左到右按层遍历

## 11.回文子串

**动态规划方法**

判断长度为5的字符串S是否回文,如知道 s[1],s[2],s[3] 这个子串是回文的,则只需比较 s[0]和s[4]
如果s[0]和s[4]相同,这个长度为5的字符串 S 就是回文串

所以,要判断一个下标范围[i,j]的子串是否为回文,依赖于标范围[i+1,j-1]的子串是否为回文
布尔类型`dp[i][j]`表示区间范围[i,j]的子串是否是回文,如果是`dp[i][j]`为true,否则为false

寻找递推关系:

1.`s[i]!=s[j]`时,`dp[i][j]=false`
2.`s[i]==s[j]`时,有三种情况:
①`i==j`,即子串只有一个字符,一定是,`dp[i][j]=true`
②j和i相差1,即子串只有2个相同字符,一定是,`dp[i][j]=true`
③不是以上两种情况,则依赖于`dp[i+1][j-1]`,`dp[i][j]=dp[i+1][j-1]`

初始化:均为false
遍历顺序:由于`dp[i][j]`依赖二维数组的左下角
所以从下到上,从左到右遍历(或者先列后行也行)

**双指针法**

动态规划方法空间复杂度偏高,可使用双指针法(空间复杂度O(1))

从前到后遍历字符串,用当前遍历到的字符作为回文子串中心
中心有两种情况①中心有一个字符(i)②中心有两个字符(i,i+1)
从中心开始同时向两边扩展,扩展过程中每当两边字符相同,则找到一个回文子串,数量+1

```c++
int countSubstrings(string s) {
    int result = 0;
    for (int i = 0; i < s.size(); i++) {
        result += extend(s, i, i, s.size()); // 以i为中心
        result += extend(s, i, i + 1, s.size()); // 以i和i+1为中心
    }
    return result;
}
int extend(const string& s, int i, int j, int n) {
    int res = 0;
    while (i >= 0 && j < n && s[i] == s[j]) {
        i--;
        j++;
        res++;
    }
    return res;
}
```

## 12.最长回文子序列

给定一个字符串 s,找到其中最长的回文子序列,并返回该序列的长度
和上一题不一样,注意此处求的回文子序列不一定连续!

`dp[i][j]`记录字符串s在[i, j]范围内最长的回文子序列的长度

若`s[i]==s[j]`,`dp[i][j] = dp[i+1][j-1]+2`(因为不要求连续,所以可以+2)
若`s[i]!=s[j]`,`dp[i][j]`有两种情况,取二者max
①子序列不考虑`s[i]`,即只加入s[j],此时`dp[i][j]=dp[i+1][j]`
①子序列不考虑`s[j]`,,即只加入s[i],此时`dp[i][j]=dp[i][j-1]`

初始化:全初始化为0(可以先初始化所有`dp[i][i]=1`,也可遍历中再赋值)
遍历顺序:从下到上,从左到右遍历

```c++
int longestPalindromeSubseq(string s) {
    vector<vector<int>> dp(s.size(),vector<int>(s.size(),0));
    for(int i=s.size()-1;i>=0;i--){
        for(int j=i;j<s.size();j++){
            if(s[i]==s[j]){
                if(j==i) dp[i][j] = 1;
                else dp[i][j] = dp[i+1][j-1] + 2;
            }
            else{
                dp[i][j] = max(dp[i+1][j],dp[i][j-1]);
                //因为j从i开始遍历,所以当i=s.size()-1和0且j=i时,不用担心入此分支导致下标越界
            }
        }
    }
    return dp[0][s.size()-1];
}
```

## 13.最长不重复子串

**1.滑动窗口**

窗口右边不和窗口中的重复,窗口向右扩大,加入set 窗口右边和窗口中的重复,从左边缩小窗口 直到窗口中和窗口右边相同的那个元素离开窗口

**2.DP**

dp状态定义:以i下标元素为结尾字符的无重复数字的子集合最大长度
遍历到 arr[j] 时,初始化索引 i = j - 1,向左遍历搜索第一个满足 s[i] = s[j] 的数字即可

```c++
public int maxLength (int[] arr) {
    // write code here
    int res = 0, tmp = 0;
    for(int j = 0; j < arr.length; j++) {
        int i = j - 1;
        while(i >= 0 && arr[i] != arr[j]) i--; // 遍历查找 i
        tmp = tmp < j - i ? tmp + 1 : j - i; // dp[j - 1] -> dp[j]
        res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
    }
    return res;
}
```

**3.哈希+双指针**

```c++
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> dic = new HashMap<>();
        int i = -1, res = 0;
        for(int j = 0; j < s.length(); j++) {
            if(dic.containsKey(s.charAt(j)))
                i = Math.max(i, dic.get(s.charAt(j))); // 更新左指针 i
            dic.put(s.charAt(j), j); // 哈希表记录
            res = Math.max(res, j - i); // 更新结果
        }
        return res;
    }
}
```
