## 1.并查集理论

并查集常用来解决连通性问题
即,需要判断两个元素是否都在同一个集合里的时候,就要想到用并查集

并查集主要有两个功能:
①判断两个元素是否都在同一个集合内(both)
②如果不是都在同一个集合内,将两个元素添加到集合中

用map,set,数组管理集合,实现以上功能,复杂且代价高

将3个元素A,B,C放在同一个集合,相当于把3个元素联通在一起(有向连通图)
只需要用一个一维数组表示:`father[A] = B,father[B] = C `

检查A和B是否在一个集合内,不在则加入:
①如A和B在图中可以联通,则在同一个集合内,不用加入,直接返回
②如A和B在图中无法联通,则不同时在该集合内,需要通过设置A和B联通来让A和B都存在于该集合中

只知道A联通B,无法知道B联通A?
我们的目的是判断这三个元素是否在同一个集合里,知道 A 连通 B 就已经足够了

find函数向上递归寻找根,直到找到最开始的根

另外,为了表示到达根,停止递归,以及判断根节点自己是否在集合中:
需要在开始把father数组初始化为自己指向自己`father[i]=i;`

```c++
// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 将v,u这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return; // 如果发现根相同,则说明在一个集合,不用两个节点相连直接返回
    father[v] = u;
}
// 判断u,v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}
// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u; // 如果根就是自己,直接返回
    else return find(father[u]); // 如果根不是自己,就根据数组下标一层一层找
}
```

**路径压缩**

搜索根的过程像是一个多叉树中从叶子到根节点的过程
如果这棵多叉树高度很深的话,每次find函数去寻找跟的过程就要递归很多次:
<img src=".\images\13.JPG" alt="13" style="zoom:67%;" />

我们的目的只需知道这些节点在同一个根下就行,所以对这棵多叉树的构造只需如图这样就可:
(即除了根节点,其他所有节点都挂载根节点下,这样我们在寻根的时候就只需要一步)
<img src=".\images\14.JPG" alt="14" style="zoom:67%;" />

想达到这样的效果,就需要路径压缩,将非根节点的所有节点直接指向根节点
只需要在递归的过程中,让 father[u] 接住 递归函数 find(father[u]) 的返回结果,即

```c++
// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u;
    else return father[u] = find(father[u]); // 路径压缩
}// 在递归返回的过程中,把一整条向上搜索路径上经过的结点的父结点都改为根节点
// 用三元表达式来精简一下:
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]);
}
```

**并查集代码模板**

```c++
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0);

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

**注意事项:**

join函数代码中前两行不能用`isSame`代替

```c++
// 以下实现是错误的:
void join(int u, int v) {
    if (isSame) return;
    father[v] = u;
}
```

原因是,在正确的join代码中,接受的u和v都需要先寻根
最后如不同时在集合中,设置father时,是让**寻找到的v的根结点指向寻找到的u的根结点**!
而如果使用`isSame`代替寻根过程,最后会错误地变成直接让v指向u, 而这种写法可能会让本来应该联通(拥有公共根)的两个结点不连通,从而被错误地判断不同时在集合中(实际上都在集合中)

依次调用`join(1,2)`和`join(3,2)`,错误和正确的版本生成的有向图分别如下:
<img src=.\images\15.jpg" alt="15" style="zoom: 67%;" />

前者错误,之后调用`isSame(1,3)`,找不到公共根,得到1和3不同时在集合中的错误结果
后者正确,在`join(3,2)`时,与3连接的是2的根1,而不是2自己,这样1和3有公共根3

**时间复杂度**

路径压缩后的并查集时间复杂度在O(logn)与O(1)之间
随着查询或者合并操作的增加,时间复杂度会越来越趋于O(1)

## 2.寻找图中是否存在路径

n个顶点的**双向**图,二维数组给出图中所有双向边,并给定start和end,求是否有start到end的有效路径

**因为是双向图,所以可以转化成2个元素是否在同一集合中的并查集问题**
(有向图不行,如果是有向图,则只能使用DFS/BFS)

①遍历给定存储边的二维数组,join到并查集中:
`join(edges[i][0], edges[i][1]);`

②`return isSame(source, destination);`

## 3.冗余连接

往一棵树中添加一条额外的边
请找出一条可以删去的边,删除后可使得剩余部分是一个有着 n 个节点的树
如果有多个答案,则返回给定数组 edges 中最后出现的边

树可以看成是一个连通且无环的无向图
一棵树添加一条额外的边后,即会形成无向环

从左到右遍历给定的每一条边:(因为端点相同的两条边先后加入并查集,被发现多余的是后加入的边,因为题目要求要找数组最后出现的边,所以从左到右遍历)
①边不在当前集合(并查集)中,调用join加入并查集
②边两个端点已经同时在并查集中,则如果此边再加入,就会形成无向环,所以这条边就是所求的边

## 4.冗余连接Ⅱ

上一题的有向图版本

1.先统计是否有入度=2的节点,有的话获取其的这两条"入边"

2.多一条边,有2种情况:
**①有入度为2的结点**
那么一定是入度为2的结点两条入边里删一条边,看删哪个可以构成树
判断删除后能否构成树:使用并查集,把除了指定要删除的边以外的其他边加入并查集
若加入过程中,并查集中仍然出现了环(加入前两个端点已在图中),则要删的不是这条边,是另一条

**②没有入度为2的情况,那么一定有向环**,找到构成环的边就是要删除的边
获取构成环的边:使用并查集,把所有边依次加入并查集
若加入某条边会让并查集中出现环(加入前两个端点已在图中),则有环,返回这条边

- 入度为2的情况,答案在两条入边中,确定答案:去掉其中一条入边,用并查集判断剩下的是否是树;
- 有环的情况,可直接用并查集找出多余的一条边

> 注意1<=n,=1000,数组要开1001,而不是1000
>
> 注意:如果3<=n<=1000,若干个n存储在一个vector e内,且需要建立一个使用n作为索引的vector
> 则这个新vector的大小是1001,而不是e.size()
>
> 若vector作为(在函数外的)类的数据成员,而不是在函数中创建
> 则不能写`vector<int> dp(n,0);`其是类的数据成员,不是执行的语句,不能这样初始化
> 应该`vector<int> dp = vector<int>(n,0);`

**代码:**

```c++
class Solution {
private:
    int father[1001];
    void init() {
        for (int i=0; i<=1000; i++) {
            father[i] = i;
        }
    }
    int find(int u) {
      return u == father[u] ? u : father[u] = find(father[u]);  
    }
    bool hasEdge(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) {
            return;
        }
        father[v] = u;
    }
public:
    bool isTreeAfterRemoveEdge(vector<vector<int>>& edges, int edge) {
        for (int i=0; i<edges.size(); i++) {
            if (i == edge) {
                continue;
            }
            if (hasEdge(edges[i][0],edges[i][1])) {
                return false;
            }
            join(edges[i][0],edges[i][1]);
        }
        return true;
    }
    vector<int> getEdge(vector<vector<int>>& edges) {
        for (int i=0; i<edges.size(); i++) {
            if (hasEdge(edges[i][0],edges[i][1])) {
                return edges[i];
            }
            join(edges[i][0],edges[i][1]);
        }
        return {};
    }
    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        init();
        vector<int> indgree(edges.size()+1,0);
        vector<int> twoinedge;
        for (vector<int> e : edges) {
            indgree[e[1]]++;
        }
        for (int i = edges.size()-1; i>=0; i--) {
            if (indgree[edges[i][1]] == 2) {
                twoinedge.push_back(i);
            }
        }
        if (twoinedge.size() > 0) {
            if (isTreeAfterRemoveEdge(edges,twoinedge[0])) {
                return edges[twoinedge[0]];
            } else {
                return edges[twoinedge[1]];
            }
        }

        return getEdge(edges);
    }
};
```

