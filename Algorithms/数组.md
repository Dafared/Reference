## 1.二分查找

按照区间定义,循环条件有两种写法

①左闭右闭区间: `while(left <= right)` (因为left == right 是有意义的)
另外,`if (nums[middle] > target)` right 要赋值为 middle - 1,因为当前这个nums[middle]一定不是target,那么接下来要查找的左区间结束下标位置就是 middle - 1

②左闭右开区间: `while(left < right)`
`if (nums[middle] > target)` right 要赋值为 middle
(因为下次寻找的左闭右开区间[left,right)不包括middle)

另外,为防止溢出,mid求法:`mid = left + (right - left)/2;`

左闭右闭为例:

```c++
class Solution {
public:
	int search(vector<int>& nums, int target) {
    	int left = 0;
        int right = nums.size()-1;
        while (left <= right) {
            int middle = (left + right)/2;
            if (target == nums[middle]) {
                return middle;
			}
            if (target > nums[middle]) {
                left = middle + 1;
            }
            if (target < nums[middle]) {
                right = middle - 1;
            }
        }
    }
};
```

### 寻找插入位置

若寻找target不存在,退出循环时插入位置在left处

```c++
int searchInsert(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size()-1;
    while (left <= right) {
        int middle = (left+right)/2;
        if (target == nums[middle]) {
            return middle;
        }
        if (target > nums[middle]) {
            left = middle + 1;
        }
        if (target < nums[middle]) {
            right = middle - 1;
        }
    }
    return left;
}
```

### (非递减)数组求某元素左右边界

**方法一:二分查找寻找左边界和右边界**

可分为三种情况:
情况一:target在数组中不存在,且不在数组的范围内
(即target小于数组最小值或大于数组最大值)
情况二:target在数组中不存在,但在数组的范围内
(即target大于数组最小值且小于数组最大值)
情况三:target在数组中存在

**寻找右边界**

当`nums[mid] <= target`, `left = mid + 1;`
当`nums[mid] > target`,`right = mid - 1;`

在二分查找中,如果目标元素target存在,一定会在某时刻得到nums[mid] == target;
之后,若nums[mid] <= target时更新left指针为mid+1
即只要nums[mid] == target, left指针会不断右移
left指针最后被更新的位置即为目标元素target的右边界(**开区间,不包括target的右边界**)
每次更新left时,同时更新一下rightbound变量,如果left(rightbound)一直没被更新过,则说明target小于数组最小值(不在数组范围内),为情况一

**寻找左边界**

当`nums[mid] < target`, `left = mid + 1;`
当`nums[mid] >= target`,`right = mid - 1;`

在二分查找中,如果目标元素target存在,一定会在某时刻得到nums[mid] == target;
之后,若nums[mid] >= target,更新right指针为mid-1
即只要nums[mid] == target, right指针会不断左移
right指针最后被更新的位置即为目标元素target的左边界(**开区间,不包括target的左边界**)
每次更新right时,同时更新一下leftbound变量,如果right(leftbound)一直没被更新过,则说明target大于数组最大值(不在数组范围内),为情况一

如果得到左边界和右边界后,左右边界的变量都被更新过,但`rightbound-leftbound<=1`,则target大于数组最小值且小于数组最大值,但不存在于数组中(为情况二)(注意rightbound和leftbound为不包括target的边界,(开区间边界),所以需要`rightbound-leftbound>1`)

如果不是情况一和情况二,则target在数组中存在且找到其左边界和右边界
注意返回的区间边界为包括target的边界`{leftbound+1,rightbound-1}`
(返回的是闭区间)

代码如下:

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left_bound = FindLeftBound(nums, target);
        int right_bound = FindRightBound(nums, target);
        if (left_bound != -2 && right_bound != -2) {
            if (right_bound - left_bound > 1) {
                return {left_bound+1,right_bound-1};
            }
        }
        return {-1,-1};
    }
    int FindLeftBound(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int left_bound = -2; // -2表示未更新过
        while (left <= right) {
            int mid = (right+left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1;
                left_bound = right;
            } else {
                left = mid + 1;
            }
        }
        return left_bound;
    }
    int FindRightBound(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int right_bound = -2; // -2表示未更新过
        while (left <= right) {
            int mid = (right+left) / 2;
            if (nums[mid] <= target) {
                left = mid + 1;
                right_bound = left;
            } else {
                right = mid - 1;
            }
        }
        return right_bound;    
    }
};
```

**方法二**

先用二分查找找到其中一个target
然后向左右分别扩展,寻找target的左右边界

### X的平方根

三种情况
如果这个整数的平方 **恰好等于** 输入整数,那么我们就找到了这个整数；
如果这个整数的平方 **严格大于** 输入整数,那么这个整数肯定不是我们要找的那个数；
如果这个整数的平方 **严格小于** 输入整数,那么这个整数 **可能** 是我们要找的那个数

可以使用二分查找寻找满足X^2<=target的"**最大的X**"
即**循环结束时的`right`**

二分循环过程中:
①mid > x/mid
②mid = x/mid
③mid < x/mid

另外,因为除0和1外,**一个整数的平方根不会大于大的一半**
所以除了01单独判断外,**需要二分查找的区间为[1,target/2]**

```c++
int mySqrt(int x) {
    if (x==0 || x==1) {
        return x;
    }
    int left = 1;
    int right = x/2;
    while(left <= right) {
        int mid = (left + right) /2;
        if (mid == x/mid) {
            return mid;
        }
        if (mid < x/mid) {
            left = mid+1;
        } else {
            right = mid-1;
        }
    }
    return right;
}
```

## 2.双指针

**非有序数组**
删除后,需要把右边的元素往左移动,填补被删掉的元素位置

### 移除元素

通过快慢指针在一个for中完成2个嵌套for循环的工作

快指针: 遍历整个原数组
慢指针: 遍历范围为删除元素后的新数组(给新数组添加元素)

快指针每次前进一步
当快指针当前走到不是要删除的元素时,把当前快指针处元素移动到慢指针处,,慢指针也+1
当快指针当前走到要删除的元素时,慢指针不动,且不把当前快指针处元素复制到慢指针位置(快指针依旧+1)

**相向双指针方法**

使用限定条件:题目说了"元素的顺序可以改变"
相向双指针方法可以保证**移动次数最少**

若要删除的元素为val
①找从当前left开始第一个等于val(要删除)的元素
②找从当前right开始第一个不等于val的元素
③用右边不等于val的元素覆盖左边等于val的元素,之后left和right分别相向移动一格
`nums[leftIndex++] = nums[rightIndex--];`

```c++
int left = 0;
int right = nums.size()-1;
while (left <= right) {
    while (left <= right && nums[left] != val) {
        left++;
    }
    while (left <= right && nums[right] == val) {
        right--;
    }
    if (left < right) {
        nums[left++] = nums[right--];
    }
}
return left;
```

### 移动零

给定一个数组 nums,编写一个函数将所有 0 移动到数组的末尾,同时保持非零元素的相对顺序

同样采用上面题目的双指针法(**要保持相对顺序,所以不能用相向双指针法**)
(不同于上面删除,在移动结束后还要**把后面的多余元素赋值为0**)

### 删除非递减数组内重复项

①unordered_set+双指针

可优化,因为是非递减数组

②考虑有序数组

有序数组,重复元素总是连续

设初始fastindex在slowindex下一个位置
从下标0到slowindex为已经找到的若干个不重复元素,即下一个找到的不重复的元素要放在slowindex+1位置

`if (nums[slowindex] != nums[fastindex])`:说明fastindex当前走到的元素不和之前重复
令`nums[++slowindex] = nums[fastindex]`

`if (nums[slowindex] == nums[fastindex])`:说明fastindex当前走到的元素和之前已经找到的重复
则不把当前fastindex处的元素添加到数组前部的非重复元素中,只让fastindex++,看下一个元素即可

**和删除元素的区别:**

删除元素只需要比较`nums[fastindex]`和给定的要删除元素
若不是要删除的元素,直接保存在当前slowindex处

但删除有序数组重复项需要**比较`nums[fastindex]`和下标slowindex处元素**
若不是重复元素,**保存在slowindex+1处**

**即慢指针slowindex的含义不同!**
删除元素:慢指针slowindex表示快指针下一个走到的不删除的元素的存储位置
删重复元素:慢指针slowindex表示上一次找到的不重复元素,新的不重复元素要存在slowindex+1处

### 比较含退格的字符串

分别用双指针去掉s和t的#
然后比较s和t是否相等

快指针遇到#后慢指针不是不动,而是后退一格

使用双指针和栈时间复杂度都是O(m+n)
但双指针的空间复杂度为O(1),栈的空间复杂度为O(m+n)

```c++
bool backspaceCompare(string s, string t) {
    int sSlow = 0;
    int sFast = 0;
    int tSlow = 0;
    int tFast = 0;
    while (sFast < s.size()) {
        if (s[sFast] != '#') {
            s[sSlow] = s[sFast];
            sSlow++;
        } else {
            if (sSlow != 0) {
                sSlow--;
            }
        }
        sFast++;
    }
    while (tFast < t.size()) {
        if (t[tFast] != '#') {
            t[tSlow] = t[tFast];
            tSlow++;
        } else {
            if (tSlow != 0) {
                tSlow--;
            }
        }
        tFast++;
    }
    if (sSlow != tSlow) {
        return false;
    }
    for (int i=0; i<tSlow; i++) {
        if (s[i]!=t[i]) {
            return false;
        }
    }
    return true;
}
```

### 有序数组的平方

给非递减顺序的整数数组,求每个数的平方组成的新数组,要求新数组也非递减

双指针法,两个指针从分别两侧开始往中间移动
(`while (left <= right)`)

## 3.滑动窗口

### 和大于s的长度最小子数组

找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组, 返回长度

滑动窗口:不断的调节子序列的起始位置和终止位置,从而得出我们要想的结果
暴力解法:2个嵌套for,滑动窗口:一个for即可
(也可看做是双指针法的一种)

**用滑动窗口的终止位置作为for循环遍历的索引**

窗口内是目前找到的满足总和 ≥ s 的长度最小的连续子数组

窗口起始位置的移动:每次在窗口终止位置随着for循环向右移动一位,把终止位置数字加到窗口内子数组总和sum上后,如发现窗口内子数组的**当前和>=s**,记录当前窗口的长度,窗口起始位置向前移动一位(**缩小窗口**)

每次窗口起始位置向右移动一位,窗口缩小后:
如果窗口内和仍大于等于s,更新窗口最小长度和总和sum,并继续尝试右移起始位置,缩小窗口
如果窗口内和不再大于等于s,停止缩小窗口,进行下一轮for循环,右边窗口终止位置右移一位(扩大窗口)

> 滑动窗口精妙之处在于**根据当前子序列和大小的情况,不断调节子序列的起始位置**
> **将O(n^2)暴力解法降为O(n)**

```c++
int minSubArrayLen(int target, vector<int>& nums) {
    int left = 0;
    int sum = 0;
    int sublength = 0;
    int result = INT32_MAX;
    for (int right = 0; right < nums.size(); right++) {
        sum += nums[right];
        while (sum >= target) {
            sublength = right - left + 1;
            result = result < sublength ? result : sublength;
            sum -= nums[left++];
        }
    }
    return result == INT32_MAX ? 0:result;
}
```

### 水果成篮

Leetcode:904

自己写:滑动窗口
当遇到除当前两个篮子中两种水果外的第三种水果
滑动窗口左边起始位置右移,直到当前篮子两种水果中某种水果数量归0

使用哈希表记录当前拥有的水果种类和对应的数量

```c++
int totalFruit(vector<int>& fruits) {
    unordered_map<int,int> bucket;
    int left = 0;
    int sum = 0;
    int res = 0;
    for (int i=0; i<fruits.size(); i++) {
        bucket[fruits[i]]++;
        sum++;
        while (bucket.size()>2) {
            bucket[fruits[left]]--;
            sum--;
            if(bucket[fruits[left]]==0){
                bucket.erase(fruits[left]);
            }
            left++;                
        }
        res = max(res,sum);
    }
    return res;
}
```

### 最小覆盖子串

1.自己写:2个哈希表+滑动窗口:
**超时**

超时的代码:

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        int left = 0;
        std::unordered_map<char,int> char_in_t;
        std::unordered_map<char,int> char_in_s;
        int result_left,result_right;
        int min_length = INT32_MAX;
        // 统计t中字符及各自的数量
        for (char c : t) {
            if (char_in_t.find(c) == char_in_t.end()) {
                char_in_t[c] = 0;
            }
            char_in_t[c]++;
        }
        // 对s使用滑动窗口
        for (int right = 0; right < s.size(); right++) {
            // 如s[right]存在于t中,用char_in_s统计该字符在s中的数量
            if (char_in_t.find(s[right]) != char_in_t.end()) {
                char_in_s[s[right]] ++;
            }
            // 判断滑动窗口中字符串是否符合要求
            while (judge(char_in_t,char_in_s)) {
                int sublength = right - left + 1;
                if (min_length > sublength) {
                    min_length = sublength;
                    result_left = left;
                    result_right = right;
                }            
                if (char_in_t.find(s[left]) != char_in_t.end()) {
                    char_in_s[s[left]]--; 
                }
                left++;
            }
        }
        if(min_length == INT32_MAX) {
            return "";
        }
        return s.substr(result_left,result_right-result_left+1);
    }
    bool judge(std::unordered_map<char,int> &char_in_t, 
               std::unordered_map<char,int> &char_in_s) {
        if (char_in_s.size() != char_in_t.size()) {
            return false;
        }
        for (auto pair : char_in_t) {
            if (pair.second > char_in_s[pair.first]) {
                return false;
            }
        }
        return true;
    }
};
```

**优化版本**

优化:当窗口缩小时,判断窗口内字符串是否符合条件:不再使用judge函数
①窗口缩小时被移出窗口的最左边字符不是t中字符:
移除该字符不影响窗口内字符串符合条件,无需判断,直接让left++即可
②窗口缩小时被移出窗口的最左边字符是t中字符:
只需检查两个哈希表中该字符**对应的数量**即可,无需用judge检查所有字符

原来超时代码中,judge函数作为while循环条件,每次窗口缩小时调用judge函数判断代价太大
新代码中,judge函数只用于每次for循环窗口结束位置右移,窗口扩大时判断

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        int left = 0;
        std::unordered_map<char,int> char_in_t;
        std::unordered_map<char,int> char_in_s;
        int result_left,result_right;
        int min_length = INT32_MAX;
        for (char c : t) {
            if (char_in_t.find(c) == char_in_t.end()) {
                char_in_t[c] = 0;
            }
            char_in_t[c]++;
        }
        for (int right = 0; right < s.size(); right++) {
            if (char_in_t.find(s[right]) != char_in_t.end()) {
                char_in_s[s[right]] ++;
            }
            if (judge(char_in_t,char_in_s)) {
                while (true) {
                    int sublength = right - left + 1;
                    if (min_length > sublength) {
                        min_length = sublength;
                        result_left = left;
                        result_right = right;
                    }
                    // 从左边缩小窗口
                    if (char_in_t.find(s[left]) != char_in_t.end()) {
                        char_in_s[s[left]]--;
                        if(char_in_s[s[left]] < char_in_t[s[left]]) {
                            // 此时窗口内字母已无法构成t
                            if (char_in_s[s[left]] == 0) {
                                char_in_s.erase(s[left]);
                            }
                            left++;
                            break;
                        }
                    }
                    left++;
                    // 左边缩小窗口一格后窗口内字符仍然能组成t
                    // 下一轮循环更新最覆盖子串长度,并尝试继续缩小窗口
                }    
            }
        }
        if(min_length == INT32_MAX) {
            return "";
        }
        return s.substr(result_left,result_right-result_left+1);
    }
    bool judge(std::unordered_map<char,int> &char_in_t,
               std::unordered_map<char,int> &char_in_s) {
        if (char_in_s.size() != char_in_t.size()) {
            return false;
        }
        for (auto pair : char_in_t) {
            if (pair.second > char_in_s[pair.first]) {
                return false;
            }
        }
        return true;
    }
};
```

## 4.模拟

### 螺旋矩阵II

求解本题依然要坚持循环不变量原则

绕的圈数:`n/2`
对于n=奇数的情况,画出的矩形最中间为一个单独的方格,该方格单独处理,不算绕的圈数
(n=偶数的情况,画出的矩阵最中间为一个2X2的矩形,为绕的最后一圈)
注意每圈别忘了更新该圈的起始索引和结束索引

把每绕的一圈分解为四条边
注意循环不变量:画四条边都应该统一是左闭右开或左开右闭
(不能都是左闭右闭,会覆盖之前赋值的)

```c++
vector<vector<int>> generateMatrix(int n) {
    vector<vector<int>> res = vector<vector<int>>(n,vector<int>(n,0));
    int loop = n/2;
    int count = 1;
    int startx = 0;
    int starty = 0;
    int endx = n;
    int endy = n;
    while (loop--) {
        for (int i=startx;i<endx-1;i++) {
            res[starty][i] = count++;
        }

        for (int j=starty;j<endy-1;j++) {
            res[j][endx-1] = count++;
        }

        for (int i=endx-1;i>startx;i--) {
            res[endy-1][i] = count++;
        }

        for (int j=endy-1;j>starty;j--) {
            res[j][startx] = count++;
        }

        startx++;
        starty++;
        endx--;
        endy--;
    }
    if (n % 2 != 0) {
        res[n/2][n/2] = count;
    }
    return res;
}
```

### 螺旋矩阵

本题提供的矩阵不一定是正方形

**绕的圈数有长和宽中较短者决定**
另外由于可能是长方形,本题每圈各自的endx和endy不一定相同

最后最中间是一个"圈"(仅通过绕圈就可以遍历完整个矩阵)还是一条"线",**也由长和宽中较短者的奇偶决定**

**如果较短者长度为奇数,则最后圈转完还剩一条线**,要单独处理
这条线的方向沿较长边的方向

```c++
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    int x = matrix[0].size();
    int y = matrix.size();
    vector<int> res;
    int loop = min(x,y)/2;
    int startx = 0;
    int statty = 0;
    int endx = x-1;
    int endy = y-1;
    while (loop--) {
        for (int i=startx;i<=endx-1;i++) {
            res.push_back(matrix[statty][i]);
        }

        for (int j=statty;j<=endy-1;j++) {
            res.push_back(matrix[j][endx]);
        }

        for (int i=endx;i>=startx+1;i--) {
            res.push_back(matrix[endy][i]);
        }

        for (int j=endy;j>=startx+1;j--) {
            res.push_back(matrix[j][startx]);
        }
        startx++;
        statty++;
        endx--;
        endy--;
    }
    if (min(x,y) % 2 != 0) {
        if (x <= y) {
            for (int j = statty; j<=endy; j++) {  
                res.push_back(matrix[j][x/2]);
            }
        } else {
            for (int i = startx; i<=endx; i++) {
                res.push_back(matrix[y/2][i]);
            }
        }
    }
    return res;
}
```

## 5.排序

**Leetcode 912**

### 快速排序及改进

基本快速排序,每次都从最左边取得基准值:

```c++
vector<int> sortArray(vector<int>& nums) {
    quickSort(nums, 0, nums.size()-1);
    return nums;
}
void quickSort(vector<int>& nums, int left, int right) {
    if (right <= left) {
        return; // 递归结束条件
    }
    int base = nums[left];
    int begin = left;
    int end = right;
    while (left < right) {
        while (left < right && nums[right] >= base) {
            right--;
        }
        if (left < right) {
            nums[left] = nums[right];
        }
        while (left < right && nums[left] <= base) {
            left++;
        }
        if (left < right) {
            nums[right] = nums[left];
        }
    }
    nums[left] = base;
    quickSort(nums, begin, left);
    quickSort(nums, left+1, end);
}
```

但该方法会超时:

①输入的本身是有序数组的情况下
普通快速排序每次依旧选着最左元素为partition,就会使得时间复杂度从O(nlogn)退化为O(n^2)
(以最左边最小/最大值为基准,产生的两部分别有1和n-1个元素,远不是大致平均划分的理想情况)

方法:**随机选取基准**(随机在left和right范围内产生基准的下标)

②输入数组可能有大量的重复的元素

方法:**三路快排**
把等于pivot元素的所有元素放在分割区间的中间,相等元素的左边和右边为用于继续递归快排的区间
等于pivot元素不再继续参与向下递归,大量元素相等的情况下,递归区间大大减少
在针对大量的重复元素的情况,这种方法大大减少了递归树的高度,极大提高了效率

**采用以上两种改进后的完整代码:**

C++随机数:
`int i = rand() % (r - l + 1) + l;`

```java
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        quickSort(nums, 0, nums.size()-1);
        return nums;
    }
    void quickSort(vector<int>& nums, int left, int right) {
        if (left >= right) {
            return;
        }
        // 产生随机基准下标,基准交换到最前面left处
        srand(time(0));
        int rand_index = rand() % (right - left + 1) + left;
        swap(nums[left], nums[rand_index]);
        int pivot = nums[left];
		
        // less:从left+1开始从前到后存储小于基准的数组元素
        // more:从right开始从后往前存储大于基准的数组元素
        // i:从前到后遍历整个数组(除基准外)的所有元素
        int less = left;
        int more = right + 1;
        int i = left + 1;
        while (i < more) {
            if (nums[i] < pivot) {
                less++;
                swap(nums[i], nums[less]);
                i++;
            } else if (nums[i] == pivot) {
                i++;
            } else {
                more--;
                swap(nums[i], nums[more]);
            }
        }
        // 遍历结束后,整个数组从left+1开始的发布如下(left是基准pivot)
        // 小于pivot的区间: [left + 1, less]
        // 等于pivot的区间: [less + 1, i]
        // 大于pivot的区间: [more, right]
        
        // less处为小于pivot,和left处pivot交换
        swap(nums[left], nums[less]);
       
        // 交换后的区间情况如下:
        // 小于pivot的区间: [left, less - 1]
        // 等于pivot的区间: [less, i]
        // 大于pivot的区间: [more, right]
        quickSort(nums, left, less-1);
        quickSort(nums, more, right);
    }
};
```

