**回溯模板:**

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择:本层集合中元素(树中节点孩子的数量就是集合的大小)) {
        处理节点;
        backtracking(路径,选择列表); // 递归
        回溯,撤销处理结果;
    }
}
```

## 1.组合问题

给定两个整数 n 和 k, 返回 1 ... n 中所有可能的 k 个数的组合

组合问题抽象为如下树形结构:
<img src=".\images\23.JPG" alt="23" style="zoom: 67%;" />

每次从集合中选取元素,**可选择的范围随着选择的进行而收缩,调整可选择的范围**
图中可以发现n相当于树的宽度,k相当于树的深度
只要每次搜索到了叶子结点,就找到了结果

相当于只要把达到叶子节点的结果收集起来,就可求得n个数中k个数的组合集合

**回溯模板**

参数:除n与k外,还需要startindex参数,表示本层从哪个数开始
另外还需要全局变量path和result,前者在搜索和回溯的过程中存储路径,result存储结果

结束条件:path的size==k,保存结果至result

层内横向遍历:从本层的startindex开始到n;循环内:
①当前节点加入path②递归调用,注意startindex=i+1③递归后回溯,当前节点退出path

### 剪枝优化

因规定了最终答案有4个数字,所以所有搜索的组合情况中数字个数不足4个的都可剪掉
<img src="./images/24.jpg" alt="24" style="zoom: 67%;" />

图中每个结点(矩形)都代表一次递归调用中的整个for循环

图中叉掉的结点,既是个数不足4个的搜索

> 如第一行的第二个结点,从2开始取的情况:
> 因总的数字只有4个,从2开始取最多只能取3个数,因此此情况一定取不到4个数字的组合
> 所以该节点需要直接剪掉

可以进行剪枝的地方是确定每个结点的for循环的开始位置(startindex)时:
在for开始前,确定了其startindex后,如发现其之后的元素个数已不足k,则没必要进行搜索了

for循环改为:
`for (int i = startIndex; i <= n - (k - path.size()); i++) `

**代码:**

```c++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void search(int n, int k, int startindex) {
        if (path.size()==k){
            res.push_back(path);
            return;
        }
        for (int i=startindex; i<=(n-(k-path.size())+1); i++) {
            path.push_back(i);
            search(n,k,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        search(n,k,1);
        return res;
    }
};
```

### 组合总和Ⅲ

找出所有相加之和为 n 的 k 个数的组合
组合中只允许含有 1 - 9 的正整数,并且每种组合中不存在重复的数字

本题在1-9的数字中找,因此树的最大宽度=9,深度仍为k

**剪枝优化:**

1.如已选元素总和如果已经大于n,则往后遍历就没有意义了,直接剪掉

剪枝可以放在递归函数开始的地方

```c++
if (sum > targetSum) { // 剪枝操作
    return;
}
```

2.同上,for循环的范围也可以剪枝

`for (int i = startIndex; i <= 9 - (k - path.size()) + 1; i++){}`

**代码:**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void search(int k, int n, int sum, int startindex) {
        if (path.size()==k){
            if(sum == n) {
                res.push_back(path);
            }
            return;
        }
        if (sum > n) {
            return;
        }
        for (int i=startindex; i<=(9-(k-path.size()))+1; i++) {
            path.push_back(i);
            search(k,n,sum+i,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        search(k,n,0,1);
        return res;
    }
};
```

### 电话号码字母组合

给定一个仅包含数字 2-9 的字符串, 每个数字能表示的字母同九键键盘
返回所有它能表示的字母组合,组合顺序任意

数字和字母的映射:
定义一个数组`const string letterMap[10]`

深度:输入的长度,叶子节点为结果

**代码:**

```c++
class Solution {
public:
    const string letterMap[10] {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"
    };
    vector<string> res;
    string path;
    void search(string digits, int i) {
        if (i==digits.size()) {
            res.push_back(path);
            return;
        }
        string letters = letterMap[digits[i]-'0'];
        for (int j=0; j<letters.size(); j++) {
            path.push_back(letters[j]);
            search(digits,i+1);
            path.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0) {
            return res;
        }
        search(digits,0);
        return res;
    }
};
```

### 组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target .找出 candidates 中所有可以使数字和为 target 的组合,candidates 中的数字可以**无限制重复被选取**
candidates元素大于1

统计sum,使用`target--`也可以(`target==0`时即找到结果)

同时也需要使用startindex

> **是否需要使用startindex?**
>
> 若是在一个集合中求组合,则需要startindex(如组合总和Ⅲ)
> 若是在多个集合取集合,各个集合之间互不影响,则不用startindex

结束条件:

```c++
if (sum > target) {
    return;
}
if (sum == target) {
    result.push_back(path);
    return;
}
```

单层搜索逻辑:

注意:本题元素**可以选择重复的**
方法:**startindex不用i+1了,直接从i开始就行**

```c++
for (int i = startIndex; i < candidates.size(); i++) {
    sum += candidates[i];
    path.push_back(candidates[i]);
    // 关键点:递归传入的startindex不用i+1了,i表示可以重复读取当前的数
    backtracking(candidates, target, sum, i);
    sum -= candidates[i];   // 回溯
    path.pop_back();        // 回溯
}
```

**剪枝优化**

之前版本的代码,是进入了下一层后,如果sum>target,才返回
但实际上可以不进入下一层,为此需要修改for循环的搜索返回

可以预先对candidates进行排序,for循环条件:
`i < candidates.size() && sum + candidates[i] <= target`

**在组合+求和问题中,排序之后加剪枝是常见的套路**

### 组合总和Ⅱ

给定一个有重复元素的数组 candidates 和一个目标数 target .找出 candidates 中所有可以使数字和为 target 的组合(和上一题不同, 本题数组candidates的元素是有重复的)

> **难点:有重复元素,但不允许有重复组合**
> 如果把所有组合先求出来,再用map/set去重,会超时
> 所以需要在搜索的过程中就进行去重

因candidates有重复元素,需去重:使用过的元素不能重复选取

若将搜索和回溯过程抽象为树:
纵向维度:树的第一层决定组合的第一个数字,第二层决定组合的第二个数字...
横向维度:树的同一层决定 搜索到的所有组合 内部的同一位置上的元素

元素重复使用也相应的分两个维度:
①树枝(纵向)方向重复使用,为在一个组合内部元素重复出现,允许
②树层(横向)方向重复使用,为不同组合在同一位置上元素相同,会导致找出重复的组合,不允许
<img src=".\images\25.JPG" alt="25" style="zoom:67%;" />

> **需判断在同一数层(横向)出现重复元素:,同时避免误判同一树枝(纵向)出现重复元素**

方法一:使用used数组:在递归调用下一层前把当前节点在used数组中标记,回溯回来时再删除
若在for循环过程中发现数组当前元素和数组上一个元素相同,且used数组==false:
为树层横向方向重复使用,直接continue

方法二:可以不使用used数组,判断是树层横向重复而不是树枝纵向重复:
`i>startindex && nums[i-1] == nums[i]`
(`i>startindex`可排除树枝纵向重复的情况)

**代码:**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void search(vector<int>& candidates, int target, int startindex, int sum) {
        if (sum == target) {
            res.push_back(path);
            return;
        }
        for (int i=startindex; i<candidates.size() && sum+candidates[i]<=target; i++) {
            if (i > startindex && candidates[i-1] == candidates[i]) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            search(candidates,target,i+1,sum);
            sum -= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        search(candidates,target,0,0);
        return res;
    }
};
```

## 2.分割回文串

将 s 分割成一些子串,使每个子串都是回文串
返回所有的分割方案

> **切割问题类似组合问题**
>
> 例如对于字符串abcdef:
>
> 组合问题:选取a,然后在bcdef中选取第二个;若第二个选了b,又可在剩余的cdef中选第三个
> 切割问题:先切割一个a,然后在后续的bcdef中切割出若干个
>
> **关键是如何模拟切割线**

设本次和上一次间的切割线是startindex,和下一次的切割线是i
从`startindex`开始到字符串结尾遍历`i`,对于每个遍历到的`i`,**本次要切割出的子串为区间`[startindex,i]`**
若判断该子串不是回文子串,这个`i`跳过(`continue`继续for循环)
若该子串是回文子串,则将其加入path中,随后递归调用(传入startindex为i+1),回溯:从path中删除

判断子串:双指针

**递归终止条件:`startindex>=s.size()`**,startindex已经走到了末尾
表示该字符串已经切割完毕(找到了一种将所给字符串切割成若干回文串的方法),保存结果即可,return

**代码:**

```c++
class Solution {
public:
    vector<vector<string>> res;
    vector<string> path;
    void search(string s, int startindex){
        if (startindex >= s.size()) {
            res.push_back(path);
            return;
        }
        for (int i=startindex; i<s.size(); i++) {
            if (!judge(s,startindex,i)) {
                continue;
            }
            string sub = s.substr(startindex,i-startindex+1);
            path.push_back(sub);
            search(s,i+1);
            path.pop_back();
       }
    }
    bool judge(string s, int start, int last) {
        while (start < last) {
            if (s[start] != s[last]) {
                return false;
            }
            start++;
            last--;
        }
        return true;
    }
    vector<vector<string>> partition(string s) {
        search(s,0);
        return res;
    }
};
```

### 复原IP地址

给定一个只包含数字的字符串,复原它并返回所有可能的 IP 地址格式
有效的IP地址正好有四个整数(每个整数位于 0 到 255 之间组成,且不能含有前导 0),整数间用 '.' 分隔

类似上一题切割回文串

不同点:

①每切割出一个构成合法数字的区间,给字符串该区间后面加一个点
因为加了点,下一次递归的`startindex=i+2`;
递归后回溯:删掉加的点

②**因为IP地址只能由4个数字组成,所以递归终止条件也不同**
递归函数额外传递一个参数pointnum,表示已经加入的点的数量
当进入递归函数时,若`pointnum==3`,判断从当前位置到末尾的区间是否为一个合法的数字(第四个数字):
若是,则找到了一种合法的IP地址,保存结果; 最后`return;`(不管找没找到结果)

(递归和回溯时注意别忘了pointnum也要++和--)

③因为IP地址中一个数字最多3位,所以for循环时可以设置剪枝:**最多循环3次**:
`for (int i=startindex; i<s.size() && i<startindex+3; i++){}`

**代码:**

```c++
class Solution {
public:
    vector<string> res;
    void search(string &s, int startindex, int pointnum) {
        if (pointnum == 3) {
            if (judge(s,startindex,s.size()-1)) {
                res.push_back(s);
            }
            return;
        }
        for (int i=startindex; i<s.size() && i<startindex+3; i++) {
            if (!judge(s,startindex,i)) {
                break;
            }
            s.insert(s.begin()+i+1,'.');
            pointnum++;
            search(s,i+2,pointnum);
            pointnum--;
            s.erase(s.begin()+i+1);
        }
    }
    bool judge(string s, int start, int last) {
        if (start > last) {
            return false;
        }
        if (s[start] == '0' && last!=start) {
            return false;
        }
        int count = 0;
        for (int i=start; i<=last; i++) {
            if (s[i] > '9' || s[i] < '0') {
                return false;
            }
            count = count*10 + s[i]-'0';
            if (count>255) {
                return false;
            }
        }
        return true;
    }
    vector<string> restoreIpAddresses(string s) {
        search(s,0,0);
        return res;
    }
};
```

## 3.子集问题

给定一组不含重复元素的整数数组 nums,返回该数组所有可能的子集
答案不能包含重复的子集

如果把子集问题,组合问题,分割问题都抽象为一棵树的话:
①组合问题和分割问题都是收集树的叶子节点
②**子集问题是找树的所有节点**

子集问题也是一种组合问题,因为集合无序
因为无序,所以**取过的元素不能重复取,因此每次都要从startindex开始**
(**排列问题才从0开始取**)

把搜索树的每个节点都记录下来,即是答案

不需要任何剪枝,因为本来就是要遍历所有节点

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void search(vector<int>& nums, int startindex) {
        for (int i=startindex; i<nums.size(); i++) {
            path.push_back(nums[i]);
            res.push_back(path);
            search(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        res.push_back(vector<int>()); // 空集也是子集
        search(nums,0);
        return res;
    }
};
```

### 子集Ⅱ

区别:nums有重复的元素且答案不能包含重复的子集

**去重逻辑:是树层去重,**(而非树枝去重)**(※数层去重记得需先排序!)**
不是树枝去重:因为题目规定了相等也算递增,即组合内部可能会有重复元素

### 递增子序列

你的任务是找到所有该数组的递增子序列,递增子序列的长度至少是2
(相等的数字应该被视为递增的一种情况)

因为求递增子序列,所以不能像子集Ⅱ一样先给数组排序

终止条件:长度大于等于2的都记录(不是求长度固定的子序列,所以**记录后不返回**)

```c++
if (path.size() > 1) {
    result.push_back(path);
    // 注意这里不要加return,因为要取树上的所有节点
}
```

去重:**同一父节点下的同层上使用过的元素就不能再使用了**
对于每层(每一个for循环),都用一个set/数组来去重

不递增或重复:continue

> 别忘了搜索树横向(数层)和纵向(树枝)代表的意义:
> 纵向(树枝):同一个组合/集合; 横向(数层): 搜索到的所有组合/集合 内部的同一位置

```c++
unordered_set<int> uset; // 使用set来对本层元素进行去重
for (int i = startIndex; i < nums.size(); i++) {
    if ((!path.empty() && nums[i] < path.back())
    	|| uset.find(nums[i]) != uset.end()) {
            continue;
    }
    uset.insert(nums[i]); // 记录这个元素在本层用过了,本层后面不能再用了
    path.push_back(nums[i]);
    backtracking(nums, i + 1);
    path.pop_back();
}
```

## 4.排列问题

给定一个 没有重复 数字的序列, 返回其所有可能的全排列

终止条件:`path.size() == nums.size()`

单层搜索的逻辑:

排列问题,因[2,1]和[1,2]是不同的结果,因此**不需要startindex**
**每次for循环都是从0开始**

**排列问题需要注意path内部去重**(防止同一位置元素反复被添加):

因每次都从0开始,所以为防止给同一个path中反复添加同一元素,需要给同一个path内的元素去重:
可以用一个和nums相同大小的数组记录当前path中哪些元素已使用过
给递归函数添加参数`vector<bool>& used`,往下递归设为true,回溯返回时恢复false

> 此处去重的"重":指的是所给数组中同一位置的元素,而非相同值的元素
>
> **used用vector而非set**,因为要按数组中位置统计,而非按照值
> (如下一题,所给数组有重复值,就不能按照值去统计是否使用过)

**代码:**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void search(vector<int>& nums, vector<bool>& used) {
        if (path.size() == nums.size()) {
            res.push_back(path);
            return;
        }
        for (int i=0; i<nums.size(); i++) {
            if (used[i]) {
                continue;
            }
            used[i] = true;
            path.push_back(nums[i]);
            search(nums,used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        search(nums,used);
        return res;
    }
};
```

### 全排列Ⅱ

给定一个可包含重复数字的序列 nums ,按任意顺序 返回所有不重复的全排列

> **和之前的问题同理,nums有重复数字,意味着要考虑去重**

**同层去重一定要先对nums进行排序!**

树层横向去重类似之前的组合和子集问题:
`if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false)`

> 注意最后的`used[i - 1] == false`,用来**区分同一path内的值相同的数字和不同path之间的重复**
> (因为每次都是从开头开始,没有startindex,所以不同于组合问题,无法用`i>startindex`区分)

同时别忘了对path内部使用used数组去重,防止往一个path中反复添加数组同一位置的数字

**代码:**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void serach(vector<int>& nums, vector<bool> &used) {
        if (path.size() == nums.size()) {
            res.push_back(path);
            return;
        }
        for (int i=0; i<nums.size(); i++) {
            if (i > 0 && nums[i-1] == nums[i] && used[i-1] == false) {
                continue;
            }
            if (used[i]) {
                continue;
            }
            used[i] = true;
            path.push_back(nums[i]);
            serach(nums,used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<bool> used(nums.size(),false);
        serach(nums,used);
        return res;
    }
};
```

## 5.其他问题

### 重新安排行程

深度优先搜索,也属于回溯

注意:①要防止因路径中存在的环而陷入死循环

②记录映射关系,且要考虑字母顺序,使用map而不是set(set无序)

一个机场可能对应多个可到达的机场
使用数据结构:`unordered_map<string, map<string, int>> targets`
即`unordered_map<出发机场, map<到达机场, 航班次数>> targets`
可以使用"航班次数"这个字段的数字做相应的增减,来标记到达机场是否使用过了
如果“航班次数”大于零,说明目的地还可以飞,如果“航班次数”等于零说明目的地不能飞了

**保持目的地机场字母顺序通过目的地机场的map:`map<string, int>`实现**

这样的的目的是避免访问顺序成环,这种方式实现的好处是:
不用对一个机场对应的机场集合`map<string, int>`进行删除操作,只需增减次数即可
(递归`--`,回溯返回`++`)

> 如果用`unordered_map<string, multiset<string>> targets`实现
> 访问后需要从`multiset<string>`中删除时,删除会导致迭代器失效,因此不如上面的实现

③单层遍历逻辑:遍历 targets[上一次访问的机场]
**((按字母顺序)遍历上次访问的机场可到达的所有目的地机场)**

**上次访问的机场为保存结果的数组中最后一个元素**
在开始递归前,**需要先把"JFK"先加入保存结果的数组中**
第一次遍历JFK机场能到达的所有目的地机场

④终止条件:设题目给了路径条数=n:
则当已记录的路径中机场数=n+1时,已找到,终止,return true

⑤返回值:**因为找到一条即终止,所以递归函数有bool返回值**
在递归调用时,如果递归结果返回true,则表示已经找到,则不用再继续找了
直接继续返回true就行

遍历完整个map,没找到,则返回false

**代码:**

```c++
class Solution {
public:
    unordered_map<string, map<string, int>> routes;
    bool search(int ticketsnum, vector<string> &res) {
        if(res.size() == ticketsnum+1) {
            return true;
        }
        for (pair<const string, int> &dst : routes[res[res.size()-1]]) {
            if (dst.second > 0) {
                res.push_back(dst.first);
                dst.second--;
                if (search(ticketsnum,res) == true) {
                    return true;
                }
                dst.second++;
                res.pop_back();
            }
        }
        return false;
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for (vector<string> route : tickets) {
            routes[route[0]][route[1]]++;
        }
        vector<string> res;
        res.push_back("JFK");
        search(tickets.size(),res);
        return res;
    }
};
```

注意:①传入函数的参数res别忘了要加引用
②遍历map,使用`pair<const string,int>`,别忘了pair中key前面的const

### N皇后

回溯搜索,搜索树的每一层表示棋盘的一行

给递归函数增加一个参数row,表示搜索到第几行

递归终止条件:row到达最底层

返回值:不同于上一题,**因题目要求找到所有可能的排布方式,而不是找到一种就行**
所以**没有返回值,**需要完整地完成遍历,找到一个答案后添加进res,而不能直接返回

单层搜索的逻辑:
遍历当前行中的每个列
给当前行每个列放棋子,判断放了棋子以后符不符合要求
如果符合要求,则继续往下一行递归,回溯

注意:因为是按行递归的,所以判断是否符合题意时:
不需要判断两颗棋子同行的情况,只需要判断同列和同对角线的情况

**代码:**

```c++
class Solution {
public:
    vector<vector<string>> res;
    void search(int n, int row, vector<string> &chessboard) {
        if (row == n) {
            res.push_back(chessboard);
            return;
        }
        for (int i=0; i<n; i++) {
            if (judge(row,i,n,chessboard)) {
                chessboard[row][i] = 'Q';
                search(n,row+1,chessboard);
                chessboard[row][i] = '.';
            }
        }
    }
    bool judge(int row, int col, int n, vector<string> chessboard) {
        for (int i=0; i<row; i++) {
            if (chessboard[i][col] != '.') {
                return false;
            }           
        }
        for (int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {
            if (chessboard[i][j] != '.') {
                return false;
            }
        }
        for (int i=row-1, j=col+1; i>=0 && j<n; i--, j++) {
            if (chessboard[i][j] != '.') {
                return false;
            }
        }
        return true;
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string> chessboard(n,string(n,'.'));
        search(n,0,chessboard);
        return res;
    }
};
    
```

### 解数独

数字 1-9 在每一行只能出现一次
数字 1-9 在每一列只能出现一次
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次

本题不能像上一题一样按行递归:
因为上一题规定了每行只能放一个元素,但本题不是

**需要进行二维递归**(对每个空格递归,搜索树要大得多)
一个for循环遍历行,一个for循环遍历列
然后对每个空方格遍历(尝试放置)数字1到9

递归过程中,一个数字可以放在当前空方格的条件:
①该数字放置在当前位置后,不会和当前已有的其他数字产生冲突
②后续继续递归后,可以给当前位置后面其他所有空方格也都找到合适的数字

本题递归函数需要`bool`返回值

当为当前空格找到了一个符合条件的值,且后续继续调用也返回true,即给当前空格放置该数字后,后续继续递归可以给后面其他方格都找到合适的数字,则当前这个数字可以放,返回true

如果给当前这个空格依次试验了数字1-9,都没有找到合适的值(需要这个值合适+后续递归遍历返回true,即可以给后续其他空方格也找到合适的值),则数独无解,返回false (**有解时,最后一次递归发现棋盘已经全是数字,没有空方格,返回true**)

由上,有了返回值,本题不需要递归终止条件

```c++
class Solution {
public:
    bool search(vector<vector<char>>& board) {
        for (int i=0; i<board.size(); i++) {
            for (int j=0; j<board[0].size(); j++) {
                if (board[i][j] == '.') {
                    for (char c = '1'; c <= '9'; c++) {
                        if (judge(board,i,j,c)) {
                            board[i][j] = c;
                            if (search(board)) {
                                return true;
                            }
                            board[i][j] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    bool judge(vector<vector<char>> &board, int row, int col, char num) {
        for (int i=0; i<board.size(); i++) {
            if (i != row && board[i][col] == num) {
                return false;
            }
        }
        for (int j=0; j<board[0].size(); j++) {
            if (j != col && board[row][j] == num) {
                return false;
            }
        }
        int rowstart = (row/3)*3;
        int colstart = (col/3)*3;
        for (int i=rowstart; i<rowstart+3; i++) {
            for (int j=colstart; j<colstart+3; j++) {
                if(i!=row && j!=col && board[i][j] == num) {
                    return false;
                }
            }
        }
        return true;
    }
    void solveSudoku(vector<vector<char>>& board) {
        search(board);
    }
};
```

