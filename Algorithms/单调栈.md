## 1.每日温度

已知每日气温列表,求一个列表,对应位置为:"要想观测到更高气温,至少需要等待的天数",0表示之后不会升高

**使用单调栈**

使用场景:一维数组,寻找某元素的右边或左边第一个比自己大或者小的元素的位置,时间复杂度为O(n)

单调栈的本质是时间换空间,在遍历过程中用一个栈记录第一个比自己大/小的元素
**即用一个容器来记录我们遍历过的元素**

以下以寻找每个元素右边第一个比自己大的元素为例:

单调栈使用递增顺序,遍历过程中保证栈中从栈入口到栈底元素始终是依次递增顺序
即新加入的元素如果小于栈顶元素才能入栈;否则栈顶出栈,直到栈顶大于新加入元素为止

> **注意:①别忘了在出栈若干个后,还要把当前遍历到的元素入栈!**
> **②看清结果结果要的是元素还是下标,以及下标需要的是绝对距离还是相对距离**

这样,当新加入元素大于栈顶时,需要对栈顶若干个元素依次出栈,直到栈的栈顶大于新元素
因此,**这个新加入元素是这次被弹出栈的若干个元素的右边第一个比自己大的元素**

单调栈`st`中元素只需记录原列表中元素下标即可,另外建立一个保存结果的列表result
当栈顶要出栈时,`result[st.top]=i-st.top();`(本题求的是第一个比自己大的元素与自己的相对位置)

## 2.下一个更大元素 I

给出两个没有重复元素 的数组 nums1 和 nums2, 其中nums1是nums2的子集
求 nums1 中每个元素在 nums2 中的下一个比其大的值的下标(不存在用-1表示)

使用递增的单调栈,建立一个和nums1一样大的保存结果的列表result
与上一题不同之处在于,不是每次出栈都需要给result数组赋值
而是需要先判断本次出栈的元素是否在nums1中存在,当确认存在时才赋值result数组

①为了快速判断出栈元素在nums1中是否存在
②如存在,还需知道它在nums1中的下标,以便知道保存到result数组中位置的下标
**因此,给nums1数组建立一个map,由元素映射到nums1中下标**

> **注意:无论在nums1中是否存在,都要pop,注意pop写的位置!**

## 3.下一个更大元素II

给定一个循环数组(最后一个元素的下一个是第一个),输出每个元素的下一个更大元素

①把两个数组拼接在一起
②不实际拼接,在同一数组上遍历2遍,模拟把两个数组拼接在一起
**(下标从0遍历到`2*nums.size()-1`,通过下标对`nums.size()`取余实现在同一数组上遍历)**

## 4.接雨水

有按列计算和按行计算两种方法
<img src="./images/4.jpg" alt="4" style="zoom: 67%;" />

**双指针+DP or 单调栈?**

> 双指针+DP适合只要求左边第一个更高的列的高度,不要求其下标的情况!
> 如果要求某元素左右第一个更大元素的下标而非值,DP无法求,只能用单调栈

**法一:双指针(DP)**

每列能存储的水的高度,为该列左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度

按列计算为例,设当前列高度为h,宽度=1
则本列可存储雨水单位=**min(左边第一个大于h的元素,右边第一个大于h的元素)-h**
因此需要寻找每列左右两边第一个高度更高的列

暴力解法:对每个元素在左右侧寻找,有重复寻找,时间复杂度为O(n^2)

双指针优化:先从左到右遍历和从右到左遍历各一次,分别寻找每列左边和右边第一个更高的列
之后再根据这两次遍历结果求每列存储的雨水量,若大于0则累加到结果中
优化版本总时间复杂度O(n)

```c++
// 前两次遍历如下:(类似DP的思想)
// 记录每个柱子左边柱子最大高度
// DP初始化:maxLeft[0] = height[0]
maxLeft[0] = height[0];
for (int i = 1; i < size; i++) {
    maxLeft[i] = max(height[i], maxLeft[i - 1]);
}
// 记录每个柱子右边柱子最大高度
// DP初始化:maxRight[size - 1] = height[size - 1]
maxRight[size - 1] = height[size - 1];
for (int i = size - 2; i >= 0; i--) {
    maxRight[i] = max(height[i], maxRight[i + 1]);
}
// 求和
int sum = 0;
for (int i = 0; i < size; i++) {
    int count = min(maxLeft[i], maxRight[i]) - height[i];
    if (count > 0) sum += count;
}
```

**法二:单调栈**

> 单调栈,新元素:小于等于栈顶入栈,大于栈顶,出栈,直到栈空或小于等于栈顶,再入栈
> 出栈过程中: bottom 出栈下标对应高度, left:栈中下一个下标对应高度
> h = min(height[i], left) - bottom; w = i - left-1; sum += h * w

单调栈按照行的方向计算雨水
单调栈保存元素下标,从栈入口到栈底使用递增顺序(记录每个列右边第一个更高的列)

遍历过程中:

(1)遍历到新元素小于栈顶元素高度,则直接入栈

(2)遇到和栈顶相同高度的柱子,将栈里元素(旧下标)弹出,将新元素(新下标)加入栈中
因为我们要求宽度的时候 如果遇到相同高度的柱子,需要使用最右边的柱子来计算宽度

(3)遍历中一旦发现添加的柱子高度大于栈头元素,此时可能发现了一个能存水的凹槽右部;
①若栈顶左边元素高度大于当前栈顶元素高度(即凹槽底部高度),则找到了当前凹槽的左部
②若栈顶左边元素高度等于当前栈顶元素高度(即凹槽底部高度),则此凹槽宽度大于1;显然这种情况下,出栈后新元素仍然大于栈顶元素,不满足单调递增栈的要求,因此继续出栈,之后再次检查是否到达了凹槽左部
③如果到了最左边都没有找到凹槽左侧壁,则此凹槽不能存水,存水=0

找到了当前凹槽左部后不代表就可以让遍历到的新元素满足加入单调递增栈的条件(即新元素小于等于栈顶)
如还不满足条件,说明上面可能还能存一层水(按照自底向上一层一层计算能存的水)

找到宽度=1的凹槽:
<img src="./images/5.jpg" alt="5" style="zoom:67%;" />

每次出栈,按以下计算方式计算当前能存储的这一层水的水量:

雨水高度h = min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度
凹槽底部高度指当前矩形的底部(上次被计算的矩形的顶部),即当前栈顶
所以每次出栈前,需要设置底部高度=当前栈顶

雨水宽度w = 凹槽右边的下标 - 凹槽左边的下标 - 1

计算每个凹槽所存雨水量大小=高度乘宽度
若结果=0,则还没找到凹槽左边壁
若结果>0,找到当前凹槽左边,计算当前这一层的水量,加入result

> 由计算高度h的方法可知,当凹槽底部宽度>1时:
> 若栈顶元素(列)的高度=栈顶左边的元素(列)高度,则计算得h=0,对此凹槽雨水存储量贡献=0
> 此时只需继续出栈,直到遇到栈顶左边的元素(列)高度>栈顶元素的列的情况,此时才能计算出这一层凹槽的存储水量;如到列表最左边还没找到,则此凹槽存水=0
>
> 按层从下到上计算每层凹槽存储的总水量,计算出当前矩形凹槽的水量(当前这一层的水量,可能是一行或多行后,如仍没遇到大于新元素的栈顶元素且没到达数组最左边,则上面可能还能存一层水,所以继续出栈,之后计算的是上面存储那层水的水量
> <img src=".\images\6.jpg" alt="6" style="zoom:80%;" />
> <img src=".\images\7.JPG" alt="7" style="zoom: 25%;" />
>
> ```c++
> int trap(vector<int>& height) {
>     int sum = 0;
>     stack<int> st;
>     st.push(0);
>     for(int i=1;i<height.size();i++){
>         while(!st.empty()&&height[i]>height[st.top()]){
>             int bottom = height[st.top()];
>             st.pop();
>             if(!st.empty()){
>                 int h = min(height[i],height[st.top()]) - bottom;
>                 int w = i - st.top() - 1;
>                 sum += h*w;
>             }
>         }
>         st.push(i);
>     }
>     return sum;
> }
> ```

## 5.柱状图中最大的矩形

给定n个非负整数,表示柱状图中各个柱子高度,每个柱子彼此相邻,且宽度为1
求在该柱状图中,能够勾勒出来的矩形的最大面积

类似于上一题,有双指针和单调栈两种方法

**单调栈**

> 单调栈,新元素:大于等于栈顶入栈,小于栈顶,出栈,直到栈空或大于等于栈顶,再入栈
> 出栈过程中,计算矩形大小
> h=出栈下标对应高度, w=i-left-1

不同于上一题使用递增栈,记录每个列右边第一个更高的列(即凹槽右壁)
本题需要使用递减栈,记录每个列右边第一个更低的列

另外,本题需要给所给数组的第一个和最后一个位置分别加一个0
从而让第一个入单调栈和最后一个入单调栈的元素都是0,原因见后

单调栈存储每个柱子的下标,遍历过程中:

(1)遇到元素的高度>=当前栈顶元素的,直接入栈

(2)若遇到元素的高度小于当前栈顶元素

出栈若干次,直到加入新元素后满足单调递减栈的性质
在此过程中,记录在"挨着新元素左边,高度大于新元素且连续的若干列"中,能围出的最大矩形面积
出栈若干次后新元素可以加入,则让新元素入栈,然后继续遍历后面的数字

每次出栈计算一次矩形面积,当前遍历到下标`i`
高度:本次出栈的元素对应的值(高度)`heights[st.top()]`
宽度:设在栈中存储的本次出栈的列的下一个列的下标(本次出栈后的栈顶元素)为`left`
则宽度=`i-left-1`, (不是`i-st.top()`,原因见后面)

> 示例:如下,栈中已有30,35,40,45,新遍历到32,要加入32,需依次出栈35,40,45:
> 在出栈这3个的过程中,需要检查这三列(图中有色区域)能围出的最大矩形
> <img src=".\images\8.JPG" alt="8" style="zoom:67%;" />
>
> 在出栈这3列的过程中,依次计算,比较的3个矩形如下:
> <img src=".\images\9.JPG" alt="9" style="zoom:67%;" />
> <img src=".\images\10.JPG" alt="10" style="zoom:67%;" />
> <img src=".\images\11.JPG" alt="11" style="zoom:67%;" />

遍历到最后时,最后一个遇到的元素是0,一定小于当前栈内剩余的所有非0元素
因此可以统计此时栈中还剩余的若干列所能围出的最大矩形

最后,统计整个遍历过程中记录到的最大矩形面积,返回结果

> **注意矩形宽度不是`i`-本次出栈列的下标(st.top()),而是要看栈中下一个元素(下次出栈的)!**
>
> 因为在遍历过程中可能先出栈若干个列,再加入新列,所以当前栈中存储的柱子下标不一定是连续的
> 如栈中当前存储的柱子下标和对应的高度如下:
> `1(10),2(20),5(30)`,下标3和4的柱子之前已经出栈,此时加入`i=6(15)`,下标2和5柱子需要出栈
>
> 当计算以下标5的柱子高度(30)为高度的矩形的宽度时:
> 如果按照`i-st.top()`计算高度30矩形的宽度,w=6-5=1,错误! 实际上,由下标3和4的柱子已经出栈可知它们的高度一定>30,所以高度30的矩形宽度应该从3到5,w=3
> 因此计算宽度应等于`i`(6)-当前要出栈的柱子出栈后下一个栈顶柱子的下标-1

## 6.最大矩形

[Leetcode 85](https://leetcode.cn/problems/maximal-rectangle/description/?envType=problem-list-v2&envId=2cktkvj)

> 暴力方法
>
> 1.先求每一行每个位置以它为最右边的最大连续的1
>
> 2.向上扩展行
>
> 单调栈
>
> 1.同暴力方法求每一行的heights
>
> 2.每一层调用一次求柱状图中最大矩形的函数

```c++
int findMax(const vector<int> &height) {
    stack<int> st;
    st.push(0);
    int max_s = 0;
    for (int i=1; i<height.size(); i++) {
        while (!st.empty() && height[i] < height[st.top()]) {
            int h = height[st.top()];
            st.pop();
            if (!st.empty()) {
                int w = i - st.top() - 1;
                int s = h*w;
                max_s = max(max_s, s);
            }
        }
        st.push(i);
    }
    return max_s;
}
int maximalRectangle(vector<vector<char>>& matrix) {
    int max_s = 0;
    int n = matrix.size();
    int m = matrix[0].size();
    vector<int> height(m+2,0);
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            if (matrix[i][j] == '0') {
                height[j+1] = 0;
            } else {
                height[j+1]++;
            }
        }
        int tmp = findMax(height);
        max_s = max(max_s, tmp);
    }

    return max_s;
}
```

## 7.子数组的最小值之和

[Leetcode 907](https://leetcode.cn/problems/sum-of-subarray-minimums/)

**法1:单调栈**

设以元素arr[i]为**最右最小值**(若有不止一个相等的最小值,其是最靠右的一个)的子序列数目=$C_i$
则这些子序列的最小值之和$s=arr[i]*C_i$
遍历所有元素,把每个元素的这个s相加,得到最终结果

计算$C_i$:
①使用单调栈寻找arr[i]左边第一个比它小的元素,下标为j
(防止左边没有比它小的元素,因此默认j为`-1`)
②使用单调栈寻找arr[i]右边第一个小于等于`arr[i]`的元素,下标为k
(防止右边没有小于等于它的元素,因此默认k为`arr.size()`)
$C_i=(j-i)*(i-k)$

**法2:DP+单调栈**

设`s[i][j]`表示连续子数组i到j中的最小值,则所有连续子数组的最小值之和为$\sum_{i=0}^{n-1}\sum_{j=i}^{n-1}s[i][j]$
也可写成$\sum_{i=0}^{j}\sum_{j=0}^{n-1}s[i][j]$

对于所有以某个给定`j`为最右元素的子数组,它们各自的最小值和为$\sum_{i=0}^{j}s[i][j]$
即可先求每个`j`的$\sum_{i=0}^{j}s[i][j]$,再对所有`j`分别对应的$\sum_{i=0}^{j}s[i][j]$值再求和,得到答案$\sum_{i=0}^{j}\sum_{j=0}^{n-1}s[i][j]$
所以下面先研究对于某个给定的`j`,如何求$\sum_{i=0}^{j}s[i][j]$ (DP+单调栈)

设序列中以 `arr[j]`为最右最小值的最长子数组长度为k,子数组左端下标为i

当`i>=j-k+1`时,子数组`[i][j]`最小值`s[i][j]`总是`arr[j]`
当`i<j-k+1`时,子数组`[i][j]`最小值`s[i][j]`等于`s[j][i-k]`
可得出递推公式:(注意以下公式以j为左,i为右)
<img src=".\images\12.JPG" alt="12" style="zoom:80%;" />

通过单调栈,可以很容易求出每个元素arr[i]左边第一个比它小的元素
即,求出了以`arr[i]`为最右且最小值的子数组最大长度(即上面的k)

求每个元素的k值,再使用以上递推公式,用DP,把dp数组每一项加起来得结果

```c++
int sumSubarrayMins(vector<int>& arr) {
    long long mod = 1e9+7; //注意10^9+7是1e9+7,不是10e9+7
    long long sum = 0;
    vector<int> minLeft(arr.size(),-1);
    stack<int> st;
    st.push(arr.size()-1);
    for(int i=arr.size()-2;i>=0;i--){
        while(!st.empty()&&arr[i]<arr[st.top()]){
            minLeft[st.top()] = i;
            st.pop();
        }
        st.push(i);
    }
    vector<int> dp(arr.size());
    for(int i=0;i<arr.size();i++){
        if(minLeft[i]==-1) dp[i] = (i-minLeft[i])*arr[i];
        else dp[i] = dp[minLeft[i]] + (i-minLeft[i])*arr[i];
        sum = (sum+dp[i])%mod;
    }
    return sum;
}
```

**第一次错误解法**

第一次提交,动规,77/88,超出内存限制
修改后要么超出内存,要么超时

```c++
class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        vector<vector<int>> dp(arr.size(),vector<int>(arr.size(),INT_MAX));
        long long sum = 0;
        long long mod = 1e9 + 7;
        for(int i=arr.size()-1;i>=0;i--){
            for(int j=i;j<arr.size();j++){
                if(i==j) dp[i][j] = arr[i];
                else{
                    dp[i][j] = min(dp[i+1][j-1],min(arr[i],arr[j]));
                }             
            }
        }
        for(int i=0;i<arr.size();i++){
            for(int j=i;j<arr.size();j++){      
                sum = (sum+dp[i][j])%mod;
            }
        }
        return sum;
    }
};
```

