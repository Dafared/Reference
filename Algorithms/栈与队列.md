> 1.栈实现队列
> 输入栈＋输出栈
> pop:弹出输出栈栈顶
> 如输出栈为空,把输入栈中数据弹到输出栈
> peek:复用pop,弹出栈顶后再压入输出栈
>
> 2.队列实现栈
> push正常入队
> pop 将队列除了最后添加进来的元素以外的其他元素出队并重新入队
>
> 3.括号匹配,匹配则弹出栈中左括号,继续遍历
> 不匹配的情况:
>
> - 栈在遍历完字符串后不为空
> - 没遍历完,遇到右括号但栈已经空了
> -  遇到右括号后和栈顶不匹配
>
> 4.删除相邻重复项
> 用栈遍历
> 新加入的和栈顶的相同,栈顶的出栈
> 最后输出栈中元素
> **依次弹出后需要再reverse一下**
>
> 5.逆波兰表达式求值
> 遇到运算符,出栈两个数字进行计算,结果再放回去
>
> 6.大小为K滑动窗口中的最大值
>
> 需要一个队列,可以入队,出队,并能获取到队中最大的元素:单调队列
> 队列头(左边)放最大的元素,从队头到队尾单调递减
>
> 从队尾(右边)入队x时:
>
> - 如果x大于队尾元素,从队尾弹出元素,直到x<=队尾元素或队列为空,然后再入队
> - 如果x小于等于队尾元素,直接入队
>
> 从队头(左边)出队x时:
>
> - 如果x是队头元素,则弹出x
> - 否则什么也不做
>
> 7.前k个高频元素
> 先用unordered_map统计频率
> 然后使用小顶堆priority_queue筛选出前k个高频元素
> 当优先队列的size>k时弹出
>
> ```c++
> // 自定义比较器:函数对象
> class MyCmp{
> public:
>     bool operator()(const pair<int,int> &lhs, const pair<int,int> &rhs){
>         return lhs.second > rhs.second;
>     }
> };
> priority_queue<pair<int,int>, vector<pair<int, int>>, MyCmp> q;
> 
> // 自定义比较器:lambda表达式
> auto cmp = [](const pair<int,int> &lhs, const pair<int,int> &rhs) -> bool{
>     return return lhs.second > rhs.second;
> };
> priority_queue<pair<int,int>, vector<pair<int, int>>, decltype(cmp)> q;
> ```
>
> 8.字符串解码
>
> - 使用一个辅助栈`stack<pair<int,string>>`
> - 遇到数字 cur_num = cur_num*10 + c - '0';
> - 遇到字母 cur_str = cur_str + c;
> - 遇到左中括号`[`,把cur_num和cur_str压入,重置cur_num和cur_str
> - 遇到右中括号`]`,取出栈顶的num和str,把当前的cur_str重复num次后接在取出的str后面
>   然后让cur_str=拼接后的字符串
>
> 9.数据流的中位数
>
> - 使用一个大顶堆存储<=中位数的数字,一个小顶堆存储>中位数的数字
> - 接收到一个新数字,如果<=大顶堆堆顶数字,存在大顶堆中,否则存在小顶堆中
> - 如果大顶堆的size>小顶堆的size+1,大顶堆堆顶元素移入小顶堆
>   如果大顶堆的size<小顶堆的size,小顶堆堆顶元素移入大顶堆
> - 最后如果两个堆大小相同,则中位数=两个堆堆顶元素相加除以2
>   如果大顶堆的size>小顶堆的size,中位数=大顶堆堆顶元素
>
> 10.会议室Ⅱ
>
> - 方法一
>   1.对会议按照开始时间排序
>   2.建立一个按照结束时间排序的小顶堆
>   3.将最先开始的会议加入小顶堆,所需房间数=1
>   4.从第二个会议开始遍历按照开始时间排序后的会议
>   5.比较遍历到的会议的开始时间和小顶堆中结束时间最早的会议的结束时间
>   如果堆顶结束时间<=开始时间,则继续遍历
>   如果堆顶结束时间>开始时间,则所需房间数+1
>
> - 方法二
>
>   1.对会议分别按照开始时间和结束时间排序
>   得到两个存储排序后会议的vector
>   2.从第二个开始遍历按开始时间排序的会议(cur_start)
>   同时从第一个开始遍历按结束时间排序的会议(cur_end)
>   如会议cur_start的开始时间小于等于会议cur_end的结束时间
>   继续遍历这两个vector
>   否则需要增加房间数
>
> 11.数组中第k大的元素
>
> 建立大小为k的小顶堆
> 遍历数组,如果大于小顶堆堆顶,则把小顶堆堆顶弹出,然后把这个数放入小顶堆
> 最后小顶堆堆顶的元素即是数组中第k大的元素

C++中stack和queue都是容器适配器
默认的底层容器是deque
使用其他容器作为底层容器:
`std::stack<int, std::vector<int> > third;`
`std::queue<int, std::list<int>> third;`

## 1.用栈实现队列

需要两个栈,一个输入栈,一个输出栈
push:把数据入输入栈即可
pop:输出栈如果为空,则把输入栈中的数据弹到输出栈
输出栈如果不为空,则弹出输出栈的栈顶
peek:复用pop函数,用pop()获取输出栈栈顶后再把其放回输出栈中

```c++
class MyQueue {
public:
    MyQueue() {}
    
    void push(int x) {
        s_in.push(x);
    }
    
    int pop() {
        if(s_out.empty()) {
            while (!s_in.empty()) {
                s_out.push(s_in.top());
                s_in.pop();
            }
        }
        int res = s_out.top();
        s_out.pop();
        return res;
    }
    
    int peek() {
        int tmp = pop();
        s_out.push(tmp);
        return tmp;
    }
    
    bool empty() {
        return s_in.empty() && s_out.empty();
    }
private:
    stack<int> s_in;
    stack<int> s_out;
};
```

## 2.用队列实现栈

①使用两个队列,其中一个仅用来备份
push:数据入队que1
pop:把que1中除最后一个加入的元素外的其余元素出队,存入que2
之后que1最后一个元素出队,完成模拟出栈
最后把在que2中备份的数据存回que1**(只需要直接赋值即可,不用真的逐个存回去)**,情空que2以备之后使用

```c++
que1 = que2;            // 再将que2赋值给que1
while (!que2.empty()) { // 清空que2
    que2.pop();
}
```

top()直接返回队列尾的元素即可

**代码:**

```c++
class MyStack {
public:
    MyStack() {}
    
    void push(int x) {
        que1.push(x);
    }
    
    int pop() {
        int s = que1.size()-1;
        while(s--) {
            que2.push(que1.front());
            que1.pop();
        }
        int res = que1.front();
        que1.pop();
        que1 = que2;
        while(!que2.empty()) {
            que2.pop();
        }
        return res;
    }
    
    int top() {
        return que1.back();
    }
    
    bool empty() {
        return que1.empty();
    }
private:
    queue<int> que1;
    queue<int> que2;
};
```

②仅使用一个队列
一个队列在模拟栈弹出元素的时候只要将队列头部的元素(除了最后一个元素外)重新添加到队列尾部,此时再去弹出元素就是栈的顺序了

```c++
que.push(que.front());
que.pop();
```

pop代码:

```c++
int pop() {
    int s = que1.size()-1;
    while (s--) {
        que1.push(que1.front());
        que1.pop();
    }
    int res = que1.front();
    que1.pop();
    return res;
}
```

## 3.有效的括号

①左括号多余->遍历完,但栈不为空
②括号不多余,但类型对不上->出栈时类型对不上
③右括号多余->遇到右括号要出栈时发现栈已经空了

技巧:遇到左括号需要入栈时,不要把左括号本身入栈,而是**直接将其对应的右括号入栈**
这样,在遇到右括号判断是否与栈顶匹配时,直接判断是否相等即可,相比左括号本身入栈更加方便
(别忘了左括号太多的情况)

```c++
bool isValid(string s) {
    stack<char> st;
    for (char c:s) {
        if (c == '(') {
            st.push(')');
        } else if (c == '[') {
            st.push(']');
        } else if (c == '{') {
            st.push('}');
        } else {
            if (st.empty()) { // 右括号太多
                return false;
            }
            else if (st.top() == c) {
                st.pop();
            } else { // 括号不匹配
                return false;
            }
        }
    }
    if (!st.empty()) { // 左括号太多
        return false;
    }
    return true;
}
```

## 4.删除字符串中所有相邻重复项

重复项删除操作会选择两个相邻且相同的字母,并删除它们,反复执行

使用栈,元素入栈时检查是否与栈顶重复,若重复,则不入栈,并弹出当前栈顶
最终从栈中弹出剩余内容,作为结果

可以使用字符串直接作为**栈**,**使用其push_back和pop_back操作**
这样结果不需要从栈转换为字符串

```c++
string removeDuplicates(string s) {
    string res;
    for (char c : s) {
        if (res.empty() || res.back() != c) {
            res.push_back(c);
        } else {
            res.pop_back();
        }
    }
    return res;
}
```

## 5.逆波兰表达式求值

遇到运算符,出栈两个数字进行计算,结果再放回去
(逆波兰表达式没有括号)

```c++
int evalRPN(vector<string>& tokens) {
    stack<int> st;
    for (string s: tokens) {
        if (s == "+" || s == "-" || s == "*" || s == "/" ) {
            int n2 = st.top();
            st.pop();
            int n1 = st.top();
            st.pop();
            int res;
            if (s == "+") {
                res = n1+n2;
            } else if (s == "-") {
                res = n1-n2;
            } else if (s == "*") {
                res = n1 * n2;
            } else {
                res = n1 / n2;
            }
            st.push(res);
        } else {
            int n = atoi(s.c_str());
            st.push(n);
        }
    }
    return st.top();
}
```

## 6.滑动窗口中的最大值

给定一个数组 nums, 有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧, 你只可以看到在滑动窗口内的 k 个数字, 滑动窗口每次只向右移动一位, 返回移动过程中每个窗口内分别出现的最大值

**要求O(N)解决**

### 单调队列

需要一个队列,在窗口移动时,右边的元素入队,左边的元素出队
同时每次移动后,**队列告诉我们里面的最大值是什么**

que.pop(滑动窗口中移除元素的数值)
que.push(滑动窗口添加元素的数值)
que.front()就返回我们要的最大值

满足这种需求的数据结构就是单调队列

队列没必要维护窗口里的所有元素,**只需要维护有可能成为窗口里最大值的元素就可以**

单调队列维护内部元素的大小递减顺序(且也保持了在数组中位置的前后顺序)

> 对于窗口里的元素{2, 3, 5, 1 ,4},单调队列里只维护{5, 4},保持单调队列里单调递减,此时队列出口元素就是窗口里最大元素

pop和push操作要保持如下规则:(使用双端队列实现,两端都可以弹出)
(队列出口元素:队列最左边元素;队列入口元素:队列最右边元素)

pop(value):
如**窗口移除的元素value等于单调队列的出口元素**(左边最大元素),则队列左边弹出元素,否则**不用任何操作**
**push(value):**
如入队的元素大于队列入口元素,那么就将队列入口元素(从右边)弹出,直到要入队的元素<=队列入口元素为止
(如果一个更大的元素入队,则其前面所有比它小的元素都没可能成为窗口最大值,**即当前队中比它小的都要弹出**)
(注意入队时要入对的元素只要<=入口元素就行,不是<入口元素,**等于也可以,只要不比队列入口更大就行**)

**代码:**

```c++
class Solution {
public:
    struct MyQueue {
        deque<int> que;
        void push(int x) {
            // 注意x能入队的条件是x<=队尾入口元素,不是x<队尾入口元素
            // 所以入口元素小于x需要从右边弹出,等于x不需要
            while (!que.empty() && que.back() < x) {
                que.pop_back();
            }
            que.push_back(x);
        }
        void pop(int x) {
            if (!que.empty() && x == que.front()) {
                que.pop_front();
            }
        }
        int front () {
            return que.front();
        }
    };
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        MyQueue que;
        for (int i=0; i<nums.size(); i++) {
            if (i < k-1) {
                que.push(nums[i]);
            } else {
                if (i >= k) {
                    que.pop(nums[i-k]);
                }
                que.push(nums[i]);
                res.push_back(que.front());
            }
        }
        return res;
    }
};
```

## 7.前k个高频元素

给定一个非空的整数数组,返回其中出现频率前 k 高的元素
时间复杂度必须优于 $O(n \log n)$,题目保证答案唯一

①要统计元素出现频率
②对频率排序
③找出前K个高频元素

①统计:使用map

②频率排序:优先级队列(一个披着队列外衣的**堆**)
使用小顶堆,用小顶堆遍历统计频率的map,当小顶堆(优先队列)中**元素>k时就弹出堆顶频率最小的元素**
最后小顶堆中保留下来的k个元素就是前K个高频元素

```c++
class mycomparison {
    public:
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};

// 定义一个小顶堆,大小为k
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
```

C++中的优先队列
定义:`priority_queue<Type, Container, Functional>`

```c++
//greater和less是std实现的两个仿函数
//队头(出队)到队尾(入队)升序队列,小顶堆
priority_queue <int,vector<int>,greater<int> > q;
//队头(出队)到队尾(入队)降序队列,大顶堆
priority_queue <int,vector<int>,less<int> >q;
```

**代码:**

**注意使用decltype+lambda表达式作为优先队列模板参数的方法**

```c++
vector<int> topKFrequent(vector<int>& nums, int k) {
    auto cmp = [](const pair<int, int>& lhs, const pair<int, int>& rhs) -> bool {
        return lhs.second > rhs.second;};
    priority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> myque;
    unordered_map<int,int> count;
    for (int n : nums) {
        count[n]++;
    }
    for (auto it = count.begin(); it != count.end(); it++) {
        myque.push(*it);
        if (myque.size() > k) {
            myque.pop();
        }
    }
    vector<int> result(k);
    // 从后往前赋值结构数组
    for (int i=k-1; i>=0; i--) {
        result[i] = myque.top().first;
        myque.pop();
    }
    return result;
}
```

## 8.字符串解码

给定一个经过编码的字符串,返回它解码后的字符串

编码规则为: k[encoded_string]
表示其中方括号内部的 encoded_string 正好重复 k 次,k 保证为正整数

```c++
// 辅助栈法,构建一个辅助栈
/*
1.当c为数字,将数字字符转变为数字
2.当c为字母,在str_res尾部添加c
3.当c为[,将当前数字和str_res入栈(当前重复若干次的字串之前的字符串入栈)
入栈后str_res和数字重新置空
4.当c为],出栈得到数字和str_before
让res = str_before + 数字*res
str_before为该[]之前已经得到的字符串
*/
string decodeString(string s) {
    stack<pair<int,string>> st;
    string str_res;
    int cur_num = 0;
    for (char c : s) {
        if (c == '[') {
            st.push({cur_num,str_res});
            str_res = "";
            cur_num = 0;
        } else if (c == ']') {
            auto tmp = st.top();
            st.pop();
            string str_before = tmp.second;
            int num = tmp.first;
            while (num--) {
                str_before = str_before + str_res;
            }
            str_res = str_before;
        } else if ('0' <= c && c <= '9') {
            cur_num = cur_num*10 + c-'0';
        } else {
            str_res = str_res + c;
        }
    }
    return str_res;
}
```

## 9.数据流的中位数

1.维护2个优先队列(堆)

①q1,一个大顶堆,存储小于等于中位数的数
②q2,一个小顶堆,存储大于中位数的数

当加入的数字num<=第一个优先队列最大者(大顶堆堆顶)
加入第一个优先队列,否则加入第二个队列
(第一次加到第一个优先队列中)

当`q2.size() > q1.size()`,需要把第一个队列最大值移入第二个队列
当`q2.size() < q1.size() - 1`,需要把第二个队列中最小数移入第一个队列

若为奇数,即第一个队列元素更多,则中位数为第一个优先队列队头(堆顶)
否则为偶数,则中位数为两个堆堆顶的平均值

```c++
class MedianFinder {
    priority_queue<int,vector<int>,less<int>> maxheap;
    priority_queue<int,vector<int>,greater<int>> minheap;
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if (maxheap.empty() || num <= maxheap.top()) {
            maxheap.push(num);
            if (minheap.size() < maxheap.size() - 1) {
                minheap.push(maxheap.top());
                maxheap.pop();
            }
        } else {
            minheap.push(num);
            if (maxheap.size() < minheap.size()) {
                maxheap.push(minheap.top());
                minheap.pop();
            }
        }
    }
    
    double findMedian() {
        if (maxheap.size() > minheap.size()) {
            return maxheap.top();
        } else {
            return( maxheap.top() + minheap.top())/2.0;
        }
    }
};
```

2.有序集合(multiset)+双指针

当为偶数元素,left和right分别指向两个中位数
当为奇数元素,left和right指向同一个唯一中位数

```c++
class MedianFinder {
    multiset nums;
    multiset::iterator left, right;
    
public:
    MedianFinder() : left(nums.end()), right(nums.end()) {}
    
    void addNum(int num) {
        nums.insert(num);
        int n = nums.size();
        if (n == 1) {
            left = right = nums.begin();
        } else if (n & 1) { //此时nums大小为奇数个,需要更新left,right使之指向唯一的中位数
            if (num >= *left && num < *right) {
                left++;
                right--;
            } else if (num >= *right) {
                left++;
            } else {
                right--;
            }
        } else { //此时nums大小为偶数个,需要更新left,right使之指向两个分别的中位数
            if (num < *left) {
                left--;
            } else {
                right++;
            }
        }
    }

    double findMedian() {
        return (*left + *right) / 2.0;
    }
};
```

## 10.会议室II(已知每个会议开始结束时间,求所需最小房间数)

给定一个会议时间安排的数组,每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si < ei)，
为避免会议冲突,同时要考虑充分利用会议室资源,请你计算至少需要多少间会议室,才能满足这些会议安排

```c++
// 1.优先队列
// 最小堆,按结束时间排序
// 先按开始时间对所有会议排序,把第一个会议放进优先队列
// 对之后的其他会议,检查优先队列队头即可,比较当前遍历到会议的start和队头会议的end
// 之后把新的安排加入堆中即可
// (注意用lambda定义优先队列的方法,以及小顶堆的定义方法)
int minMeetingRooms_1(vector<vector<int>>& intervals) {
    sort(intervals.begin(),intervals.end());
    auto cmp = [](const vector<int> &l, const vector<int> &r){
        return l[1]>r[1];
    };
    priority_queue<vector<int>,vector<vector<int>>,decltype(cmp)> que(cmp);
    int cur_meeting = 1;
    int num_rooms = 1;
    que.push(intervals[0]);
    while (cur_meeting < intervals.size()) {
        if (que.top()[1] <= intervals[cur_meeting][0]) {
            que.pop();
            num_rooms--;
        }
        que.push(intervals[cur_meeting]);    
        cur_meeting++;
        num_rooms++;
    }
    return num_rooms;
}

// 2.按照会议的开始和结束时间排序
// 开始指针遍历按开始时间排序的会议,结束指针同理
// 当前结束指针指向会议结束时间<=当前开始指针指向会议开始时间:
// 表示此时一个会议确实已结束,结束指针后移,开始指针后移
// 反之,则使用的房间数+1,开始指针后移
int minMeetingRooms(vector<vector<int>>& intervals) {
    sort(intervals.begin(),intervals.end());
    vector<vector<int>> sorted_end = intervals;
    sort(sorted_end.begin(),sorted_end.end(),[](
        const vector<int> &l, const vector<int> &r){
            return l[1] < r[1];
        });
    int cur_start = 1;
    int cur_end = 0;
    int num_room = 1;
    while (cur_start < intervals.size()) {
        if (intervals[cur_start][0] >= sorted_end[cur_end][1]) {
            cur_end++;
            cur_start++;
        } else {
            num_room++;
            cur_start++;
        }
    }
    return num_room;
}
```

## 11.数组中第k大元素

建立大小为k的小顶堆
遍历元素,当大于堆顶时则替换小顶堆堆顶
最后小顶堆堆顶为第k个最大元素
