想清楚局部最优是什么
如果想不到反例,那么就试一试贪心

**分饼干**

优先满足胃口大的孩子
局部最优:每一次都尽可能利用饼干尺寸,从而使全局上避免浪费

**摆动序列**

局部最优:删除每个单调向上/向下坡度区间中间的点即可
=>只要求长度,所以不用删除,只需要计算峰值顶点个数即可
=>判断是否是顶点=>左边差值和右边差值一正一负

但有特殊情况:序列中有平坡(连续几个相同)
①序列中所有数都是相同的=>只留一个
②平坡在上下坡之间:连续相等的几个数只留一个(即只算一个顶点)
③平坡在单调坡(单调非减/单调非增)中间:连续相等的几个数不算顶点

②若按刚开始一正一负的标准判断顶点,则该情况不会算入(实际算1个顶点)
可以统一删除靠左的几个(保留最右一个算作顶点)或保留最左一个作为顶点
如选择前者,则判断是顶点的条件变成:(保留平坡最右一个作为顶点)
(左边差值<=0&&右边差值>0)||(左边差值>=0&&右边差值<0)

③平坡在单调坡中间,本来不应该计算顶点,但按照②中的条件,会让顶点数+1
如在②中选择了"保留平坡最右一个",则在离开单调坡中的平坡时顶点数也会加1
解决方法:让左侧的差值不要在单调坡中途更新(即不要变成0,仍然保存进入平坡前的值)
只有在真正遇到顶点(即离开当前单调非减/单调非增的坡时)再更新为右边的差值
(由于②中顶点条件包括了左边0右边非0,所以第一次加1可以正常进行)

①刚开始初始化左边差值为0
若所有数全相同,则同样无法在②中满足顶点条件,顶点数量不会增加
若只有2个数,初始化左差值=0,右差值=nums[1]-nums[0],因此只要这两个数不相等,顶点数就会加1
另外:如果没有顶点(即所有数全相同),最后输出结果也是1,所以顶点数初始值设为1

**最大连续子序和**

当累加和变得<0时令其归0
从下一个重新开始加

**股票最佳时机Ⅱ**

把连续的几天拆分成多个一天
把所有正的日利润加起来就行

**跳跃游戏**

判断是否能到终点
局部最优:当前可以覆盖到的最远距离
在当前覆盖范围内遍历中不断更新这个局部最优,直到终点,实现全局最优

在当前最远覆盖范围内遍历,用"当前坐标+当前元素对应的最远跳远距离"与记录的最远覆盖距离比较
若前者更大,则更新最远覆盖距离. 重复该过程,直到最远覆盖距离能覆盖到终点

**跳跃游戏Ⅱ**

目标:最少的跳跃次数到终点,求最少次数
(题中已经说明总是可以到达数组的最后一个位置,不存在到不了的情况)

局部最优:当前可移动距离都尽可能多走,每跳一次跳跃次数加一,直到覆盖到终点

初始跳跃次数为0,初始的当前覆盖范围=0
遍历所有元素,在途中记录最大的"当前坐标+当前元素对应的最远跳跃距离"为下一跳最远覆盖距离
每走到当前覆盖范围最后一个时,更新当前覆盖范围为记录的下一跳最远覆盖范围,跳跃次数+1
若下一跳最远覆盖范围已经覆盖到了终点,则结束程序,返回当前跳跃次数

> 为什么需要当前覆盖范围和下一步覆盖范围,而不是和上一题一样只有一个最远覆盖范围?
> 上一题不需要知道什么时候跳,跳几次,只需要知道最后能不能覆盖到终点.
> 而本题需要明确知道是在哪些元素跳的,从而在每次跳时将跳跃次数+1,所以需要记录当前跳和下一跳分别能覆盖到的范围.
> 另外,下一跳覆盖范围指的是从上一跳落点到当前跳落点的最远覆盖范围内的某一点起跳,能跳到的最远距离.
> 因此, 下一跳覆盖范围需要遍历完当前跳最远覆盖范围才能真正确定.(遍历完才知道从本跳范围内哪一点起跳才跳得最远)

改进:每当到当前跳覆盖范围最后一个,跳跃次数直接加一,不考虑下一跳是否覆盖了终点
此外,将循环遍历范围改为倒数第二个元素及之前,而不是全部元素(最后一个及之前)
因为题目已经告诉了一定可以到最后一个,所以虽然终点不在循环的遍历范围内,但是当前坐标在超出遍历范围(i>nums.size()-2),让循环终止前的最后一跳一定跳到的是终点.(因为题目限制一定可以到终点,最后一跳一定跳到的是终点,而让终点超出遍历范围外,意味着循环结束前的最后一跳就是整个过程的最后一跳,省略了确定下一跳是不是最后一跳的判断)

**K次取反后最大化数组和**

按绝对值从大到小排列,优先把绝对值大的负数改正
若改完所有负数后仍有次数剩余且剩余次数为奇数,则反复改变绝对值最小的

**加油站**

题目保证如果有解,则是唯一解

排除无解:遍历一遍所有加油站,累计剩余油量,若总和>=0则有解,否则无解
从头开始遍历,累计剩余油量,若站在某累计剩余油量和变为负,则说明起始点不在从开头到该加油站的距离中
则从下一个加油站开始重新累计剩余油量,因为若有解一定是唯一解,则正确起始点一定在后面的加油站中间

**分发糖果**

先从左向右遍历,先满足相邻的右>左
然后从右向左遍历,满足相邻的左>右,要修改时取两次遍历赋值的较大者

**根据身高重建队列**

先按照身高降序排列,如果身高相同,则把前面人少的排前面(不要忘了身高相同的情况)
然后从左向右,逐个根据每个人前面身高大于等于人数进行调整

本题用vector较慢,建议用list/forward_list

**最少的箭射气球**

局部最优:当气球出现重叠一起射,所用弓箭最少
然按照起始位置(左边界)排序,那么就从前向后遍历气球数组,靠左尽可能让气球重复
气球重叠了,其他气球的左边界要小于所有气球的右边边界的最小值
注意是重叠气球右边界的最小值,不一定是最左边气球的右边界!如果重叠,要不断更新右边界最小值
若不重叠,minright=该不重叠区间右边界

注意:sort函数的自定义比较器形参需要设为引用类型,否则太慢

**无重叠区间**

题目即求重叠区间的数量
首先也需要按照左边界或右边界排序

若按右边界排序,则先求出不重叠的区间数量,用总区间个数-不重叠的区间数量
则遇到左边界大于记录的最大的右边界,则不重叠数量+1并更新最大右边界(maxright)

若按左边界排序,则可以直接求出重叠区间数量
若重叠则记录重叠区间内最小的右边界(minright),并将重叠区间+1(类似上一题的方法)
若不重叠,minright=该不重叠区间右边界

>用例`[[1,10],[2,3],[4,5]]`,按照左边界排序
>
>看似,在处理完`[2,3]`之后,res+=1,minright会变成3,导致`[4,5]`不会被看作与`[1,10]`重叠的
>但是,题目问的能去除的最小区间,因此要去掉`[1,10]`而不是后两个,结果为1是正确的
>理解错误原因:当处理到`[2,3]`时,判断重叠,重叠区间数量+1,此时重叠的情况是`[1,10]`和`[2,3]`重叠,后续可能会去掉`[1,10]`,也可能去掉`[2,3]`(被去掉的区间不一定是`[2,3]`)

**合并区间**

先按照左边界排序,然后将第一个区间存入结果vector中
将从第二个区间开始遍历的每个区间的左边界与结果vector中最后一个区间的右边界比较
若前者<=后者,则可以合并,将vector中最后一个区间右边界更新为其值与遍历到的区间的右边界中的较大者
若前者>后者,则不相邻/重叠,不能合并,将遍历到的区间加入结果vector

> 这三道题目,前两道求的都是有哪些区间是重叠的,重叠的区间有多少,解法类似:
>
> **①若按左边边界排序,可求出重叠区间的数量**
> 已知之前已有若干个区间重叠,遍历到一个新区间.只知道新区间左边界比之前的所有左边界都大,但无法直接看出新区间左边界与之前区间右边界的关系,因此需要记录之前若干个互相重叠区间的最小右边界,以与新区间左边界相比较;可得出两种判断结果①新区间与这些区间每一个都互相重叠②新区间与这些区间中至少一个不重叠. 若是结果②, 则之前这些互相重叠的区间只需保留一个与新区间不重叠的区间,其余删掉即可, 删掉的数量既是重叠的数量.因此按左边边界排序,方便求出重叠的区间数量.
>
> **②若按右边边界排序,可求出不重叠区间的数量**
> 已知之前已有若干个区间重叠,遍历到一个新区间.因为已知新区间右边界大于所有的这若干个重叠区间的右边界,只要新区间左边界大于上一个区间右边界(也即这些区间中最大的右边界),即可确定新区间不与之前这些互相重叠的区间相重叠; 可得出两种判断结果①新区间与这些区间中每一个都不重叠②新区间与这些区间中至少一个重叠.若是结果①,则该新区间是不重叠区间,不重叠区间数量加1,因此从按右边边界排序,方便求出不重叠的区间数量.
>
> 而第三道题只要求合并重叠区间,不需要记录具体哪些以及多少区间是重叠的,因此只需遇到与上一个合并区间重叠的就直接合并,更新合并后的区间,不重叠的另起一个新区间即可;
>
> 三道题共同点是都需要先统一按照区间一边坐标进行排序

**单调递增的数字**

暴力(超时):从数字开始从大到小逐个检查是不是符合要求

贪心:首先想到如果遇到strNum[i-1]>strNum[i],让strNum[i-1]--.strNum[i]=9,但这样会有一个问题:如果从高位到低位从左向右遍历数字,有可能出现strNum[i-2]==strNum[i-1],如果让strNum[i-1]减1,又会导致strNum[i-2]>strNum\[i-1](改了后面,前面又出问题了)

解决方法:遍历不一定非要从左向右遍历,也可以尝试从右向左遍历(因为要求的是从左向右越来越大,所以自然会出现改了右边影响左边的情况.当出现改了右边导致左边不满足条件的情况时,如果左向右遍历,影响的是已经处理过的序列;而若从右向左遍历,影响的是左边还未处理的序列,就算让左边序列也不符合要求,在之后继续向左处理时也可以解决)

> 例如332,如从左向右遍历,遍历到2时,把数字改为329,又导致前面不符合要求;
> 而若从右向左遍历,同样会先把数字改成329,然后继续往左遍历,再把329改为299
>
> 另外:在遍历中要记录从右向左遍历最后一次需要修改9的位置,其右边全部改为'9',不能只修改一个

**划分字母区间**

在遍历的过程中相当于是要找每一个字母的边界
如果找到之前遍历过的所有字母的最远边界,说明这个边界就是分割点了

①统计每一个字符最后出现的位置
②从头遍历字符,遍历过程中收集本区间出现的字母,同时检查是否到达了某个本区间出现过的字母的最远出现位置.
当遍历范围已经经过(找到)了该区间内所有字符的最远出现位置,此处即为本区间和后面的分割点

> 例如,本区间出现过的字母只有a,b,c,d,e,到下标i时,之前已经经过a,b,c,d的最远出现位置,且发现此处(下标i)为字母e的最远出现位置,则可以说明此处为区间结束点(与后面分割点),字母a,b,c,d,e只出现在本区间中

**监控二叉树**

一个摄像头可以覆盖上中下三层.首先,为了不浪费监视范围,摄像头不能放在根节点和叶子节点
然后,需要选择从叶子节点从下往上遍历or从头结点从上往下遍历,因为从下往上遍历第一步可以确定叶子节点不放摄像头,而从上往下遍历第一步仅可确定根节点不放摄像头,由于叶子节点更多,所以前者更合适,用后序遍历

最后,还需实现在遍历过程中隔两个节点放一个摄像头
设节点三个状态,无覆盖(0),有摄像头(1),有覆盖(2)

递归终止操作:
为了不在叶子节点放置摄像头,而是在叶子节点的父节点放,需要将空节点设为"有覆盖"状态(遇到空节点递归返回2)

单层处理:
①左右孩子均返回2,则该点无覆盖,返回0
②左右孩子中至少一个是无覆盖(至少一个返回0),则该点要放摄像头,返回1
③左右孩子没有无覆盖(0)且至少一个有摄像头(返回1),则该节点被覆盖,返回2
④处理完只剩头结点时,出现头结点无覆盖的情况:在头结点放置摄像头