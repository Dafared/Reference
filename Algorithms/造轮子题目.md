[TOC]

## 1.LRU

我们可以从题中所需的 key-value 类型数据中得出我们可能需要使用的数据结构是**哈希表**

基础的哈希表虽具备读写 key-value 数据的功能,但是 key 的存储是无序的
而本题当 LRU 存满时,再次存储时需删除最久未使用的数据,这就需要数据结构能够保存特定的顺序信息
因此,我们可以考虑一种**有序的哈希表**

通常,会用双向链表去记录哈希表中键的顺序,每个键都有拥有指向前一个键的指针和指向后一个键的指针
当进行 set & get 操作时,只需要把当前节点调整到链表尾,而需要 pop 操作的时候,将链表首弹出即可

**第一版:大测试用例超时**

```c++
class LRUCache {
public:
    LRUCache(int capacity):capacity_(capacity), size_(0){}
    
    int get(int key) {
        if(data_map.find(key)!=data_map.end()){
            use_order.splice(use_order.begin(),use_order,
                find(use_order.begin(),use_order.end(),key));
            return data_map[key];
        }
        return -1;
    }
    
    void put(int key, int value) {
        if(data_map.find(key)==data_map.end()){
            if(size_==capacity_){
                data_map.erase(*(--use_order.end()));
                use_order.erase(--use_order.end());
                size_--;
            }
            use_order.push_front(key);
            size_++;
        }
        else{
            use_order.splice(use_order.begin(),use_order,
                find(use_order.begin(),use_order.end(),key));
        }
        data_map[key] = value;
    }
private:
    unordered_map<int,int> data_map;
    list<int> use_order;
    int capacity_;
    int size_;
};
```

原因:list寻找太耗时
解决方法:用map存储对应key在链表中的迭代器

**改进版1:用index_map存储list中迭代器**

```c++
class LRUCache {
public:
    LRUCache(int capacity):capacity_(capacity), size_(0){}
    
    int get(int key) {
        if(data_map.find(key)!=data_map.end()){
            use_order.splice(use_order.begin(),use_order,index_map[key]);
            return data_map[key];
        }
        return -1;
    }
    
    void put(int key, int value) {
        if(data_map.find(key)==data_map.end()){
            if(size_==capacity_){
                data_map.erase(*(--use_order.end()));
                index_map.erase(*(--use_order.end()));
                use_order.erase(--use_order.end());
                size_--;
            }
            use_order.push_front(key);
            index_map[key] = use_order.begin();
            size_++;
        }
        else{
            use_order.splice(use_order.begin(),use_order,index_map[key]);
        }
        data_map[key] = value;
    }
private:
    unordered_map<int,int> data_map;
    unordered_map<int,list<int>::iterator> index_map;
    list<int> use_order;
    int capacity_;
    int size_;
};
```

**改进版2:手动实现**

## 2.LRU-K

LRU-1即LRU

`K-distance`定义:
如果一个数出现次数达到了K次,那么k-distance就是倒数第K次出现的位置
如果一个数出现不到K次,那么k-distance就是+inf
<img src=".\images\lruk1.png" alt="lruk1" style="zoom: 20%;" />

驱逐kdistance最大的
如果有多个kdistance最大且相同的,则驱逐最后一次出现时间最早的页面

## 3.LFU

要求get和put达到O(1)复杂度

**1.使用若干个双向链表+2个unordered_map:**

给每个频率(使用次数)对应一个双向链表
链表有虚拟头节点(哨兵结点)dummy
链表中的顺序表示对应值最近一次被使用的时间次序

> 驱逐时,只需要找到最低使用频率对应的那个链表,从中驱逐链表尾部的结点即可
> 在同一个链表中,表示使用频率(次数)相同
> 越靠近尾部,表示最近一次使用时间越早

链表存储的Node中有①key②value③fre④next和pre指针

需要2个哈希表①key到Node(的指针)②频率到对应的链表
另外需要一个min_fre变量,表示当前缓存中最小的频率值

get() 使用key到node的哈希表获取node
并将该node从原来所属的链表中拿出来,加入fre+1对应的**链表头部**
如之前的链表在该node被拿走后为空,则需要释放内存,并更新min_fre变量

put() 如果存在,更新node中的value即可
(**注意更新value也算使用,也要执行上面的类似操作**)
不存在,如果已达到capacity,则从当前min_fre对应的链表中,拿出**链表尾部**的结点
将其删除(如删除后链表变空,需释放内存)
之后给新加入的值创建node,加入fre=1对应的链表头部,并将让min_fre=1

```c++
class LFUCache {
struct Node{
        int key;
        int value;
        int fre{1};
        Node* next{nullptr};
        Node* pre{nullptr};
        Node(int k, int v) : key(k), value(v) {};
};
public:
    LFUCache(int capacity) : capacity_(capacity){}
    
    int get(int key) {
        if (store.find(key) == store.end()) {
            return -1;
        }
        Node* node = store[key];
        remove_from_list(node);
        node->fre++;
        add_to_list(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (store.find(key) != store.end()) {
            Node* node = store[key];
            node->value = value;
            remove_from_list(node);
            node->fre++;
            add_to_list(node);
            return;
        }
        if (store.size()==capacity_) {
            Node* evict_node = lists_map[min_fre_]->pre;
            remove_from_list(evict_node);
            store.erase(evict_node->key);
            delete evict_node;
            evict_node = nullptr;
        }
        min_fre_ = 1;
        Node* new_node = new Node(key,value);
        add_to_list(new_node);
        store[key] = new_node;
    }
    
private:
    // 加入结点使用频率对应链表,如链表为空需要创建
    void add_to_list(Node* node) {
        if (lists_map.find(node->fre)==lists_map.end()) {
            Node* dummy = new Node(-1,-1);
            dummy->next = dummy;
            dummy->pre = dummy;
            lists_map[node->fre] = dummy;
        }
        Node* dummy = lists_map[node->fre];
        node->pre = dummy;
        node->next = dummy->next;
        dummy->next->pre = node;
        dummy->next = node;
    }
    
	// 从结点所属链表中删除结点,如链表删除后为空,需要清除
    void remove_from_list(Node* node) {
        node->next->pre = node->pre;
        node->pre->next = node->next;
        Node* dummy = lists_map[node->fre];
        if (dummy->pre == dummy) {
            lists_map.erase(node->fre);
            delete dummy;
            dummy = nullptr;
            if (node->fre==min_fre_) {
                min_fre_++;
            }
        }
    }

    int capacity_;
    int min_fre_{1};
    unordered_map<int,Node*> store;
    unordered_map<int,Node*> lists_map;
};
```

**2.使用set(有序)+unordered_map:**

set是有序的容器,底层是红黑树

定义一个node,存储key,value,fre和time(最近一次使用的逻辑时间戳)
node类型中重载<运算符,用于set实现排序

(**注意set和priority_queue自定义比较符时的区别**)

注意别忘了operator<()需要是const函数

```c++
bool operator < (const Node& rhs) const {
    return cnt == rhs.cnt ? time < rhs.time : cnt < rhs.cnt;
}
```

定义一个unordered_map,实现key到node的映射
定义一个set,存储node
直接存储node而不是node的指针

get()时,除更新unordered_map中的node外
将对应node从set中删除,更新time和fre后重新加入set

put()时:

若存在,类似get(),更新unordered_map中node
将对应node从set中删除,更新value,time和fre后重新加入set

若不存在,若以达到capacity需要驱逐
需要驱逐的node为set中第一个node(begin()迭代器所指位置)
从set和unordered_map中删除该key对应node
之后创建新结点,加入set和unordered_map

(删除和添加时记得对set和unordered_map都要操作)

```c++
class LFUCache {
struct LFUNode{
    int key;
    int value;
    int time;
    int freq;
    LFUNode() {};
    LFUNode(int k, int v, int t) : key(k), value(v), time(t), freq(1) {}
    bool operator<(const LFUNode &r) const {
        return freq == r.freq ? time < r.time : freq < r.freq;
    }
};
public:
    LFUCache(int capacity) : capacity_(capacity) {}
    
    int get(int key) {
        if (store.find(key) == store.end()) {
            return -1;
        }
        LFUNode node = store[key];
        store.erase(key);
        node_set.erase(node);
        node.freq++;
        node.time = time_now++;
        node_set.insert(node);
        store[key] = node;
        return node.value;
    }
    
    void put(int key, int value) {
        if (store.find(key) != store.end()) {
            LFUNode node = store[key];
            store.erase(key);
            node_set.erase(node);
            node.value = value;
            node.freq++;
            node.time = time_now++;
            node_set.insert(node);
            store[key] = node;
            return;
        }
        if (store.size() == capacity_) {
            LFUNode evict_node = *node_set.begin();
            store.erase(evict_node.key);
            node_set.erase(evict_node);
        }
        LFUNode new_node(key,value,time_now++);
        store[key] = new_node;
        node_set.insert(new_node);
    }
private:
    int capacity_;
    int time_now{0};
    unordered_map<int,LFUNode> store;
    set<LFUNode> node_set;
};
```

## 4.线程池

```c++
struct ThreadPoolTask
{	
    // 表示一个符合以下形式的可调用对象
    // 函数签名符合void(std::shared_ptr<void>),即接受一个std::shared_ptr<void>类型的参数,并且没有返回值
    std::function<void(std::shared_ptr<void>)> fun;
    std::shared_ptr<void> args;
};

static pthread_mutex_t lock;
static pthread_cond_t notify;
std::vector<pthread_t> ThreadPool::threads;
std::vector<ThreadPoolTask> ThreadPool::queue;

int ThreadPool::threadpool_create(int _thread_count, int _queue_size) {
    thread_count = 0;
    queue_size = _queue_size;
    head = tail = count = 0;
    shutdown = started = 0;
    
    threads.resize(_thread_count);
    queue.resize(_queue_size);
    
    for (int i = 0; i < _thread_count; ++i) {
        if(pthread_create(&threads[i], NULL, threadpool_thread, (void*)(0)) != 0) 
        {
            return -1;
        }
        ++thread_count;
        ++started;
    }
    
    return 0;
}

int ThreadPool::threadpool_add(std::shared_ptr<void> args, std::function<void(std::shared_ptr<void>)> fun) {
    
    int next = 0;
    pthread_mutex_lock(&lock);
    next = (tail + 1) % queue_size;
	if(count == queue_size) {
        // 队列满
        pthread_mutex_unlock(&lock);
        return -1;
    }
    queue[tail].fun = fun;
    queue[tail].args = args;
    tail = next;
    ++count;
    
    pthread_cond_signal(&notify);
    pthread_mutex_unlock(&lock);
}

void *ThreadPool::threadpool_thread(void *args)
{
    while (true)
    {
        ThreadPoolTask task;
        pthread_mutex_lock(&lock);
        while((count == 0)) 
        {	
            // 没有任务,在队列上等待
            pthread_cond_wait(&notify, &lock);
        }
        if((shutdown == immediate_shutdown) ||
           ((shutdown == graceful_shutdown) && (count == 0)))
        {	
            // 线程池需要停止
            break;
        }
        task.fun = queue[head].fun;
        task.args = queue[head].args;
        queue[head].fun = NULL;
        queue[head].args.reset();
        head = (head + 1) % queue_size;
        --count;
        pthread_mutex_unlock(&lock);
        (task.fun)(task.args);
    }
    --started;
    pthread_mutex_unlock(&lock);
    pthread_exit(NULL);
    return(NULL);
}

int ThreadPool::threadpool_destroy(ShutDownOption shutdown_option) {
   shutdown = shutdown_option;
   pthread_cond_broadcast(&notify); 
   for(i = 0; i < thread_count; ++i)
   {
       pthread_join(threads[i], NULL);
   }
   pthread_mutex_lock(&lock);
   pthread_mutex_destroy(&lock);
   pthread_cond_destroy(&notify);
   return 0;
}
```

## 5.智能指针

### shared_ptr

拷贝构造函数:拷贝成员,调用引用计数-1的函数

移动构造函数:拷贝成员,另一个对象的成员值nullptr

```c++
template<typename T>
class smart
{
private:
	T* _ptr;
	int* _count; //reference couting

public:
	//构造函数
	smart(T* ptr = nullptr) :_ptr(ptr)
	{
		if (_ptr)
		{
			_count = new int(1);
		}
		else
		{
			_count = new int(0);
		}
	}

	//拷贝构造
	smart(const smart& ptr)
	{
		if (this != &ptr)
		{
			this->_ptr = ptr._ptr;
			this->_count = ptr._count;

			(*this->_count)++;
		}
	}

	//重载operator=
	smart& operator=(const smart & ptr)
	{
		if (this->_ptr == ptr._ptr)
		{
			return *this;
		}
		if (this->_ptr)
		{
			(*this->_count)--;
			if (*this->_count == 0)
			{
				delete this->_ptr;
				delete this->_count;
			}
		}
		this->_ptr = ptr._ptr;
		this->_count = ptr._count;
		(*this->_count)++;
		return *this;
	}

	//operator*重载
	T& operator*()
	{
		if (this->_ptr)
		{
			return *(this->_ptr);
		}
	}

	//operator->重载
	T* operator->()
	{
		if (this->_ptr)
		{
			return this->_ptr;
		}
	}

	//析构函数
	~smart()
	{
		(*this->_count)--;
		if (*this->_count == 0)
		{
			delete this->_ptr;
			delete this->_count;
		}
	}
	//return reference couting
	int use_count()
	{
		return *this->_count;
	}
};
```

### unique_ptr

```c++
template<typename T>
class UniquePtr
{
public:
	UniquePtr(T *pResource = NULL)
		: m_pResource(pResource)
	{

	}

	~UniquePtr()
	{
		del();
	}
    
    // 移动构造
    UniquePtr(UniquePtr&& rhs) noexcept {
        m_pResource = rhs.m_pResource;
        rhs.m_pResource = NULL;
    }
    // 移动赋值
    UniquePtr& operator=(UniquePtr&& rhs) noexcept {
        m_pResource = rhs.m_pResource;
        rhs.m_pResource = NULL;
        return *this;
    }

public:
	void reset(T* pResource) // 先释放资源(如果持有), 再持有资源
	{
		del();
		m_pResource = pResource;
	}

	T* release() // 返回资源，资源的释放由调用方处理
	{
		T* pTemp = m_pResource;
		m_pResource = nullptr;
		return pTemp;
	}

	T* get() // 获取资源，调用方应该只使用不释放，否则会两次delete资源
	{
		return m_pResource;
	}

public:
	operator bool() const // 是否持有资源
	{
		return m_pResource != nullptr;
	}

	T& operator * ()
	{
		return *m_pResource;
	}

	T* operator -> ()
	{
		return m_pResource;
	}

private:
	void del()
	{
		if (nullptr == m_pResource) return;
		delete m_pResource;
		m_pResource = nullptr;
	}

private:
	UniquePtr(const UniquePtr &) = delete; // 禁用拷贝构造
	UniquePtr& operator = (const UniquePtr &) = delete; // 禁用拷贝赋值

private:
	T *m_pResource;
};
```

## 6.排序

### 冒泡

```c++
int i = n-1;
int last_exchange;
while (i > 0) {
    last_exchange = 0;
    for (int j=0; j<i; j++) {
        if (nums[j] > nums[i]) {
            swap(nums[j],nums[i]);
            last_exchange = j;
        }
        i = last_exchange;
    }
}
```

### 快排

```java
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        quickSort(nums, 0, nums.size()-1);
        return nums;
    }
    void quickSort(vector<int>& nums, int left, int right) {
        if (left >= right) {
            return;
        }
        // 产生随机基准下标,基准交换到最前面left处
        srand(time(0));
        int rand_index = rand() % (right - left + 1) + left;
        swap(nums[left], nums[rand_index]);
        int pivot = nums[left];
		
        // less:从left+1开始从前到后存储小于基准的数组元素
        // more:从right开始从后往前存储大于基准的数组元素
        // i:从前到后遍历整个数组(除基准外)的所有元素
        int less = left;
        int more = right + 1;
        int i = left + 1;
        while (i < more) {
            if (nums[i] < pivot) {
                less++;
                swap(nums[i], nums[less]);
                i++;
            } else if (nums[i] == pivot) {
                i++;
            } else {
                more--;
                swap(nums[i], nums[more]);
            }
        }
        // 遍历结束后,整个数组从left+1开始的发布如下(left是基准pivot)
        // 小于pivot的区间: [left + 1, less]
        // 等于pivot的区间: [less + 1, i]
        // 大于pivot的区间: [more, right]
        
        // less处为小于pivot,和left处pivot交换
        swap(nums[left], nums[less]);
       
        // 交换后的区间情况如下:
        // 小于pivot的区间: [left, less - 1]
        // 等于pivot的区间: [less, i]
        // 大于pivot的区间: [more, right]
        quickSort(nums, left, less-1);
        quickSort(nums, more, right);
    }
};
```

### 堆排序

堆排序:(以大顶堆为例)

所有操作都涉及到自上向下和自底向上调整以维护堆的性质

①建堆,从堆的二叉树下面第一个由孩子的节点(下标n/2-1)开始到堆第一个节点,向下维护堆的性质
②排序,依次把堆顶的元素和数组后面的元素交换,从新的堆顶开始对剩下元素组成的堆维护堆的性质

> 每次输出堆顶后进行该调整,可以让下次堆顶仍然是最大的
> 最终这个数组本身也会被升序排列

③插入,放在末尾,然后从末尾开始自下往上维护堆的性质
④删除:要删除的数和末尾交换,size--,然后从目标位置开始向上/向下维护堆性质
(目标位置是叶子:向上;目标位置非叶子:向下;避免排序:up和down都调用一下)

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int n;
const int N = 100010;
int h[N], size_;

void down(int u) {
    int t = u;  // t记录最小值
    // 左儿子存在,且值比父亲小
    if (2 * u <= size_ && h[2 * u] < h[t]) t = 2 * u; 
    // 右儿子存在，且值比父亲小
    if (2 * u + 1 <= size_ && h[2 * u + 1] < h[t]) t = 2 * u + 1; 
    if (t != u) {
        swap(h[t], h[u]);
        down(t);
    }
    return;
}

void up(int u) {
    if (u / 2 > 0 && h[u / 2] > h[u]) {
        swap(h[u / 2], h[u]);
        up(u / 2);
    }
    return;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i ++) cin >> h[i]; 
    size_ = n;

    // 初始化堆
    for (int i = n / 2; i > 0; i --) down(i); 

    while(n --) {
        cout << h[1] << " ";
        h[1] = h[size_];
        size_ --;
        down(1); 
    }
   
    
    // 插入一个数
    heap[++size_] = x; up(size_);
    
    // 删除集合中任意一个数
    heap[k] = heap[size_]; size_ --; down(k); up(k);
    
    // 修改集合中任意一个数
	heap[k] = x; down(k); up(k);
    
    /*
    在删除数组中一个数时
    因为我们删除末尾元素是很方便的,但删除中间的不是很方便
    所以我们先把末尾元素赋值给当前要删的位置,然后总长度减一
    最后再down(k)一下,up(k)一下
    这两个函数实际上只会执行一个,都写上可以省去分类讨论
    */
    
    return 0;
}
```

建堆复杂度O(n)

> 在建堆的过程中,实际的比较和交换操作次数比表面上的每个节点的 O(log⁡n)复杂度要少

维护堆的性质O(logn)
堆排序O(nlogn)

使用场景:
1.需要稳定的时间复杂度
2.内存空间有限,数据量大,求topk
3.动态维护和获取最大最小值(优先级问题)

## 7.单例模式

见设计模式pdf

## 8.模板编程(vector)

https://developer.aliyun.com/article/1027468

> 可以对内置数据类型以及自定义数据类型的数据进行存储
> 将数组中的数据存储到堆区
> 构造函数中可以传入数组的容量
> 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
> 提供尾插法和尾删法对数组中的数据进行增加和删除
> 可以通过下标的方式访问数组中的元素
> 可以获取数组中当前元素个数和数组的容量

```c++
#pragma once
#include<iostream>
using namespace std;
template<class T>
class Arrays
{
private:
	T* arr;//数组arr存放T类型的数据
	int capacity;//数组容量
 	int size;//数组大小
    
    void resize()
    {
        this->capacity *= 2;
        T* newArr = new T[this->capacity];
        for (int i = 0; i < this->size; i++)
        {
            newArr[i] = this->arr[i];
        }
        delete[] this->arr;
        this->arr = newArr;
    }

public:
    Arrays(int capacity)
    {
      this->capacity = capacity;
      this->size = 0;
      this->arr = new T[this->capacity];
    }
    ~Arrays()
    {
      if (this->arr != NULL)
      {
        delete []this->arr;
        this->arr = NULL;
      }
    }
    Arrays(const Arrays& p)
    {
        this->capacity = p.capacity;
        this->size = p.size;
        this->arr = new T[p.capacity];
        for (int i = 0; i < this->size; i++)
        {
        	this->arr[i] = p.arr[i];
        }
    }
    Arrays& operator=(const Arrays& p)
    {	
        if (this != &p) 
        if (this->arr!=NULL)
        {
            delete []this->arr;
            this->arr = NULL;
            this->capacity = 0;
            this->size = 0;
        }
        //深拷贝过程
        this->capacity = p.capacity;
        this->size = p.size;
        this->arr = new T[this->capacity];
        for (int i = 0; i < p.size; i++)
        {
        	this->arr[i] = p.arr[i];
        }
        return *this;
    }
    T& operator[](int index)
    {	
        if (index < 0 || index >= this->size)
        {
            throw out_of_range("索引越界");
        }
    	return this->arr[index];
    }
    
	void insert_Arrays(const T&value)
    {
        if (this->capacity == this->size)
        {
        	resize();
        }
        this->arr[size] = value;
        this->size++;
    }
    
    void insert_at_beginning(const T& value)
    {
        if (this->size == this->capacity)
        {
            resize();
        }
        // 将元素向后移动
        for (int i = this->size; i > 0; --i)
        {
            this->arr[i] = this->arr[i - 1];
        }
        this->arr[0] = value;
        this->size++;
    }
    
    void insert_at(int index, const T& value)
    {
        if (index < 0 || index > this->size)
        {
            cout << "插入位置不合法" << endl;
            return;
        }
        if (this->size == this->capacity)
        {
            resize();
        }
        // 将元素向后移动
        for (int i = this->size; i > index; --i)
        {
            this->arr[i] = this->arr[i - 1];
        }
        this->arr[index] = value;
        this->size++;
    }
    
    void delete_Arrays()
    {
        if (this->size == 0)
        {
            return;
        }
    	this->size--;
    }
    
    void delete_at_beginning()
    {
        if (this->size == 0)
        {
            cout << "数组为空，无法删除" << endl;
            return;
        }
        // 将元素向前移动
        for (int i = 0; i < this->size - 1; ++i)
        {
            this->arr[i] = this->arr[i + 1];
        }
        this->size--;
    }
    
    void delete_at(int index)
    {
        if (index < 0 || index >= this->size)
        {
            cout << "删除位置不合法" << endl;
            return;
        }
        // 将元素向前移动
        for (int i = index; i < this->size - 1; ++i)
        {
            this->arr[i] = this->arr[i + 1];
        }
        this->size--;
    }
};
```

测试用例

```c++
#include <iostream>
#include "Arrays.h"  // 假设Arrays类保存在Arrays.h文件中

using namespace std;

int main() {
    // 初始化一个容量为 5 的数组
    Arrays<int> arr(5);

    // 1. 测试尾部插入
    cout << "测试尾部插入:" << endl;
    for (int i = 0; i < 5; ++i) {
        arr.insert_Arrays(i);
        cout << "插入 " << i << " 后数组大小: " 
            << arr.get_size() << ", 容量: " << arr.get_capacity() << endl;
    }

    // 2. 测试自动扩容 (插入超过初始容量的元素)
    cout << "测试自动扩容:" << endl;
    arr.insert_Arrays(5);
    cout << "插入 " << 5 << " 后数组大小: " << arr.get_size() 
        << ", 容量: " << arr.get_capacity() << endl;

    // 3. 测试从头部插入
    cout << "测试从头部插入:" << endl;
    arr.insert_at_beginning(-1);
    cout << "插入 -1 后第一个元素: " << arr[0] << endl;

    // 4. 测试从中间插入
    cout << "测试从中间插入:" << endl;
    arr.insert_at(3, 99); // 在索引 3 处插入 99
    cout << "插入 99 后数组大小: " << arr.get_size() << endl;
    cout << "索引 3 处的元素: " << arr[3] << endl;

    // 5. 测试边界条件 (非法索引插入)
    cout << "测试非法索引插入:" << endl;
    arr.insert_at(20, 100); // 超出范围，应该显示错误信息

    // 6. 测试删除尾部元素
    cout << "测试删除尾部元素:" << endl;
    arr.delete_Arrays();
    cout << "删除后数组大小: " << arr.get_size() << endl;

    // 7. 测试从头部删除
    cout << "测试从头部删除:" << endl;
    arr.delete_at_beginning();
    cout << "删除后第一个元素: " << arr[0] << endl;

    // 8. 测试从中间删除
    cout << "测试从中间删除:" << endl;
    arr.delete_at(2);
    cout << "删除索引 2 处的元素后，当前大小: " << arr.get_size() << endl;

    // 9. 测试边界条件 (非法索引删除)
    cout << "测试非法索引删除:" << endl;
    arr.delete_at(20); // 超出范围，应该显示错误信息

    return 0;
}
```

## 9.手写string

https://developer.aliyun.com/article/1617536

> C++ 中动态内存管理:如何正确地分配与释放内存
>
> 深拷贝与浅拷贝的区别:当对象之间共享资源时如何避免潜在问题
> (赋值运算符,拷贝构造函数)
>
> 运算符重载的实现:尤其是赋值运算符和输出运算符的重载
>
> 现代 C++ 特性:包括移动语义,右值引用等

**字符串实现:**

**1.构造函数,拷贝构造函数,赋值运算符,移动构造函数,移动赋值运算符**

**2.查找,插入和删除操作**

**3.迭代器**

```c++
namespace W
{
    class string
    {
    public:
        // 构造函数
        string(const char* str = "") {
            if (!str) str = "";
            _size = strlen(str);
            _capacity = _size;
            _str = new char[_capacity + 1];
            strcpy(_str, str);
        }

        // 深拷贝构造函数
        string(const string& s) {
            _size = s._size;
            _capacity = s._capacity;
            _str = new char[_capacity + 1];
            strcpy(_str, s._str);
        }

        // 赋值运算符重载
        string& operator=(const string& s) {
            if (this != &s) {  // 避免自我赋值
                delete[] _str;  // 释放原有内存
                _size = s._size;
                _capacity = s._capacity;
                _str = new char[_capacity + 1];  // 分配新内存
                strcpy(_str, s._str);  // 复制内容
            }
            return *this;
        }
        
        // 移动构造函数
        string(string&& s) noexcept 
            : _str(s._str), _size(s._size), _capacity(s._capacity) {
            s._str = nullptr;  // 置空源对象的数据
            s._size = 0;
            s._capacity = 0;
        }

        // 移动赋值运算符
        string& operator=(string&& s) noexcept {
            if (this != &s) {  // 避免自我赋值
                delete[] _str;  // 释放原有内存
                _str = s._str;   // 窃取资源
                _size = s._size;
                _capacity = s._capacity;

                s._str = nullptr;  // 置空源对象的数据
                s._size = 0;
                s._capacity = 0;
            }
            return *this;
        }

        // 析构函数
        ~string() {
            delete[] _str;
        }
        
        // 重载输出运算符 <<
        /*
        友元其既能够访问 W::string 类的私有成员,
        同时又能满足左侧为 std::ostream 的要求
        */
        friend std::ostream& 
            operator<<(std::ostream& os, const string& s) {
            os << s._str;
            return os;
        }
        
        // 非const迭代器
        typedef char* iterator;
        // const迭代器
        typedef const char* const_iterator;
        
        // 非const迭代器接口
        iterator begin() { return _str; }
        iterator end() { return _str + _size; }

        // const迭代器接口
        const_iterator begin() const { return _str; }
        const_iterator end() const { return _str + _size; }
        
        void reserve(size_t new_capacity) {
            if (new_capacity > _capacity) {
                char* new_str = new char[new_capacity + 1];// 分配新内存
                strcpy(new_str, _str);// 复制原字符串
                delete[] _str;// 释放旧内存
                _str = new_str;
                _capacity = new_capacity;
            }
        }
        
        // 查找字符在字符串中的第一次出现位置
        size_t find(char c, size_t pos = 0) const {
            assert(pos < _size);
            for (size_t i = pos; i < _size; ++i) {
                if (_str[i] == c) {
                    return i;
                }
            }
            return npos;  // 如果没有找到，返回 npos
        }

        // 查找子字符串在字符串中的第一次出现位置
        size_t find(const char* str, size_t pos = 0) const {
            assert(pos < _size);
            const char* p = strstr(_str + pos, str);
            if (p) {
                return p - _str;  // 计算子字符串的位置
            }
            return npos;  // 如果没有找到，返回 npos
        }
        
        // 在指定位置插入字符
        string& insert(size_t pos, char c) {
            assert(pos <= _size);  // 确保插入位置合法

            if (_size == _capacity) {
                reserve(_capacity * 2);  // 如果容量不够，扩展容量
            }

            // 将 pos 位置后的字符后移一位
            for (size_t i = _size; i > pos; --i) {
                _str[i] = _str[i - 1];
            }

            _str[pos] = c;
            ++_size;
            _str[_size] = '\0';

            return *this;
        }

        // 在指定位置插入字符串
        string& insert(size_t pos, const char* str) {
            assert(pos <= _size);

            size_t len = strlen(str);
            if (_size + len > _capacity) {
                reserve(_size + len);  // 如果容量不够，扩展容量
            }

            // 将 pos 位置后的字符后移 len 位
            // 注意下面这个写法当pos==0时会出现死循环问题
            /*for (size_t i = _size; i >= pos; --i) {
                _str[i + len] = _str[i];
            }*/
            
            //采用这种
            for (size_t i = _size; i + 1 > pos; --i) {
                _str[i + len] = _str[i];
            }


            // 复制要插入的字符串
            memcpy(_str + pos, str, len);
            _size += len;
            _str[_size] = '\0';

            return *this;
        }
        
        // 在指定位置删除若干字符
        string& erase(size_t pos, size_t len = npos) {
            assert(pos <= _size);  // 确保删除的位置合法

            if (len == 0 || pos == _size) {
                // 如果 len 为 0 或 pos 已经到达字符串末尾，无需执行任何操作
                return *this;
            }

            if (len == npos || pos + len > _size) {
                len = _size - pos;  // 确保不越界删除
            }

            // 将 pos 后 len 位字符前移
            for (size_t i = pos; i + len < _size; ++i) {
                _str[i] = _str[i + len];
            }

            _size -= len;
            _str[_size] = '\0';  // 更新字符串末尾

            return *this;
        }
        
	
    public:
        /*
        size_t 是无符号整数类型,而 -1 是有符号的整数
		在无符号整数中,-1 会被解释为最大值
		表示一个非常大的无效索引值
		这个值不可能是一个有效的索引,便于检测出错情况
		
		实际的内存限制使得不可能创建这么大的字符串
        */
        static const size_t npos = -1;
        
    private:
        char* _str;
        size_t _capacity;
        size_t _size;
    };
}

void TestString() {
    W::string s1("Hello");
    W::string s2("World");
    s2 = s1;  // 调用赋值运算符重载
}
```

## 10.读写锁

- 读者优先

  允许多个读者线程同时持有读锁
  当有写者请求写锁时,只要有读者继续请求读锁,写者就会被阻塞
  直到所有读者释放读锁且没有新的读者请求,写者才能获取写锁
  导致写者饥饿

- 写者优先

  当有写者请求写锁时,系统会优先满足写者的请求,阻止新来的读者获取读锁
  (原先的读锁仍会等待释放)
  写者完成写操作并释放写锁后,其他读者才可以获取读锁
  如果写操作频繁,读者可能饥饿

- 公平调度

  确保读者和写者按照请求的顺序获得锁

1.pthread的读写锁

默认写者优先

```c++
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

// 读锁
pthread_rwlock_rdlock(&rwlock);

// 写锁
pthread_rwlock_wrlock(&rwlock);

// 解锁
pthread_rwlock_unlock(&rwlock);
```

2.使用c++17引入的shared_mutex

若某个线程获取了独占锁,其余所有线程都无法获取独占锁和共享锁。

若某个线程获取了共享锁,其余线程只可获取共享锁却不可获取独占锁

写者优先:如果有线程请求写锁,新的读锁请求会被阻塞,直到写锁释放

```c++
class RWLatch{
public:
    void wLock() {
        mutex_.lock();
    }
    void wUnLock() {
        mutex_.unlock();
    }
    void rLock() {
        mutex_.lock_shared();
    }void rUnLock() {
        mutex_.unlock_shared();
    }
private:
    std::shared_mutex mutex_;
};
```

3.自己实现写者优先的读写锁

```c++
#pragma once
#include <atomic>
#include <mutex>
#include <condition_variable>
/*
c++11,读写锁,写优先
*/

class CRWMtx
{
public:
	CRWMtx()
	{
		m_WrCount = 0;
		m_RdCount = 0;
		m_bWriteFinished = true;
	}
	~CRWMtx(){}

	void RLock()
	{
		std::unique_lock<std::mutex> lk(m_mtx);
		//需要双重检查,可能存在m_bWriteFinished为true但是m_WrCount>0
		m_rd_cv.wait(lk, [this]{return m_bWriteFinished && (m_WrCount == 0); });
		++m_RdCount;
	}

	void RUnLock()
	{
		std::unique_lock<std::mutex> lk(m_mtx);
		--m_RdCount;
		m_rd_cv.notify_all();
	}


	void WLock()
	{
		std::unique_lock<std::mutex> lk(m_mtx);
		m_bWriteFinished = false;
		m_rd_cv.wait(lk, [this]{return (m_RdCount <= 0 && m_WrCount == 0); });
		++m_WrCount;
	}

	void WUnLock()
	{
		std::unique_lock<std::mutex> lk(m_mtx);
		if (--m_WrCount == 0)
		{
			m_bWriteFinished = true;
		}
		m_rd_cv.notify_all();
	}
private:
	std::atomic_bool m_bWriteFinished;//写结束
	std::atomic<unsigned long long> m_WrCount;//当前写数量
	std::atomic<unsigned long long> m_RdCount;//当前读数量
	std::mutex m_mtx;
	std::condition_variable m_rd_cv;
};

class CReadLock
{
public:
	CReadLock(CRWMtx &rwMtx) :m_rwMtx(rwMtx){m_rwMtx.RLock();}
	~CReadLock(){m_rwMtx.RUnLock();}
private:
	CRWMtx &m_rwMtx;
};

class CWiteLock
{
public:
	CWiteLock(CRWMtx &rwMtx) :m_rwMtx(rwMtx){ m_rwMtx.WLock(); }
	~CWiteLock(){ m_rwMtx.WUnLock(); }
private:
	CRWMtx &m_rwMtx;
};
```

## 11.前缀树

Leetcode 208

```c++
struct TrieNode{
    bool is_end;
    map<char,TrieNode*> sons;
    TrieNode():is_end(false) {};
};
class Trie {
public:
    TrieNode* root;
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        if(word.size()==0) return;
        TrieNode* curNode = root;
        for(int i=0;i<word.size();i++){
            if(curNode->sons.find(word[i])==curNode->sons.end()){
                curNode->sons[word[i]] = new TrieNode();
            }
            curNode = curNode->sons[word[i]];
        }
        curNode->is_end = true;
    }
    
    bool search(string word) {
        TrieNode* curNode = root;
        int i;
        for(i=0;i<word.size();i++){
            if(curNode->sons.find(word[i])!=curNode->sons.end()){
                curNode = curNode->sons[word[i]];
            }
            else break;
        }
        if(i==word.size()&&curNode->is_end){
            return true;
        }
        return false;
    }
    
    bool startsWith(string prefix) {
        TrieNode* curNode = root;
        int i;
        for(i=0;i<prefix.size();i++){
            if(curNode->sons.find(prefix[i])!=curNode->sons.end()){
                curNode = curNode->sons[prefix[i]];
            }
            else break;
        }
        if(i==prefix.size()) return true;
        return false;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

## 12.循环队列

**1.数组**

规定循环队列最多只能有capacity-1个元素
当循环队列中只剩下一个空存储单元时,则表示队列已满

判空条件是 rear == front

判满条件是`((rear + 1) % capacity) == front`

front=(rear+1) mod capacity

计算长度:(rear−front+capacity) mod capacity

```c++
class MyCircularQueue {
private:
    int front;
    int rear;
    int capacity;
    vector<int> elements;

public:
    MyCircularQueue(int k) {
        this->capacity = k + 1;
        this->elements = vector<int>(capacity);
        rear = front = 0;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        elements[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return elements[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return elements[(rear - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return rear == front;
    }

    bool isFull() {
        return ((rear + 1) % capacity) == front;
    }
};
```

**2.链表**

保存链表的头和尾即可

## 13.双端循环队列

**1.数组**

```c++
class MyCircularDeque {
private:
    vector<int> elements;
    int rear, front;
    int capacity;

public:
    MyCircularDeque(int k) {
        capacity = k + 1;
        rear = front = 0;
        elements = vector<int>(k + 1);
    }

    bool insertFront(int value) {
        if (isFull()) {
            return false;
        }
        front = (front - 1 + capacity) % capacity;
        elements[front] = value;
        return true;
    }

    bool insertLast(int value) {
        if (isFull()) {
            return false;
        }
        elements[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    bool deleteFront() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        return true;
    }

    bool deleteLast() {
        if (isEmpty()) {
            return false;
        }
        rear = (rear - 1 + capacity) % capacity;
        return true;
    }

    int getFront() {
        if (isEmpty()) {
            return -1;
        }
        return elements[front];
    }

    int getRear() {
        if (isEmpty()) {
            return -1;
        }
        return elements[(rear - 1 + capacity) % capacity];
    }   

    bool isEmpty() {
        return rear == front;
    }

    bool isFull() {
        return (rear + 1) % capacity == front;
    }
};
```

**2.链表**

使用双向链表来模拟双端队列
