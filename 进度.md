### 7.10

**圈复杂度**

**降低圈复杂度的方法**

- 提炼函数
- 替换为更高效的数据结构/算法
- 逻辑优化
- 合并判断条件
- 使用高层次抽象工具处理可能的 `null` 值或异常情况
  减少异常检查

**魔法世界的数字咒语转换**

1.使用string接受输入的数字

2.字符串转为long long

注意负数的字符串第一个字符是'-'
需要特殊处理

```c++
for (char ch : numStr) {
    if (isdigit(ch)) {
        num = num * 10 + (ch - '0');
    }
}
if (numStr[0] == '-') {
    num = -num;
}
```

3.范围检查

用移位表示2的次方

注意num是long long,**需要用1LL而非1**

`if(num < -(1LL << 31) || num >= (1LL << 32)) {...}`

4.若为负数则取补码:**负数转为补码**

> 原码:最高位为符号位
>
> 反码:正数的反码等于本身
> 负数的反码除符号位以外,各位取反
>
> 补码:最高位为符号位,0表示正数,1表示负数
> 正数的补码等于本身,负数的补码等于反码+1
>
> **另一种补码计算方法**
> 对于任意宽度为 X 的二进制数,想要表示一个负数 **−N**
> 底层就把它当成 **2^W - N** 这个无符号整数来存

已知num是一个负数
`补码 = (1 << 32) + num;`

注意:**1 << 32要加括号,因为+的优先级大于<<**
不能是`补码 = 1 << 32 + num;`,会相当于`补码 = 1 << (32 + num);`

**同理,补码转为负数num**

`num = 补码 - (1 << 32);`

5.转换为题目要求的输出形式

5.1.把num拆成4个字节(分大端和小端的情况)

`num >> (i*8)` : 把当前需要的字节移动到末尾

`&0XFF` : 和 0X000000FF 与运算 可以只保留最后8bit(最后一字节)

```c++
unsigned char bytes[4];

for (int i = 0; i < 4; ++i) {
    if (isBigEndian) {
        bytes[3-i] = (num >> (i*8)) & 0xFF;
    } else {
        bytes[i] = (num >> (i*8)) & 0xFF;
    }
}
```

5.2按照题目要求的输出格式,格式化每个字节

拆了字节以后,每个字节转int(`(int) byttes[i]`),得到的是四个整数值
这一步需要把这些整数打印成 “04”,“0A”,“FF”,“00” 这样的两位十六进制字符串

使用stringstream:
可以使用 iostream 的格式化操纵符(hex,dec,setw,setfill,uppercase,nouppercase)
只需往 ss 里像往 cout 那样“<<”几下,就自动完成了进制切换,宽度对齐和填充字符的工作
最后一行 ss.str() 就拿到完整结果

默认情况下,`cout << hex << 4;` 会输出 `4`,而不是我们想要的 `04`

- `setw(2)`告诉流“本次输出占两个字符宽度”
- `setfill('0')`当实际内容少于两位时用字符 `'0'` 补齐

有了这两个,4就会输出为04

```c++
#include <sstream>
#include <iomanip>

stringstream ss;
for (int i=0; i<4; i++) {
    ss << uppercase << stew(2) << setfill('0') 
        << hex << (int) byttes[i] << " ";
}

string res = ss.str();
result.pop_back(); // 去掉最后的空格
return res;
```

**设备编号的魔咒**

暴力逐一检查

转为字符串:`to_string`

字符串匹配:`find("xxx")!= string::npos`

**魔法卷轴编号格式化**

若字符串中有空格
只用cin>>s读不全
**可用getline(cin, s);读取一行**

### 7.12

**IP报文头解析问题**

注意标志位有3个bit!

取到第7第8个字节

因为大端存储,标志位在高3位
所以取到这两个字节(16bits)并转为int后右移13位,再和0x7与
得到高3位的标志位

```c++
#include <iostream>
#include <string>
using namespace std;

int hexToDec(char c) {
    if (isdigit(c)) {
        return c - '0';
    } else {
      	return 10 + c - 'a';
    }
}

int process(const string &s) {
    int res = 0;
    for (int i=0; i<s.size(); i++) {
        if (s[i] == ' ') {
            continue;
        }
        res = res*16 + hexToDec(s[i]);
    }
    return res;
}

int main() {
    string ipHead;
    getline(cin, ipHead);
    string totalLen = to_string(process(ipHead.substr(6,6)));
    string flag = to_string((process(ipHead.substr(18,6)) >> 13) & 0X7);
    string ipAddress = "";
    for (int i=0; i<4; i++) {
        ipAddress = ipAddress + to_string(process(ipHead.substr(48+i*3,3))) + ".";
    }
    ipAddress.pop_back();
    cout<< totalLen << "," << flag << "," << ipAddress <<endl;
}
```

改进:先按byte拆分再解析,之后取需要的字节即可
而不是每次都用substr()拆分

- `stringstream ss(header);`
  把输入字符串header `"45 00 10 3c …"` 包装成一个流 `ss`
  这样就可以像读文件或读标准输入一样用 `>>` 操作符按空白分隔地读“单词”了
  可用`while (ss >> byteHex)`读取到每个字节
  
- `stoi(byteHex, nullptr, 16)`
  `byteHex` 此时是类似 `"45"`,`"00"`,`"3c"` 这样的两字符字符串
  `stoi(..., nullptr, 16)` 把它当作十六进制数来转换成对应的 `int`(`"3c"` → `60`,`"FF"` → `255`)
  第 2 个参数 `nullptr` 表示我们不需要记录转换后还剩下哪些字符
  
- `std::stoi` 是 C++11 标准库在 `<string>` 头文件中提供的一个函数,用来将字符串转换成整型
  第三个参数表示转换所用的进制(被转换的字符串的进制)
  
- atoi是C语言 `<cstdlib>` 里的字符串转整形函数,只支持十进制,接受一个`const char*`参数

- 单字节的数据不用考虑大端小端问题(例如ip地址四个数字中的每一个)
  因为大端是高位字节数据放在低位字节地址,**以字节为最小单位组织数据**

  > 一个字节内部的8个bit的顺序总是bit0是低地址,bit7是高地址
  > 而且CPU 读写时一次拿整个字节,不会把它拆成若干 bit 来单独排序

  但多字节数据需要考虑,例如总长度字段,有两个字节
  高位的一个字节总长度放在低地址的字节(第3字节)
  低位的一个字节总长度放在高地址的字节(第4字节)
  所以把第三字节(byes[2])左移8位后用或运算和低8位的bytes[3]合在一起
  `int totalLength = (bytes[2] << 8) | bytes[3];`

```c++
#include <iostream>
#include <string>
using namespace std;

vector<int> parseHexToBytes(const string& header) {
    vector<int> bytes;
    stringstream ss(header);
    string byteHex;
    while (ss >> byteHex) {
        bytes.push_back(stoi(byteHex, nullptr, 16));
    }
    return bytes;
}

string toIpString(const vector<int>& bytes) {
    stringstream ipStream;
    for (int i = 16; i < 20; ++i) { // 最后 4 字节
        if (i > 16) ipStream << ".";
        ipStream << bytes[i];
    }
    return ipStream.str();
}

int main() {
    string header;
    getline(cin, header);
    vector<int> bytes = parseHexToBytes(header);
    
    int totalLength = (bytes[2] << 8) | bytes[3];
    
    int flag = bytes[6] >> 5;
    
    string ip = toIpString(bytes);
    
    string res = to_string(totalLength) + "," + to_string(flag) + "," + ip;
    
    cout << res << endl;
}
```

**Leetcode7 整数反转**

- 从后往前按位逐一处理,设每次处理的数是当前最后一位
  pop = num % 10; num = num/10
  设rev是得到的反转后的数字 rev = rev*10 + pop
- 重点是判断当前rev是否移除(超出int范围)
  但又要求只能存储32位整数,不能存64位整数
  所以要判断当前的rev在`rev*10+pop`后是否还在安全范围内
  不能`rev*10+pop`后再判断
- 可以判断当前若 `rev > INT_MAX/10 || rev < INT_MIN/10` 则下一次rev一定溢出
  即,若当前rev满足`rev <= INT_MAX/10 && rev >= INT_MIN/10` 则安全
  不用担心满足这个条件,但加上pop后溢出
  因为当满足`rev == INT_MAX/10`或 `rev == INT_MIN/10` 时
  pop肯定是原来数字最左边第一位(最高位)
  因为输入原数字在int范围内,所以第一位肯定不超过2,加上也不会导致溢出

**Leetcode8 atoi实现**

- 状态机 start sign num end 四个状态
  状态转换关系用`unordered_map<string, vector<string>> table`存储
  分别储存输入空格 符号 数字 其他字符时,当前状态会转移到什么状态
- 状态机的流程包括:
  - 根据当前状态和输入转移到新状态
  - 根据状态执行当前状态对应的行为

- 状态机内sign存的是符号,**ans存的是绝对值**
  所以溢出时截断这样写:(ans是long long)
  `ans = sign == 1 ? min(ans,(long long)INT_MAX) : min(ans, -(long long)INT_MIN);`
  最后用`automaton.ans * automaton.sign;`得到最后的结果
- 别忘了写初始状态! `string state = "start";`

```cpp
class Automation{
private:
    string state = "start";
    unordered_map<string, vector<string>> table{
        {"start",{"start","sign","number","end"}},
        {"sign",{"end","end","number","end"}},
        {"number",{"end","end","number","end"}},
        {"end",{"end","end","end","end"}}
    };

    int get_nextCol(char c) {
        if (isspace(c)) {
            return 0;
        }
        if (c == '+' || c == '-') {
            return 1;
        }
        if (isdigit(c)) {
            return 2;
        }
        return 3;
    }
public:
    long long ans = 0;
    int sign = 1;

    void process(char c) {
        state = table[state][get_nextCol(c)];
        if (state == "number") {
            ans = ans * 10 + c - '0';
            ans = sign == 1 ? min(ans,(long long)INT_MAX) : min(ans,-(long long)INT_MIN);
        } else if (state == "sign"){
            sign = c == '+' ? 1 : -1;
        }
    }

};

class Solution {
public:
    int myAtoi(string s) {
        Automation automaton;
        for (char c : s) {
            automaton.process(c);
        }
        return automaton.ans * automaton.sign;
    }
};
```

**Leetcode349 两个数组交集**

一个哈希表(unordered_map)存其中一个数组

**Leetcode88 合并两个有序数组**

双指针
一个指针从nums1的最后开始往前,一个指针从nums2的最后开始往前
然后在新空间从后往前放数字

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1 = m-1;
        int p2 = n-1;
        for (int i = m+n-1; i>=0; i--) {
            if(p1 >= 0 && p2 >= 0) {
                if(nums1[p1] > nums2[p2]) {
                    nums1[i] = nums1[p1];
                    p1--;
                } else {
                    nums1[i] = nums2[p2];
                    p2--;
                }
            } else if (p1 >=0) {
                nums1[i] = nums1[p1];
                p1--;
            } else {
                nums1[i] = nums2[p2];
                p2--;
            }
        }
    }
};
```

**K0015 魔法数字格式化**

- 展开区间存储+去重+输出结果格式化

- 展开区间存储:用一个vector<pair<int,int>>存每个区间的左边界和长度
  如果只有一个数字x,则存{x-1,1}
  
- 读取横杠(-)左右两边的两个数字:使用stringstream装输入的字符串
  ```c++
  string str;
      if (str.find('-')!=string::npos){
          int l,r;
          char dash;
          stringstream ss(str);
          ss >> l >> dash >> r;
          cnt.push_back({l-1,r-l+1})
      } else {
          cnt.push_back({stoi(str)-1,1})
      }
  ```

  去重:用一个大小位9999的bool数组表示编号是否被用过
  然后遍历之前存储的区间里的每个数字
  寻找没被用过的编号
  如果当前数字本身的编号已用,则按照x=(x+1)%9999寻找可用编号,直到找到
  然后记录bool数组这个编号被使用

- 输出结果格式化:上一步中每找到一个可用的编号就按照题目要求的格式输出
  使用strringstream方便格式化(不足4位用0不足,setw,setfill)

```c++
for (const auto &p : cnt) {
    int x = p.first;
    int c = p.second;
    for (int i=0; i<c; i++) {
        // 写use[x]而不是use[x+i]
        // 因为反正use[x]为true时,x也会+1
        while (use[x]) {
            x = (x+1) % 9999;
        }
        stringstream ss;
        ss << word << "-" << setw(4) << setfill('0') << (x+1);
        result.push_back(ss.str());
        use[x] = true;
    }    
}
```

### 7.17

**魔法商城的免单争夺战**

使用一个`unordered_map<string,vector<int>>`
key为毫秒前面的时间string
value为毫秒数的数组

先提取前面的时间string 然后提取毫秒数 存入map
然后给每个key对应的所有value排序

使用到的c++api:

- 寻找string中最后一个'.'字符:`rfind('.')`
- 获取主时间部分`substr`
- 提取毫秒数:`stoi`
- 获取某一秒内所有最短的毫秒数值**`min_element()`**
  参数为vector的begin和end,返回int的指针
- 计算vector内有多少个最短毫秒数:`count()`

**神秘的符文大陆 K0029**

1.用unordered_map统计每个卷轴中每个字符的出现次数

2.用unordered_set统计每个卷轴中出现至少 n 次的字符

3.多个unordered_set求交集

```c++
// 遍历每个卷轴
for (const string& s : strings) {
    
    // 1和2,当前卷轴至少 n 次的字符存在st中
    
    // 处理多个卷轴的交集
    if (first) {
        res = st; // 第一个卷轴直接赋值
        first = false;
    } else {
        unordered_set<char> temp; // 临时存储交集结果
        for (char c : res) {
            if (st.find(c) != st.end()) {
                temp.insert(c);
            }
        }
        res = temp;
    }
}
```

4.交集结果按ASCII 码升序排序:使用set自动排序

5.转换成字符串返回

**魔力的数字 K0025**

用unordered_set去重
然后遍历set中数字,检查n-diff在set中是否存在

**魔法学徒编号 K0036**

- string的find函数返回的不是迭代器 而是下标值
  如果不存在 返回的是string::npos

- string的erase两个参数:下标int和要删除的长度

- 判断是否为字母`isalpha()`

- 大写转小写 `<cctype> tolower`

- 先用`int n; cin>>n;` 获取了一个int后
  如果直接用getline(cin,s);读取后续一行的字符串
  会把换行符读进去 导致读不到

  避免这种混用cin>>和getline导致读不到的问题:

  - cin>>读int后用`cin.get();`跳过换行符再用getline()
  - 统一使用getline(),数字用stoi()转换getline()读到的字符串

- set里面存的默认是const
  遍历时要么`for (const string &s : result) `加const
  要么直接用auto

**魔法骑士停留试炼**

使用`unordered_map<int,unordered_map<string,pair<int,int>>> month2car`
存储每个月份的车辆的停留信息

然后遍历指定月份的停车信息
用`map<int,map<int,set<string>>> getMaxMap;`找出题目要求的答案

问题:找最大用的数据结构太重了

用一次遍历＋手写比较代替多层 map<…> 排序

```c++
string best_plate;
int best_time = -1, best_cnt = -1;
for (auto &p : stats) {
    const string &plate = p.first;
    int total = p.second.first;
    int cnt   = p.second.second;
    if ( total > best_time
      || (total == best_time && cnt > best_cnt)
      || (total == best_time && cnt == best_cnt && plate < best_plate) )
    {
        best_time = total;
        best_cnt  = cnt;
        best_plate = plate;
    }
}
```

**魔法水晶的预警之声**

用一个长度为minLimits的滑动窗口遍历每个接口的访问时间
检查窗口右边元素的时间减窗口左边元素时间是否<timeSegment

**魔法刻印共鸣的符文**

交集用`unordered_map<char,int> result;`存储
int为在所有卷轴中都出现的出现次数

设每个单独卷轴的字符出现次数存在`unordered_map<char,int> count;`
则遍历result,让其中出现次数=min(result中原出现次数,count中该字符出现次数)

### 7.20

**魔法塔的全视之眼**

- 注意vector和pair不能作unordered_map的key
  因为没有提供hash函数

**魔法二进制流的目标锁定**

使用双指针滑动窗口算法

维护一个最多包含1个非目标字符的滑动窗口

```c++
#include <iostream>
using namespace std;

int main() {
    char target;
    cin >> target;
    
    string s;
    cin >> s;
    int left = 0;
    int numNeedReverse = 0;
    int res = 0;
    for (int right = 0; right < s.size(); right++) {
        if (s[right] == target) {
           res = max (res, right-left+1);
        } else {
            if (numNeedReverse == 0) {
                numNeedReverse++;
            } else {
                while (left <= right && s[left] == target) {
                    left++;
                }
                left++;
            }
        }
    }
    cout << res << endl;
    return 0;
}
```

**魔法世界的内存释放术**

使用双指针滑动窗口算法

维护一个最多包含cnt个非被占用块的滑动窗口

> **类似魔法二进制流的目标锁定**

**魔法符文中的最大三数提取**

滑动窗口

从字符串开头到结尾遍历right

如果当前right:

- 是数字
- 是负号,且下一个字符是数字

则让left = right

找到left后,right继续往后直到末尾或非数字字符
因此得到一个数字子串的left和right
用stoi转为数字即可

**魔法流量水晶的超载警报**

遍历从min到max所有窗口大小

用每个窗口大小做滑动窗口大小
遍历整个数组
当窗口中流量>threshold时结果+1

**古代预言石碑**

1.将 num 转换为二进制字符串:

```c++
string binary_str = "";
while (num > 0) {
    // 获取每一位二进制数字并拼接
    binary_str = (char)(num % 2 + '0') + binary_str;
    num /= 2;
}
```

2.滑动窗口+双指针

识别并统计每一段连续的相同字符的长度

定义双指针法的两个指针 i 和 j

- i 是当前段的起始位置
- j 是用于寻找连续字符段的末尾位置

- 固定 `i` 后,`j` 向右扩展,直到遇到不同字符为止
- 这时,`j - i` 就是当前段连续字符的长度
- 更新最大长度 `max_len = max(max_len, j - i)`
- 接下来令 `i = j`,继续寻找下一段

3.注意n的范围 需要用long long

```c++
#include <iostream>
using namespace std;

int main() {
    long long n;
    cin >> n;
    string s;
    if (n == 0 || n == 1) {
        cout << 1 << endl;
        return 0;
    }
    while (n) {
        s = (char)(n % 2 + '0') + s;
        n /= 2;
    }
    int left = 0;
    int res = 0;
    for (int right = 0; right < s.size(); right++) {
        if (s[right] == s[left]) {
            res = max(res, right-left+1);
        } else {
            while (left <= right && s[right] != s[left]) {
                left++;
            }
        }
    }
    cout << res << endl;
}
```

**统计平衡三元组**

- 从第 2 个位置(下标1)遍历j到倒数第 2 个位置
- 固定中间元素 j
- 向左和向右分别查找满足与 j 形成合法差值
- 判断 i 和 k 是否满足最终条件
- 绝对值函数: cmath头文件中abs函数

具体实现时:

- 遍历所有可能的中间索引 j,因为题设要求 i < j < k,所以 j 不能是数组首尾

- 然后对于每个j:

  - 遍历 [0, j) 区间 构建左侧候选 i 值集合
  - 遍历 (j, n) 区间 构建右侧候选 k 值集合
  - 对右侧的k候选集合进行排序 便于使用双指针查找最终满足条件的组合
  - 对每个合法的 i 元素,统计满足 `|i - k| <= numC`的 k 个数

  ```c++
  for (int i_val : valid_i) {
      int l = lower_bound(
          valid_k.begin(), valid_k.end(), i_val - numC) - valid_k.begin();//左边界
      int r = upper_bound(
          valid_k.begin(), valid_k.end(), i_val + numC) - valid_k.begin();//右边界
      count += (r - l); //区间内的元素数量即为满足条件的三元组数
  }
  ```


完整代码:

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

// 题目没有要求三元组需要去重
// 即下标不同即可,值相同也不用去重
// 先确定一个中间的,把剩下的分成两半,在两边找满足题意的另外两个
// 最后比较两边的两个,确定完全满足题意的三元组
int main() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }
    int numA, numB, numC;
    cin >> numA >> numB >> numC;
    int res = 0;
    for (int j=1; j<n-1; j++) {
        int mid = arr[j];
        
        vector<int> valid_i, valid_k;
        for (int i=0; i<j; i++) {
            if (abs(arr[i]-mid)<=numA) {
                valid_i.push_back(arr[i]);
            }
        }
        
        for (int k=j+1; k<n; k++) {
            if (abs(arr[k]-mid)<=numB) {
                valid_k.push_back(arr[k]);
            }
        }
        
        sort(valid_k.begin(),valid_k.end());
        for (int i : valid_i) {
            int left = lower_bound(
                valid_k.begin(),valid_k.end(),i-numC) - valid_k.begin();
            int right = upper_bound(
            	valid_k.begin(),valid_k.end(),i+numC) - valid_k.begin();
            res += (right - left);
        }
    }
    cout << res << endl;
}
```

### 7.24

**136只出现一次的数字**

相同数字之间异或得0

0和数字x之间异或得数字x

**137只出现一次的数字Ⅱ**

给你一个整数数组 nums ,除某个元素仅出现 一次 外,其余每个元素都恰出现 三次 
请你找出并返回那个只出现了一次的元素

除了某个元素,其他元素都是三个为一组的

所以将所有`nums[i]`对应的二进制数的对应位求和
将每一位的和值分别与3进行取模运算
得到的余数就是答案的对应二进制位的数值

> 如果输入是nums = [2,2,3,2],那么它的各个元素对应的32位二进制数就是[00000000000000000000000000000010, 00000000000000000000000000000010, 00000000000000000000000000000011, 00000000000000000000000000000010]
> 接着,对这些二进制数的对应位进行求和,得到[00000000000000000000000000000041]
> 对这个求和结果的每一位进行3的取模运算,得到[00000000000000000000000000000011]
> 把上面的结果从二进制转换为十进制,就是3

具体实现时

- for循环遍历1到32位:
- 对于获取每个数字num的从右往左第i位的和:
  `sum += (num >> i) & 1;`
- 如果sum%3==1,则说明最终结果上这一位是1
  `res |= (1 << i);`

**260只出现一次的数字Ⅲ**

两次异或遍历
[Leetcode题解](https://leetcode.cn/problems/single-number-iii/solutions/2484352/tu-jie-yi-zhang-tu-miao-dong-zhuan-huan-np9d2/)

- 第一遍:所有数字异或
  得到的结果即是那两个只出现一次的数字异或的结果

  结果中,为1的位即是这两个数字不同的位

- 选择第一遍遍历得到的异或结果中,为1的任意一位
  然后把所有数字按照这一位为0 or 为1 分为两组
  这样那两个只出现一次的数字就会被分别分到两个组中

  每一组中都会有若干重复出现两次的数字+1个只出现一次的数字

- 将每一组分别遍历,异或,得到最终结果

在实际代码中:

- 去找最低位为 1 的位置

- `sum & -sum` 的结果是 nsum的最低位的二进制

  > 比如 sum = 1011 那么它的反码是 0100 补码就是 0101
  > 1011 & 0101 = 0001 获取到了 sum 中最低位为 1 的位置
  >
  > 负数补码=反码(取反)+1
  > 如果原来低位的若干位符合"从高到低为1+连续若干个0"
  > 则取反后就是"从高到低为0+连续若干个1"
  > 再加1,因为进位,连续若干个1会变成0,这些1左边的0变为1
  > 即原数最低位的1的那个位还是1
  >
  > 再和原数进行与运算,则原数最低位的1的位置就能找到

- 特殊情况:如果sum=INT_MIN,即 sum = -2^31
  二进制位为 1000 0000 0000 0000 0000 0000 0000 0000
  取反后再加 1 会产生溢出的情况

- 注意&运算优先级低 所以`if( ( k & num ) == 0 )`中
  **k&num要加括号!**

```c++
int k = (sum == Integer.MIN_VALUE) ? sum  : sum & -sum;

 // 假设这两个只出现一次的元素分别为 a 和 b
int a = 0;
int b = 0;

// 再次遍历 nums 将 num 划分为两部分
for(int num:nums){
    // 注意&运算优先级低 所以k&num要加括号!
    if( ( k & num ) == 0 ){
        a ^= num;
    }else{
        b ^= num;
    }        
}
```

### 7.25

**魔导服务器**

排序后最中间的一台(奇数)或最中间两台中latency最小的(偶数)

**魔法阵数字的奇偶排序法则**

将奇数和偶数分别提取并排序后,再按原位重构数组

**使用sort降序排序:**

`sort(evens.begin(), evens.end(), greater<int>()); `

`greater<int>` 是定义在 `<functional>` 头文件中的函数对象(仿函数)

或者`sort(evens.rbegin(), evens.rend()); `

其他用法:在容器中作为模板参数

优先队列
`std::priority_queue<int> maxHeap;`
改成最小堆
`std::priority_queue<int,std::vector<int>,std::greater<int>> minHeap;`

自定义比较器:`struct MyComp { bool operator()(…) }`

**魔法版本的能量提升计算**

- 使用stringstream提取一个字符串中用'.'分隔的数字

  ```c++
  string s,part;
  cin >> s;
  stringstream ss(s);
  vector<int> version;
  while (getline(ss,part,'.')) {
      version.push_back(stoi(part));
  }
  ```

**升级法术包**

- 读取两个用空格分隔的字符串
  直接`cin >> s1 >> s2;`

**第三大的数**

> **要求时间复杂度O(N)**

- 一次遍历 用一个有序集合set维护前三大的数
  如果遍历中发现比set中最小数大的数,则替换

  注意:因为需要不同的三个数,需要去重
  所以num加入set时,不仅要判断num比set中原第三大数字更大
  还要判断其在set中不存在才行

  ```c++
  int thirdMax(vector<int>& nums) {
      set<int> threeBiggest;
      for (int n : nums) {
          if (threeBiggest.size() < 3) {
              threeBiggest.insert(n);
          } else {
              int third = *threeBiggest.begin();
              if (n>third && threeBiggest.find(n) == threeBiggest.end()) {
                  threeBiggest.erase(third);
                  threeBiggest.insert(n);
              }
          }
      }
      if (threeBiggest.size() == 3) {
          cout<<"!"<<endl;
          return *threeBiggest.begin();
      } else {
          return *(--threeBiggest.end());
      }
  
  }
  ```

- 一次遍历 用三个变量 abc来维护前三大的数字
  初始化为极小值

  - 如果num 大于a 则a替换为num,b替换为a,c替换为b
  - 如果num 大于b 小于a 则b替换为num, c替换为b
  - 如果num 大于c 小于b 则c替换为num

**水晶契约与发货仪式**

维护的数据结构

```c++
unordered_map<int,unordered_set<int>> personId2Items;
unordered_map<int,unordered_set<int>> item2PersonIds;
map<int,set<int>> itemNum2PersonIds;
```

### 7.27

**Trie**

树形结构

每个node对应一个char有:

- 存储下一个char到node节点指针映射的unordered_map
- 标志位isEnd,表明该node是否是一个单词的末尾

```c++
struct TrieNode{
    bool isEnd;
    unordered_map<char,TrieNode*> sons;
    TrieNode() : isEnd(false) {}
};

class Trie {
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* curNode = root;
        for (char c : word) {
            if (curNode->sons.find(c) == curNode->sons.end()) {
                curNode->sons[c] = new TrieNode();
            }
            curNode = curNode->sons[c];
        }
        curNode->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* curNode = root;
        int i;
        for (i=0; i<word.size(); i++) {
            if (curNode->sons.find(word[i]) != curNode->sons.end()) {
                curNode = curNode->sons[word[i]];
            } else {
                break;
            }
        }
        if (i == word.size() && curNode->isEnd) {
            return true;
        }
        return false;
    }
    
    bool startsWith(string prefix) {
        TrieNode* curNode = root;
        int i;
        for (i=0; i<prefix.size(); i++) {
            if (curNode->sons.find(prefix[i]) != curNode->sons.end()) {
                curNode = curNode->sons[prefix[i]];
            } else {
                break;
            }
        }
        if (i == prefix.size()) {
            return true;
        }
        return false;
    }
private:
    TrieNode* root;
};
```

**Leetcode211 添加与搜索单词**

- 使用Trie
- 处理'.':采用类似DFS的思路 对所有sons进行DFS遍历-回溯
- add单词时别忘了把最后一个节点的isEnd设为true!

```c++
struct TrieNode{
    bool isEnd;
    unordered_map<char,TrieNode*> sons;
    TrieNode() : isEnd(false) {} 
};

class WordDictionary {
public:
    WordDictionary() {
        root = new TrieNode();
    }
    
    void addWord(string word) {
        TrieNode* curNode = root;
        for (char c : word) {
            if(curNode->sons.find(c) == curNode->sons.end()) {
                curNode->sons[c] = new TrieNode();
            }
            curNode = curNode->sons[c];
        }
        curNode->isEnd = true;
    }
    
    bool search(string word) {
       return find(word,0,root);
    }

    bool find(const string &word, int indexStart, TrieNode* curNode) {
        if (indexStart == word.size()) {
            if (curNode->isEnd) {
                return true;
            }
            return false;;
        }
        char c = word[indexStart];
        bool res;
        if (c != '.') {
            if(curNode->sons.find(c) == curNode->sons.end()) {
                return false;
            }
            res = find(word,indexStart+1,curNode->sons[c]);
        } else {
            for (auto &p : curNode->sons) {
                res = find(word,indexStart+1,p.second);
                if (res) {
                    break;
                }
            }
        }
        return res;
    }
private:
    TrieNode* root;
};
```

### 7.29

**魔法装备管理系统**

题意是每个进程组都分别有proc_num个进程

数据结构:

- `vector<vector<int>> rest;`表示每个进程组中各个进程各自剩余的内存大小
- `unordered_map<int,tuple<int,int,int>>`存储设备信息
  key为设备ID,value为一个tuple,包含进程ID,设备所占内存大小和设备类型

**补充:读取tuple值**

```c++
tuple<int,int,int> info;
// ...
int n0 = get<0>(info);
int n1 = get<1>(info);
int n2 = get<2>(info);
```

**魔法卷轴封印系统**

题意要求的是必须从当前系统中时间戳最早的卷轴开始封印

- 因为需要从后面添加新的卷轴+从前面删除被打包的卷轴
  所以使用双端队列存储卷轴(**vector从前面删除效率低**)
  `deque<tuple<int, int, int>> q;`
  每个元素是一个三元组 (timestamp, fileId, fileSize)

  **注意:deque可以支持下标访问**

- 每当要打包时
  从队列首个卷轴开始遍历
  找满足总大小,时间戳差值和总数量要求的打包集合
  然后从队列中删除这些被打包的卷轴

**魔法代码量统计系统**

注意最终只需要统计产品粒度的代码量
不需要管具体的仓库

所以只需要记录仓库id到产品id的映射哈希表
以及每个产品所有仓库总的代码行数

最后排序时自定义排序规则
```c++
vector<pair<int, int>> sorted_languages(language_cnt.begin(), language_cnt.end());
sort(sorted_languages.begin(), sorted_languages.end(), 
    [](const pair<int, int>& a, const pair<int, int>& b) {
    if (a.second == b.second) {
        return a.first < b.first; // 如果行数相同按语言ID升序
    }
    return a.second > b.second; // 按代码行数降序
});
```

**魔法交错之力**

双指针

正数指针+负数指针

交替移动

正数指针每次移动到下一个正数,负数指针同理

**神秘符文的拼接**

- 二进制转换
- 按位宽补齐
- 二进制拼接
- 按每 4 位一组转换为十六进制
- 最终输出去掉前导零的十六进制字符串
  如果最终结果为空字符串则返回 `'0'`

1.二进制转换

```c++
string toBin(unsigned int v) {
        string res = "";
        while (v > 0) {
            // 每次取二进制的最低位
            res = char('0' + v % 2) + res;  
            v /= 2;
        }
        return res.empty() ? "0" : res;
    }

```

2.遍历每个数和对应的宽度
如果二进制表示的长度小于给定宽度 w,前面补充 0
然后将按位宽补齐的二进制字符串添加到s中

3.如果最终字符串s不是4的倍数
在前面补0使之成为4的倍数

4.转换成16进制字符串

- stoi的第三个参数为字符串的进制

- string的erase(pos,len)的参数:

  > 不同于vector的erase只有一个迭代器参数

  - pos:删除开始的位置下标
  - len:删除的字符数量

- string的find_first_not_of(ch)寻找第一个不是字符ch的下标
  全部都是 `ch` → 返回 `std::string::npos`(一个特别大的数，表示“没找到”)

- `ans.erase(0, min(ans.find_first_not_of('0'), ans.size()));`
  这句话的意思是去掉ans所有的前导0
  如果ans全是0,就删除ans.size()个0,将ans清空

```c++
string mp = "0123456789ABCDEF";  // 十六进制字符映射表

// 用于存储最终的十六进制结果
string ans = "";  
// 每 4 位二进制转换为 1 个十六进制字符
for (size_t i = 0; i < s.length(); i += 4) {
    // 每 4 位二进制转为十进制整数
    int num = stoi(s.substr(i, 4), nullptr, 2);
    // 转换为对应的十六进制字符
    ans += mp[num];
}

// 去掉十六进制结果开头的 0
ans.erase(0, min(ans.find_first_not_of('0'), ans.size()));

// 如果去掉 0 后为空字符串后返回 '0'
if (ans.empty()) {
    ans = "0";
}
```

**魔法森林中的符号路径**

给定一个树形结构和一个目标符号序列
在给定的树形结构中,存在若干条从根节点到叶子节点的路径
需要在这些路径中寻找满足要求的连续子路径
要求该连续子路径能通过删除若干字符(保持相对顺序)形成目标符号序列的最短路径
最后输出满足要求子路径中长度最短,字典序最小的那个

- 使用栈维护当前路径

  每读入一行节点,首先统计 |- 的数量,得到当前节点的深度
  然后维护一个栈结构 st表示当前路径：

  - 若栈深度超过当前节点深度,说明应从上一分支返回,弹出多余节点
  - 将当前节点加入栈中,构成从根到当前节点的路径

- 为判断某条路径是否匹配目标序列,使用双指针方法,按顺序扫描目标字符串
  在路径中寻找匹配字符
  这等价于判断一个序列是否是另一个序列的子序列

  遍历所有路径
  对于同一条从根节点到叶子的路径:
  由浅入深地遍历不同长度的路径
  即每读到一个节点就当作一条从根到当前节点的路径
  
  ```c++
  for (const string& s : tree_structure) {
      int cnt = count(s.begin(), s.end(), '|');  // 层级数由 '|' 的数量决定
      while (st.size() > cnt) {
          st.pop_back();  // 弹出多余的元素,回退到正确层级
      }
  
      // 提取当前节点字符(去除开头的 '|' 和 '-')
      string ch;
      for (char c : s) {
          if (c != '|' && c != '-') {
              ch += c;
          }
      }
      st.push_back(ch);
      // ...
  }
  ```
  
  对于当前遍历到的特定深度的某条路径
  
  先正向检测
  当前路径是否已经包含 target_sequence(给定目标子序列的子路径)
  
  ```c++
  // 辅助函数:检查序列 s 是否可以通过删除若干元素变成序列 t
  int match_pos(const vector<string>& s, const string& t) {
      int p = 0;  // 指向目标字符串 t 的指针
      for (int i = 0; i < s.size(); ++i) {
          if (p < t.size() && s[i][0] == t[p]) {
              p++;  // 如果匹配成功,移动指针
          }
          if (p == t.size()) {
              return i;  // 如果匹配完整个目标字符串,返回当前位置
          }
      }
      return -1;  // 无法匹配
  }
  ```
  
  如果包含,则再**从末尾往前**寻找满足匹配的连续后缀
  
  注意:由于同一条路径上,从根节点开始,浅到深的路径都会被遍历
  所以对于当前遍历到的路径,可以只看以当前路径最后一个节点作为结尾的target_sequence
  因此**从末尾开始倒着往回找,可以找到最短的**
  
  因为辅助函数`match_pos()`寻找的是符合条件的连续子路径的终点
  所以目标字符串和原完整路径字符串反转后
  寻找的就是从结尾开始,符合条件的连续子路径的起点的下标
  
  又寻找的符合条件的连续子路径以当前路径的最后一个节点结尾
  所以寻找到的从结尾开始的起点下标就是**这个连续子路径的长度k**
  
  把当前遍历到的路径末尾的k个字符拿出来
  就是当前找到的最短连续子路径
  
  ```c++
  // 反转目标序列，用于从末尾匹配
  string t_reversed = target_sequence;
  reverse(t_reversed.begin(), t_reversed.end());
  
  // ....
  
  // 判断路径是否包含目标序列
  if (match_pos(st, target_sequence) >= 0) {
      // 从末尾向前找最短有效路径
      vector<string> reversed_st = st;
      reverse(reversed_st.begin(), reversed_st.end());
      int k = match_pos(reversed_st, t_reversed) + 1;
  
      string tmp = "";
      for (int i = st.size() - k; i < st.size(); ++i) {
          tmp += st[i];  // 构造最短路径字符串
      }
  
      // 若更短或字典序更小，更新答案
      if (ans.empty() 
          || tmp.length() < ans.length() 
          || (tmp.length() == ans.length() && tmp < ans)) {
          ans = tmp;
      }
  }
  ```
  
- 用一个变量维护当前最优路径:

    - 路径长度更短

    - 若长度相同则字典序更短

### 7.30

**浮空城的魔法浮窗控制系统**

- 模拟多窗口的图形界面系统
- 新创建的窗口自动在最上层
- 支持点击事件响应,且只有最上层命中的窗口会响应
  被点击的窗口如果命中,会被提升到最上层
- 屏幕区域为 `1000 x 1000`,窗口可以部分或全部超出边界

整个系统以层级顺序管理窗口
需要支持频繁的插入,删除,顺序查找,提权(提升到最上层)操作

> 创建浮窗 create_window
> id
> row
> col
> width
> height
>
>   - 若创建成功输出 True
>   - 若 id 已存在输出 False
>
> 销毁浮窗 destroy_window
> id
>
> - 若成功销毁输出 `True`
> - 若不存在该 `id`输出 `False`
>
> 移动浮窗 move_window
> id
> row
> col
>
> - 若成功移动输出 `True`
> - 若不存在该 `id`输出 `False`
>
> 点击事件 click
> row
> col
>
> - 若命中浮窗输出该浮窗 `id`
> - 否则输出 `-1`

**使用的数据结构**

1.哈希表（HashMap）

- 用于快速定位窗口是否存在及其对应信息（位置、尺寸等）
- O(1)快速查询,创建,删除的能力
- 同时存储链表节点,可以通过哈希表快速定位到对应链表node
- 结构:`id -> [row, col, width, height, node]`

2.双向链表（Doubly Linked List）

- 维护窗口的层级顺序,每个窗口对应一个链表节点
  最上层窗口在链表尾部,最下层窗口在链表头部
- **点击操作从链表尾部向头部查**,满足从上到下命中顺序
- 点击命中时只需要把窗口的链表节点移动到链表尾部
- 实现 O(1) 的插入,删除,提升层级操作

**幻影通讯**

注意:释放通道导致更上层通道用户降级后
又可能触发更低级别的降级,依此类推

需要的数据结构

```c++
vector<int> channels;  // 每种视频类型的通道数
vector<int> charge;    // 每种视频类型的收费标准
vector<set<tuple<int, int, int>>> booked;  // 存储各类视频的预定信息时间(时间,用户ID,视频类型)
```

1.系统初始化

初始化三个数据结构

2.分配通道 `allocateChannel(time, userId, videoType)`

从传入参数所给的videoType开始,从低到高遍历三个视频类型

- 如果当前遍历到的视频类型有通道未被完全占用
  则停止向上遍历
  将 `(time, userId, videoType)` 加入对应 `booked` 集合中,返回 `True`
- 如果所有三个视频类型的通道都满,返回 `False`

3.释放通道`freeChannel(time, userId)`

遍历 `booked` 中的每一类通道,查找是否有ID为userId的用户的占用记录

如果有,则从中删除该记录
然后计算费用:`(time - start_time) × charge[request_type]`
然后将该视频类型的可用通道数量+1

**之后开始尝试降级**

从最高级别视频类型开始往下查找占用情况
寻找因为刚刚释放的低级别类型通道不足,补位到高通道的用户
将第一个找到的降级,并释放原来的高级通道

重复上述过程,直到不能降级为止

4.查询通道 `queryChannel(userId)`

遍历 `booked` 三个集合
若任一集合存在 `userId`返回该集合的下标
若未找到返回 `-1`

**Leetcode71 简化路径**

原思路:直接遍历路径字符串
遇到/跳过
遇到.统计数量
如果是夹在//中间的一个或两个点,continue或弹栈
(注意弹栈之前判断栈不为空)
其他的.加入curStr
其他字符加入curStr
如果遍历到/或遍历结束时,把curStr入栈并清空

缺点:逻辑判断复杂

改进:先把路径字符串按照`/`分段并保存到vector后再进行处理

```c++
string simplifyPath(string path) {
    vector<string> stk;
    int n = path.size(), i = 0;
    while (i < n) {
        // 跳过连续斜杠
        while (i < n && path[i] == '/') ++i;
        if (i == n) break;
        // 读取下一个段
        int j = i;
        while (j < n && path[j] != '/') ++j;
        string seg = path.substr(i, j - i);
        if (seg == "..") {
            if (!stk.empty()) stk.pop_back();
        } else if (seg != ".") {
            stk.push_back(seg);
        }
        i = j;
    }
    // 拼接结果
    if (stk.empty()) return "/";
    ostringstream oss;
    for (auto& s : stk) {
        oss << '/' << s;
    }
    return oss.str();
}
```

**Leetcode146 LRU缓存**

2个哈希表 key->value, key->链表node
1个链表,加入或使用放队头,队尾的是可以被逐出的第一个

### 8.2

**元素抗性判定**

**注意lower_bound和upper_bound底层均是二分查找**

1. 给敌方元素数组array2排序,方便后续二分查找

2. 遍历array1的元素

   对于当前遍历到的a
   使用二分法寻找array2中可能的干扰点

   - 使用 `bisect_left(array2, a - distance)` 
     找第一个可能>= `a - distance` 的下标位置 `left`
   - 如 `array2[left]` 存在并且 `|array2[left] - a| <= distance`
     说明落入干扰区间,否则安全

```c++
for (int a : array1) {
        // 使用 lower_bound 找到第一个 >= a - distance 的位置
        auto it = lower_bound(array2.begin(), array2.end(), a - distance);

        // 假设当前晶石是安全的
        bool is_safe = true;

        // 如果当前位置元素存在且在干扰范围内则该晶石不安全
        if (it != array2.end() && abs(*it - a) <= distance) {
            is_safe = false;
        }

        // 如果安全则计数
        if (is_safe) {
            count++;
        }
    }
```

**魔法通信技术**

1. 按前缀的长度分类存储禁区区间

2. 对于每种前缀长度的各个区间进行合并
   先按照start从小到大排序
   遍历并合并所有相交或相邻的区间,得到不重叠区间段
   合并后的结果分别保存其左端点数组 `left[i]` 和右端点数组 `right[i]`
   用于后续的二分查找

3. 对于每个信标编号:

   对其长度为 1~6 的前缀依次进行尝试

   对每个长度 `length`,将前缀转换为整数
   遍历该长度的区间,找是否该前缀处于某个区间内
